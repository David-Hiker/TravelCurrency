webpackJsonp([12], Array(498).concat([function(t, e, i) {
    (function(e, n) {
        "use strict";
        i(499), i(500), i(502);
        var r = i(405);
        t.exports = r.module("date-range-picker", ["daterangepicker"]).factory("$getDaterangepickerOptions", function() {
            return function() {
                return {
                    opens: "left",
                    applyClass: "btn-primary",
                    clearLabel: "清除",
                    eventHandlers: {
                        "apply.daterangepicker": function(t) {
                            t.opts.onApply && !function() {
                                var i = void 0,
                                    r = void 0,
                                    a = void 0;
                                t.opts.singleDatePicker ? (i = e(t.model), r = e(t.model)) : (i = e(t.model.startDate), r = e(t.model.endDate)), !t.opts.singleDatePicker && t.opts.ranges && n.each(t.opts.ranges, function(t, e) {
                                    i.isSame(t[0]) && r.isSame(t[1]) && (a = e)
                                }), t.opts.onApply(i, r, a, t.opts)
                            }()
                        },
                        "cancel.daterangepicker": function(t) {
                            t.opts.onApply && t.opts.onApply()
                        }
                    },
                    locale: {
                        format: "YYYY-MM-DD",
                        separator: " - ",
                        applyLabel: "确认",
                        cancelLabel: "取消",
                        customRangeLabel: "自定义",
                        daysOfWeek: ["日", "一", "二", "三", "四", "五", "六"],
                        monthNames: ["一月", "二月", "三月", "四月", "五月", "六月", "七月", "八月", "九月", "十月", "十一月", "十二月"],
                        firstDay: 1
                    }
                }
            }
        }).component("datePickButton", {
            template: '\n      <div class="btn-group btn-group-sm">\n        <a href="" class="btn btn-alt btn-default" ng-model="$ctrl.range" options="$ctrl.options" date-range-picker clearable="$ctrl.clearable">\n          {{$ctrl.label}}\n          <span class="caret"></span>\n        </a>\n      </div>\n    ',
            bindings: {
                options: "<",
                clearable: "<",
                range: "<",
                onApply: "&"
            },
            controller: ["$getDaterangepickerOptions", function(t) {
                "ngInject";
                var e = this;
                this.$onInit = function() {
                    e.options = Object.assign(t(), {
                        onApply: function(t, i, n, r) {
                            if (n)
                                e.label = n;
                            else {
                                var a = "YYYY-MM-DD";
                                r.timePicker && (a += " HH:mm"), r.singleDatePicker ? e.label = t.format(a) : e.label = t.format(a) + " - " + i.format(a)
                            }
                            e.onApply({
                                startDate: t,
                                endDate: i,
                                label: n,
                                opts: r
                            })
                        }
                    }, e.options || {}), e.range || e.options.singleDatePicker || (e.range = {
                        startDate: null,
                        endDate: null
                    }), e.options.eventHandlers["apply.daterangepicker"]({
                        model: e.range,
                        opts: e.options
                    })
                }
            }]
        })
    }).call(e, i(484), i(482))
}, function(t, e, i) {
    var n,
        r; /**
	* @version: 2.1.24
	* @author: Dan Grossman http://www.dangrossman.info/
	* @copyright: Copyright (c) 2012-2016 Dan Grossman. All rights reserved.
	* @license: Licensed under the MIT license. See http://www.opensource.org/licenses/mit-license.php
	* @website: https://www.improvely.com/
	*/






    !function(a, o) {
        n = [i(484), i(402)], r = function(t, e) {
            return a.daterangepicker = o(t, e)
        }.apply(e, n), !(void 0 !== r && (t.exports = r))
    }(this, function(t, e) {
        var i = function(i, n, r) {
            if (this.parentEl = "body", this.element = e(i), this.startDate = t().startOf("day"), this.endDate = t().endOf("day"), this.minDate = !1, this.maxDate = !1, this.dateLimit = !1, this.autoApply = !1, this.singleDatePicker = !1, this.showDropdowns = !1, this.showWeekNumbers = !1, this.showISOWeekNumbers = !1, this.showCustomRangeLabel = !0, this.timePicker = !1, this.timePicker24Hour = !1, this.timePickerIncrement = 1, this.timePickerSeconds = !1, this.linkedCalendars = !0, this.autoUpdateInput = !0, this.alwaysShowCalendars = !1, this.ranges = {}, this.opens = "right", this.element.hasClass("pull-right") && (this.opens = "left"), this.drops = "down", this.element.hasClass("dropup") && (this.drops = "up"), this.buttonClasses = "btn btn-sm", this.applyClass = "btn-success", this.cancelClass = "btn-default", this.locale = {
                direction: "ltr",
                format: "MM/DD/YYYY",
                separator: " - ",
                applyLabel: "Apply",
                cancelLabel: "Cancel",
                weekLabel: "W",
                customRangeLabel: "Custom Range",
                daysOfWeek: t.weekdaysMin(),
                monthNames: t.monthsShort(),
                firstDay: t.localeData().firstDayOfWeek()
            }, this.callback = function() {}, this.isShowing = !1, this.leftCalendar = {}, this.rightCalendar = {}, "object" == typeof n && null !== n || (n = {}), n = e.extend(this.element.data(), n), "string" == typeof n.template || n.template instanceof e || (n.template = '<div class="daterangepicker dropdown-menu"><div class="calendar left"><div class="daterangepicker_input"><input class="input-mini form-control" type="text" name="daterangepicker_start" value="" /><i class="fa fa-calendar glyphicon glyphicon-calendar"></i><div class="calendar-time"><div></div><i class="fa fa-clock-o glyphicon glyphicon-time"></i></div></div><div class="calendar-table"></div></div><div class="calendar right"><div class="daterangepicker_input"><input class="input-mini form-control" type="text" name="daterangepicker_end" value="" /><i class="fa fa-calendar glyphicon glyphicon-calendar"></i><div class="calendar-time"><div></div><i class="fa fa-clock-o glyphicon glyphicon-time"></i></div></div><div class="calendar-table"></div></div><div class="ranges"><div class="range_inputs"><button class="applyBtn" disabled="disabled" type="button"></button> <button class="cancelBtn" type="button"></button></div></div></div>'), this.parentEl = e(n.parentEl && e(n.parentEl).length ? n.parentEl : this.parentEl), this.container = e(n.template).appendTo(this.parentEl), "object" == typeof n.locale && ("string" == typeof n.locale.direction && (this.locale.direction = n.locale.direction), "string" == typeof n.locale.format && (this.locale.format = n.locale.format), "string" == typeof n.locale.separator && (this.locale.separator = n.locale.separator), "object" == typeof n.locale.daysOfWeek && (this.locale.daysOfWeek = n.locale.daysOfWeek.slice()), "object" == typeof n.locale.monthNames && (this.locale.monthNames = n.locale.monthNames.slice()), "number" == typeof n.locale.firstDay && (this.locale.firstDay = n.locale.firstDay), "string" == typeof n.locale.applyLabel && (this.locale.applyLabel = n.locale.applyLabel), "string" == typeof n.locale.cancelLabel && (this.locale.cancelLabel = n.locale.cancelLabel), "string" == typeof n.locale.weekLabel && (this.locale.weekLabel = n.locale.weekLabel), "string" == typeof n.locale.customRangeLabel && (this.locale.customRangeLabel = n.locale.customRangeLabel)), this.container.addClass(this.locale.direction), "string" == typeof n.startDate && (this.startDate = t(n.startDate, this.locale.format)), "string" == typeof n.endDate && (this.endDate = t(n.endDate, this.locale.format)), "string" == typeof n.minDate && (this.minDate = t(n.minDate, this.locale.format)), "string" == typeof n.maxDate && (this.maxDate = t(n.maxDate, this.locale.format)), "object" == typeof n.startDate && (this.startDate = t(n.startDate)), "object" == typeof n.endDate && (this.endDate = t(n.endDate)), "object" == typeof n.minDate && (this.minDate = t(n.minDate)), "object" == typeof n.maxDate && (this.maxDate = t(n.maxDate)), this.minDate && this.startDate.isBefore(this.minDate) && (this.startDate = this.minDate.clone()), this.maxDate && this.endDate.isAfter(this.maxDate) && (this.endDate = this.maxDate.clone()), "string" == typeof n.applyClass && (this.applyClass = n.applyClass), "string" == typeof n.cancelClass && (this.cancelClass = n.cancelClass), "object" == typeof n.dateLimit && (this.dateLimit = n.dateLimit), "string" == typeof n.opens && (this.opens = n.opens), "string" == typeof n.drops && (this.drops = n.drops), "boolean" == typeof n.showWeekNumbers && (this.showWeekNumbers = n.showWeekNumbers), "boolean" == typeof n.showISOWeekNumbers && (this.showISOWeekNumbers = n.showISOWeekNumbers), "string" == typeof n.buttonClasses && (this.buttonClasses = n.buttonClasses), "object" == typeof n.buttonClasses && (this.buttonClasses = n.buttonClasses.join(" ")), "boolean" == typeof n.showDropdowns && (this.showDropdowns = n.showDropdowns), "boolean" == typeof n.showCustomRangeLabel && (this.showCustomRangeLabel = n.showCustomRangeLabel), "boolean" == typeof n.singleDatePicker && (this.singleDatePicker = n.singleDatePicker, this.singleDatePicker && (this.endDate = this.startDate.clone())), "boolean" == typeof n.timePicker && (this.timePicker = n.timePicker), "boolean" == typeof n.timePickerSeconds && (this.timePickerSeconds = n.timePickerSeconds), "number" == typeof n.timePickerIncrement && (this.timePickerIncrement = n.timePickerIncrement), "boolean" == typeof n.timePicker24Hour && (this.timePicker24Hour = n.timePicker24Hour), "boolean" == typeof n.autoApply && (this.autoApply = n.autoApply), "boolean" == typeof n.autoUpdateInput && (this.autoUpdateInput = n.autoUpdateInput), "boolean" == typeof n.linkedCalendars && (this.linkedCalendars = n.linkedCalendars), "function" == typeof n.isInvalidDate && (this.isInvalidDate = n.isInvalidDate), "function" == typeof n.isCustomDate && (this.isCustomDate = n.isCustomDate), "boolean" == typeof n.alwaysShowCalendars && (this.alwaysShowCalendars = n.alwaysShowCalendars), 0 != this.locale.firstDay)
                for (var a = this.locale.firstDay; a > 0;)
                    this.locale.daysOfWeek.push(this.locale.daysOfWeek.shift()), a--;
            var o,
                s,
                l;
            if ("undefined" == typeof n.startDate && "undefined" == typeof n.endDate && e(this.element).is("input[type=text]")) {
                var c = e(this.element).val(),
                    u = c.split(this.locale.separator);
                o = s = null, 2 == u.length ? (o = t(u[0], this.locale.format), s = t(u[1], this.locale.format)) : this.singleDatePicker && "" !== c && (o = t(c, this.locale.format), s = t(c, this.locale.format)), null !== o && null !== s && (this.setStartDate(o), this.setEndDate(s))
            }
            if ("object" == typeof n.ranges) {
                for (l in n.ranges) {
                    o = "string" == typeof n.ranges[l][0] ? t(n.ranges[l][0], this.locale.format) : t(n.ranges[l][0]), s = "string" == typeof n.ranges[l][1] ? t(n.ranges[l][1], this.locale.format) : t(n.ranges[l][1]), this.minDate && o.isBefore(this.minDate) && (o = this.minDate.clone());
                    var h = this.maxDate;
                    if (this.dateLimit && h && o.clone().add(this.dateLimit).isAfter(h) && (h = o.clone().add(this.dateLimit)), h && s.isAfter(h) && (s = h.clone()), !(this.minDate && s.isBefore(this.minDate, this.timepicker ? "minute" : "day") || h && o.isAfter(h, this.timepicker ? "minute" : "day"))) {
                        var d = document.createElement("textarea");
                        d.innerHTML = l;
                        var p = d.value;
                        this.ranges[p] = [o, s]
                    }
                }
                var f = "<ul>";
                for (l in this.ranges)
                    f += '<li data-range-key="' + l + '">' + l + "</li>";
                this.showCustomRangeLabel && (f += '<li data-range-key="' + this.locale.customRangeLabel + '">' + this.locale.customRangeLabel + "</li>"), f += "</ul>", this.container.find(".ranges").prepend(f)
            }
            "function" == typeof r && (this.callback = r), this.timePicker || (this.startDate = this.startDate.startOf("day"), this.endDate = this.endDate.endOf("day"), this.container.find(".calendar-time").hide()), this.timePicker && this.autoApply && (this.autoApply = !1), this.autoApply && "object" != typeof n.ranges ? this.container.find(".ranges").hide() : this.autoApply && this.container.find(".applyBtn, .cancelBtn").addClass("hide"), this.singleDatePicker && (this.container.addClass("single"), this.container.find(".calendar.left").addClass("single"), this.container.find(".calendar.left").show(), this.container.find(".calendar.right").hide(), this.container.find(".daterangepicker_input input, .daterangepicker_input > i").hide(), this.timePicker ? this.container.find(".ranges ul").hide() : this.container.find(".ranges").hide()), ("undefined" == typeof n.ranges && !this.singleDatePicker || this.alwaysShowCalendars) && this.container.addClass("show-calendar"), this.container.addClass("opens" + this.opens), "undefined" != typeof n.ranges && "right" == this.opens && this.container.find(".ranges").prependTo(this.container.find(".calendar.left").parent()), this.container.find(".applyBtn, .cancelBtn").addClass(this.buttonClasses), this.applyClass.length && this.container.find(".applyBtn").addClass(this.applyClass), this.cancelClass.length && this.container.find(".cancelBtn").addClass(this.cancelClass), this.container.find(".applyBtn").html(this.locale.applyLabel), this.container.find(".cancelBtn").html(this.locale.cancelLabel), this.container.find(".calendar").on("click.daterangepicker", ".prev", e.proxy(this.clickPrev, this)).on("click.daterangepicker", ".next", e.proxy(this.clickNext, this)).on("mousedown.daterangepicker", "td.available", e.proxy(this.clickDate, this)).on("mouseenter.daterangepicker", "td.available", e.proxy(this.hoverDate, this)).on("mouseleave.daterangepicker", "td.available", e.proxy(this.updateFormInputs, this)).on("change.daterangepicker", "select.yearselect", e.proxy(this.monthOrYearChanged, this)).on("change.daterangepicker", "select.monthselect", e.proxy(this.monthOrYearChanged, this)).on("change.daterangepicker", "select.hourselect,select.minuteselect,select.secondselect,select.ampmselect", e.proxy(this.timeChanged, this)).on("click.daterangepicker", ".daterangepicker_input input", e.proxy(this.showCalendars, this)).on("focus.daterangepicker", ".daterangepicker_input input", e.proxy(this.formInputsFocused, this)).on("blur.daterangepicker", ".daterangepicker_input input", e.proxy(this.formInputsBlurred, this)).on("change.daterangepicker", ".daterangepicker_input input", e.proxy(this.formInputsChanged, this)), this.container.find(".ranges").on("click.daterangepicker", "button.applyBtn", e.proxy(this.clickApply, this)).on("click.daterangepicker", "button.cancelBtn", e.proxy(this.clickCancel, this)).on("click.daterangepicker", "li", e.proxy(this.clickRange, this)).on("mouseenter.daterangepicker", "li", e.proxy(this.hoverRange, this)).on("mouseleave.daterangepicker", "li", e.proxy(this.updateFormInputs, this)), this.element.is("input") || this.element.is("button") ? this.element.on({
                "click.daterangepicker": e.proxy(this.show, this),
                "focus.daterangepicker": e.proxy(this.show, this),
                "keyup.daterangepicker": e.proxy(this.elementChanged, this),
                "keydown.daterangepicker": e.proxy(this.keydown, this)
            }) : this.element.on("click.daterangepicker", e.proxy(this.toggle, this)), this.element.is("input") && !this.singleDatePicker && this.autoUpdateInput ? (this.element.val(this.startDate.format(this.locale.format) + this.locale.separator + this.endDate.format(this.locale.format)), this.element.trigger("change")) : this.element.is("input") && this.autoUpdateInput && (this.element.val(this.startDate.format(this.locale.format)), this.element.trigger("change"))
        };
        return i.prototype = {
            constructor: i,
            setStartDate: function(e) {
                "string" == typeof e && (this.startDate = t(e, this.locale.format)), "object" == typeof e && (this.startDate = t(e)), this.timePicker || (this.startDate = this.startDate.startOf("day")), this.timePicker && this.timePickerIncrement && this.startDate.minute(Math.round(this.startDate.minute() / this.timePickerIncrement) * this.timePickerIncrement), this.minDate && this.startDate.isBefore(this.minDate) && (this.startDate = this.minDate, this.timePicker && this.timePickerIncrement && this.startDate.minute(Math.round(this.startDate.minute() / this.timePickerIncrement) * this.timePickerIncrement)), this.maxDate && this.startDate.isAfter(this.maxDate) && (this.startDate = this.maxDate, this.timePicker && this.timePickerIncrement && this.startDate.minute(Math.floor(this.startDate.minute() / this.timePickerIncrement) * this.timePickerIncrement)), this.isShowing || this.updateElement(), this.updateMonthsInView()
            },
            setEndDate: function(e) {
                "string" == typeof e && (this.endDate = t(e, this.locale.format)), "object" == typeof e && (this.endDate = t(e)), this.timePicker || (this.endDate = this.endDate.endOf("day")), this.timePicker && this.timePickerIncrement && this.endDate.minute(Math.round(this.endDate.minute() / this.timePickerIncrement) * this.timePickerIncrement), this.endDate.isBefore(this.startDate) && (this.endDate = this.startDate.clone()), this.maxDate && this.endDate.isAfter(this.maxDate) && (this.endDate = this.maxDate), this.dateLimit && this.startDate.clone().add(this.dateLimit).isBefore(this.endDate) && (this.endDate = this.startDate.clone().add(this.dateLimit)), this.previousRightTime = this.endDate.clone(), this.isShowing || this.updateElement(), this.updateMonthsInView()
            },
            isInvalidDate: function() {
                return !1
            },
            isCustomDate: function() {
                return !1
            },
            updateView: function() {
                this.timePicker && (this.renderTimePicker("left"), this.renderTimePicker("right"), this.endDate ? this.container.find(".right .calendar-time select").removeAttr("disabled").removeClass("disabled") : this.container.find(".right .calendar-time select").attr("disabled", "disabled").addClass("disabled")), this.endDate ? (this.container.find('input[name="daterangepicker_end"]').removeClass("active"), this.container.find('input[name="daterangepicker_start"]').addClass("active")) : (this.container.find('input[name="daterangepicker_end"]').addClass("active"), this.container.find('input[name="daterangepicker_start"]').removeClass("active")), this.updateMonthsInView(), this.updateCalendars(), this.updateFormInputs()
            },
            updateMonthsInView: function() {
                if (this.endDate) {
                    if (!this.singleDatePicker && this.leftCalendar.month && this.rightCalendar.month && (this.startDate.format("YYYY-MM") == this.leftCalendar.month.format("YYYY-MM") || this.startDate.format("YYYY-MM") == this.rightCalendar.month.format("YYYY-MM")) && (this.endDate.format("YYYY-MM") == this.leftCalendar.month.format("YYYY-MM") || this.endDate.format("YYYY-MM") == this.rightCalendar.month.format("YYYY-MM")))
                        return;
                    this.leftCalendar.month = this.startDate.clone().date(2), this.linkedCalendars || this.endDate.month() == this.startDate.month() && this.endDate.year() == this.startDate.year() ? this.rightCalendar.month = this.startDate.clone().date(2).add(1, "month") : this.rightCalendar.month = this.endDate.clone().date(2)
                } else
                    this.leftCalendar.month.format("YYYY-MM") != this.startDate.format("YYYY-MM") && this.rightCalendar.month.format("YYYY-MM") != this.startDate.format("YYYY-MM") && (this.leftCalendar.month = this.startDate.clone().date(2), this.rightCalendar.month = this.startDate.clone().date(2).add(1, "month"));
                this.maxDate && this.linkedCalendars && !this.singleDatePicker && this.rightCalendar.month > this.maxDate && (this.rightCalendar.month = this.maxDate.clone().date(2), this.leftCalendar.month = this.maxDate.clone().date(2).subtract(1, "month"))
            },
            updateCalendars: function() {
                if (this.timePicker) {
                    var t,
                        e,
                        i;
                    if (this.endDate) {
                        if (t = parseInt(this.container.find(".left .hourselect").val(), 10), e = parseInt(this.container.find(".left .minuteselect").val(), 10), i = this.timePickerSeconds ? parseInt(this.container.find(".left .secondselect").val(), 10) : 0, !this.timePicker24Hour) {
                            var n = this.container.find(".left .ampmselect").val();
                            "PM" === n && t < 12 && (t += 12), "AM" === n && 12 === t && (t = 0)
                        }
                    } else if (t = parseInt(this.container.find(".right .hourselect").val(), 10), e = parseInt(this.container.find(".right .minuteselect").val(), 10), i = this.timePickerSeconds ? parseInt(this.container.find(".right .secondselect").val(), 10) : 0, !this.timePicker24Hour) {
                        var n = this.container.find(".right .ampmselect").val();
                        "PM" === n && t < 12 && (t += 12), "AM" === n && 12 === t && (t = 0)
                    }
                    this.leftCalendar.month.hour(t).minute(e).second(i), this.rightCalendar.month.hour(t).minute(e).second(i)
                }
                this.renderCalendar("left"), this.renderCalendar("right"), this.container.find(".ranges li").removeClass("active"), null != this.endDate && this.calculateChosenLabel()
            },
            renderCalendar: function(i) {
                var n = "left" == i ? this.leftCalendar : this.rightCalendar,
                    r = n.month.month(),
                    a = n.month.year(),
                    o = n.month.hour(),
                    s = n.month.minute(),
                    l = n.month.second(),
                    c = t([a, r]).daysInMonth(),
                    u = t([a, r, 1]),
                    h = t([a, r, c]),
                    d = t(u).subtract(1, "month").month(),
                    p = t(u).subtract(1, "month").year(),
                    f = t([p, d]).daysInMonth(),
                    g = u.day(),
                    n = [];
                n.firstDay = u, n.lastDay = h;
                for (var m = 0; m < 6; m++)
                    n[m] = [];
                var v = f - g + this.locale.firstDay + 1;
                v > f && (v -= 7), g == this.locale.firstDay && (v = f - 6);
                for (var y, x, _ = t([p, d, v, 12, s, l]), m = 0, y = 0, x = 0; m < 42; m++, y++, _ = t(_).add(24, "hour"))
                    m > 0 && y % 7 === 0 && (y = 0, x++), n[x][y] = _.clone().hour(o).minute(s).second(l), _.hour(12), this.minDate && n[x][y].format("YYYY-MM-DD") == this.minDate.format("YYYY-MM-DD") && n[x][y].isBefore(this.minDate) && "left" == i && (n[x][y] = this.minDate.clone()), this.maxDate && n[x][y].format("YYYY-MM-DD") == this.maxDate.format("YYYY-MM-DD") && n[x][y].isAfter(this.maxDate) && "right" == i && (n[x][y] = this.maxDate.clone());
                "left" == i ? this.leftCalendar.calendar = n : this.rightCalendar.calendar = n;
                var b = "left" == i ? this.minDate : this.startDate,
                    w = this.maxDate,
                    M = ("left" == i ? this.startDate : this.endDate, "ltr" == this.locale.direction ? {
                        left: "chevron-left",
                        right: "chevron-right"
                    } : {
                        left: "chevron-right",
                        right: "chevron-left"
                    }),
                    S = '<table class="table-condensed">';
                S += "<thead>", S += "<tr>", (this.showWeekNumbers || this.showISOWeekNumbers) && (S += "<th></th>"), S += b && !b.isBefore(n.firstDay) || this.linkedCalendars && "left" != i ? "<th></th>" : '<th class="prev available"><i class="fa fa-' + M.left + " glyphicon glyphicon-" + M.left + '"></i></th>';
                var A = this.locale.monthNames[n[1][1].month()] + n[1][1].format(" YYYY");
                if (this.showDropdowns) {
                    for (var I = n[1][1].month(), D = n[1][1].year(), k = w && w.year() || D + 5, T = b && b.year() || D - 50, C = D == T, L = D == k, P = '<select class="monthselect">', E = 0; E < 12; E++)
                        P += (!C || E >= b.month()) && (!L || E <= w.month()) ? "<option value='" + E + "'" + (E === I ? " selected='selected'" : "") + ">" + this.locale.monthNames[E] + "</option>" : "<option value='" + E + "'" + (E === I ? " selected='selected'" : "") + " disabled='disabled'>" + this.locale.monthNames[E] + "</option>";
                    P += "</select>";
                    for (var O = '<select class="yearselect">', R = T; R <= k; R++)
                        O += '<option value="' + R + '"' + (R === D ? ' selected="selected"' : "") + ">" + R + "</option>";
                    O += "</select>", A = P + O
                }
                if (S += '<th colspan="5" class="month">' + A + "</th>", S += w && !w.isAfter(n.lastDay) || this.linkedCalendars && "right" != i && !this.singleDatePicker ? "<th></th>" : '<th class="next available"><i class="fa fa-' + M.right + " glyphicon glyphicon-" + M.right + '"></i></th>', S += "</tr>", S += "<tr>", (this.showWeekNumbers || this.showISOWeekNumbers) && (S += '<th class="week">' + this.locale.weekLabel + "</th>"), e.each(this.locale.daysOfWeek, function(t, e) {
                    S += "<th>" + e + "</th>"
                }), S += "</tr>", S += "</thead>", S += "<tbody>", null == this.endDate && this.dateLimit) {
                    var z = this.startDate.clone().add(this.dateLimit).endOf("day");
                    w && !z.isBefore(w) || (w = z)
                }
                for (var x = 0; x < 6; x++) {
                    S += "<tr>", this.showWeekNumbers ? S += '<td class="week">' + n[x][0].week() + "</td>" : this.showISOWeekNumbers && (S += '<td class="week">' + n[x][0].isoWeek() + "</td>");
                    for (var y = 0; y < 7; y++) {
                        var V = [];
                        n[x][y].isSame(new Date, "day") && V.push("today"), n[x][y].isoWeekday() > 5 && V.push("weekend"), n[x][y].month() != n[1][1].month() && V.push("off"), this.minDate && n[x][y].isBefore(this.minDate, "day") && V.push("off", "disabled"), w && n[x][y].isAfter(w, "day") && V.push("off", "disabled"), this.isInvalidDate(n[x][y]) && V.push("off", "disabled"), n[x][y].format("YYYY-MM-DD") == this.startDate.format("YYYY-MM-DD") && V.push("active", "start-date"), null != this.endDate && n[x][y].format("YYYY-MM-DD") == this.endDate.format("YYYY-MM-DD") && V.push("active", "end-date"), null != this.endDate && n[x][y] > this.startDate && n[x][y] < this.endDate && V.push("in-range");
                        var N = this.isCustomDate(n[x][y]);
                        N !== !1 && ("string" == typeof N ? V.push(N) : Array.prototype.push.apply(V, N));
                        for (var B = "", F = !1, m = 0; m < V.length; m++)
                            B += V[m] + " ", "disabled" == V[m] && (F = !0);
                        F || (B += "available"), S += '<td class="' + B.replace(/^\s+|\s+$/g, "") + '" data-title="r' + x + "c" + y + '">' + n[x][y].date() + "</td>"
                    }
                    S += "</tr>"
                }
                S += "</tbody>", S += "</table>", this.container.find(".calendar." + i + " .calendar-table").html(S)
            },
            renderTimePicker: function(t) {
                if ("right" != t || this.endDate) {
                    var e,
                        i,
                        n,
                        r = this.maxDate;
                    if (!this.dateLimit || this.maxDate && !this.startDate.clone().add(this.dateLimit).isAfter(this.maxDate) || (r = this.startDate.clone().add(this.dateLimit)), "left" == t)
                        i = this.startDate.clone(), n = this.minDate;
                    else if ("right" == t) {
                        i = this.endDate.clone(), n = this.startDate;
                        var a = this.container.find(".calendar.right .calendar-time div");
                        if (!this.endDate && "" != a.html() && (i.hour(a.find(".hourselect option:selected").val() || i.hour()), i.minute(a.find(".minuteselect option:selected").val() || i.minute()), i.second(a.find(".secondselect option:selected").val() || i.second()), !this.timePicker24Hour)) {
                            var o = a.find(".ampmselect option:selected").val();
                            "PM" === o && i.hour() < 12 && i.hour(i.hour() + 12), "AM" === o && 12 === i.hour() && i.hour(0)
                        }
                        i.isBefore(this.startDate) && (i = this.startDate.clone()), r && i.isAfter(r) && (i = r.clone())
                    }
                    e = '<select class="hourselect">';
                    for (var s = this.timePicker24Hour ? 0 : 1, l = this.timePicker24Hour ? 23 : 12, c = s; c <= l; c++) {
                        var u = c;
                        this.timePicker24Hour || (u = i.hour() >= 12 ? 12 == c ? 12 : c + 12 : 12 == c ? 0 : c);
                        var h = i.clone().hour(u),
                            d = !1;
                        n && h.minute(59).isBefore(n) && (d = !0), r && h.minute(0).isAfter(r) && (d = !0), e += u != i.hour() || d ? d ? '<option value="' + c + '" disabled="disabled" class="disabled">' + c + "</option>" : '<option value="' + c + '">' + c + "</option>" : '<option value="' + c + '" selected="selected">' + c + "</option>"
                    }
                    e += "</select> ", e += ': <select class="minuteselect">';
                    for (var c = 0; c < 60; c += this.timePickerIncrement) {
                        var p = c < 10 ? "0" + c : c,
                            h = i.clone().minute(c),
                            d = !1;
                        n && h.second(59).isBefore(n) && (d = !0), r && h.second(0).isAfter(r) && (d = !0), e += i.minute() != c || d ? d ? '<option value="' + c + '" disabled="disabled" class="disabled">' + p + "</option>" : '<option value="' + c + '">' + p + "</option>" : '<option value="' + c + '" selected="selected">' + p + "</option>"
                    }
                    if (e += "</select> ", this.timePickerSeconds) {
                        e += ': <select class="secondselect">';
                        for (var c = 0; c < 60; c++) {
                            var p = c < 10 ? "0" + c : c,
                                h = i.clone().second(c),
                                d = !1;
                            n && h.isBefore(n) && (d = !0), r && h.isAfter(r) && (d = !0), e += i.second() != c || d ? d ? '<option value="' + c + '" disabled="disabled" class="disabled">' + p + "</option>" : '<option value="' + c + '">' + p + "</option>" : '<option value="' + c + '" selected="selected">' + p + "</option>"
                        }
                        e += "</select> "
                    }
                    if (!this.timePicker24Hour) {
                        e += '<select class="ampmselect">';
                        var f = "",
                            g = "";
                        n && i.clone().hour(12).minute(0).second(0).isBefore(n) && (f = ' disabled="disabled" class="disabled"'), r && i.clone().hour(0).minute(0).second(0).isAfter(r) && (g = ' disabled="disabled" class="disabled"'), e += i.hour() >= 12 ? '<option value="AM"' + f + '>AM</option><option value="PM" selected="selected"' + g + ">PM</option>" : '<option value="AM" selected="selected"' + f + '>AM</option><option value="PM"' + g + ">PM</option>", e += "</select>"
                    }
                    this.container.find(".calendar." + t + " .calendar-time div").html(e)
                }
            },
            updateFormInputs: function() {
                this.container.find("input[name=daterangepicker_start]").is(":focus") || this.container.find("input[name=daterangepicker_end]").is(":focus") || (this.container.find("input[name=daterangepicker_start]").val(this.startDate.format(this.locale.format)), this.endDate && this.container.find("input[name=daterangepicker_end]").val(this.endDate.format(this.locale.format)), this.singleDatePicker || this.endDate && (this.startDate.isBefore(this.endDate) || this.startDate.isSame(this.endDate)) ? this.container.find("button.applyBtn").removeAttr("disabled") : this.container.find("button.applyBtn").attr("disabled", "disabled"))
            },
            move: function() {
                var t,
                    i = {
                        top: 0,
                        left: 0
                    },
                    n = e(window).width();
                this.parentEl.is("body") || (i = {
                    top: this.parentEl.offset().top - this.parentEl.scrollTop(),
                    left: this.parentEl.offset().left - this.parentEl.scrollLeft()
                }, n = this.parentEl[0].clientWidth + this.parentEl.offset().left), t = "up" == this.drops ? this.element.offset().top - this.container.outerHeight() - i.top : this.element.offset().top + this.element.outerHeight() - i.top, this.container["up" == this.drops ? "addClass" : "removeClass"]("dropup"), "left" == this.opens ? (this.container.css({
                    top: t,
                    right: n - this.element.offset().left - this.element.outerWidth(),
                    left: "auto"
                }), this.container.offset().left < 0 && this.container.css({
                    right: "auto",
                    left: 9
                })) : "center" == this.opens ? (this.container.css({
                    top: t,
                    left: this.element.offset().left - i.left + this.element.outerWidth() / 2 - this.container.outerWidth() / 2,
                    right: "auto"
                }), this.container.offset().left < 0 && this.container.css({
                    right: "auto",
                    left: 9
                })) : (this.container.css({
                    top: t,
                    left: this.element.offset().left - i.left,
                    right: "auto"
                }), this.container.offset().left + this.container.outerWidth() > e(window).width() && this.container.css({
                    left: "auto",
                    right: 0
                }))
            },
            show: function(t) {
                this.isShowing || (this._outsideClickProxy = e.proxy(function(t) {
                    this.outsideClick(t)
                }, this), e(document).on("mousedown.daterangepicker", this._outsideClickProxy).on("touchend.daterangepicker", this._outsideClickProxy).on("click.daterangepicker", "[data-toggle=dropdown]", this._outsideClickProxy).on("focusin.daterangepicker", this._outsideClickProxy), e(window).on("resize.daterangepicker", e.proxy(function(t) {
                    this.move(t)
                }, this)), this.oldStartDate = this.startDate.clone(), this.oldEndDate = this.endDate.clone(), this.previousRightTime = this.endDate.clone(), this.updateView(), this.container.show(), this.move(), this.element.trigger("show.daterangepicker", this), this.isShowing = !0)
            },
            hide: function(t) {
                this.isShowing && (this.endDate || (this.startDate = this.oldStartDate.clone(), this.endDate = this.oldEndDate.clone()), this.startDate.isSame(this.oldStartDate) && this.endDate.isSame(this.oldEndDate) || this.callback(this.startDate, this.endDate, this.chosenLabel), this.updateElement(), e(document).off(".daterangepicker"), e(window).off(".daterangepicker"), this.container.hide(), this.element.trigger("hide.daterangepicker", this), this.isShowing = !1)
            },
            toggle: function(t) {
                this.isShowing ? this.hide() : this.show()
            },
            outsideClick: function(t) {
                var i = e(t.target);
                "focusin" == t.type || i.closest(this.element).length || i.closest(this.container).length || i.closest(".calendar-table").length || (this.hide(), this.element.trigger("outsideClick.daterangepicker", this))
            },
            showCalendars: function() {
                this.container.addClass("show-calendar"), this.move(), this.element.trigger("showCalendar.daterangepicker", this)
            },
            hideCalendars: function() {
                this.container.removeClass("show-calendar"), this.element.trigger("hideCalendar.daterangepicker", this)
            },
            hoverRange: function(t) {
                if (!this.container.find("input[name=daterangepicker_start]").is(":focus") && !this.container.find("input[name=daterangepicker_end]").is(":focus")) {
                    var e = t.target.getAttribute("data-range-key");
                    if (e == this.locale.customRangeLabel)
                        this.updateView();
                    else {
                        var i = this.ranges[e];
                        this.container.find("input[name=daterangepicker_start]").val(i[0].format(this.locale.format)), this.container.find("input[name=daterangepicker_end]").val(i[1].format(this.locale.format))
                    }
                }
            },
            clickRange: function(t) {
                var e = t.target.getAttribute("data-range-key");
                if (this.chosenLabel = e, e == this.locale.customRangeLabel)
                    this.showCalendars();
                else {
                    var i = this.ranges[e];
                    this.startDate = i[0], this.endDate = i[1], this.timePicker || (this.startDate.startOf("day"), this.endDate.endOf("day")), this.alwaysShowCalendars || this.hideCalendars(), this.clickApply()
                }
            },
            clickPrev: function(t) {
                var i = e(t.target).parents(".calendar");
                i.hasClass("left") ? (this.leftCalendar.month.subtract(1, "month"), this.linkedCalendars && this.rightCalendar.month.subtract(1, "month")) : this.rightCalendar.month.subtract(1, "month"), this.updateCalendars()
            },
            clickNext: function(t) {
                var i = e(t.target).parents(".calendar");
                i.hasClass("left") ? this.leftCalendar.month.add(1, "month") : (this.rightCalendar.month.add(1, "month"), this.linkedCalendars && this.leftCalendar.month.add(1, "month")), this.updateCalendars()
            },
            hoverDate: function(t) {
                if (e(t.target).hasClass("available")) {
                    var i = e(t.target).attr("data-title"),
                        n = i.substr(1, 1),
                        r = i.substr(3, 1),
                        a = e(t.target).parents(".calendar"),
                        o = a.hasClass("left") ? this.leftCalendar.calendar[n][r] : this.rightCalendar.calendar[n][r];
                    this.endDate && !this.container.find("input[name=daterangepicker_start]").is(":focus") ? this.container.find("input[name=daterangepicker_start]").val(o.format(this.locale.format)) : this.endDate || this.container.find("input[name=daterangepicker_end]").is(":focus") || this.container.find("input[name=daterangepicker_end]").val(o.format(this.locale.format));
                    var s = this.leftCalendar,
                        l = this.rightCalendar,
                        c = this.startDate;
                    this.endDate || this.container.find(".calendar td").each(function(t, i) {
                        if (!e(i).hasClass("week")) {
                            var n = e(i).attr("data-title"),
                                r = n.substr(1, 1),
                                a = n.substr(3, 1),
                                u = e(i).parents(".calendar"),
                                h = u.hasClass("left") ? s.calendar[r][a] : l.calendar[r][a];
                            h.isAfter(c) && h.isBefore(o) || h.isSame(o, "day") ? e(i).addClass("in-range") : e(i).removeClass("in-range")
                        }
                    })
                }
            },
            clickDate: function(t) {
                if (e(t.target).hasClass("available")) {
                    var i = e(t.target).attr("data-title"),
                        n = i.substr(1, 1),
                        r = i.substr(3, 1),
                        a = e(t.target).parents(".calendar"),
                        o = a.hasClass("left") ? this.leftCalendar.calendar[n][r] : this.rightCalendar.calendar[n][r];
                    if (this.endDate || o.isBefore(this.startDate, "day")) {
                        if (this.timePicker) {
                            var s = parseInt(this.container.find(".left .hourselect").val(), 10);
                            if (!this.timePicker24Hour) {
                                var l = this.container.find(".left .ampmselect").val();
                                "PM" === l && s < 12 && (s += 12), "AM" === l && 12 === s && (s = 0)
                            }
                            var c = parseInt(this.container.find(".left .minuteselect").val(), 10),
                                u = this.timePickerSeconds ? parseInt(this.container.find(".left .secondselect").val(), 10) : 0;
                            o = o.clone().hour(s).minute(c).second(u)
                        }
                        this.endDate = null, this.setStartDate(o.clone())
                    } else if (!this.endDate && o.isBefore(this.startDate))
                        this.setEndDate(this.startDate.clone());
                    else {
                        if (this.timePicker) {
                            var s = parseInt(this.container.find(".right .hourselect").val(), 10);
                            if (!this.timePicker24Hour) {
                                var l = this.container.find(".right .ampmselect").val();
                                "PM" === l && s < 12 && (s += 12), "AM" === l && 12 === s && (s = 0)
                            }
                            var c = parseInt(this.container.find(".right .minuteselect").val(), 10),
                                u = this.timePickerSeconds ? parseInt(this.container.find(".right .secondselect").val(), 10) : 0;
                            o = o.clone().hour(s).minute(c).second(u)
                        }
                        this.setEndDate(o.clone()), this.autoApply && (this.calculateChosenLabel(), this.clickApply())
                    }
                    this.singleDatePicker && (this.setEndDate(this.startDate), this.timePicker || this.clickApply()), this.updateView(), t.stopPropagation()
                }
            },
            calculateChosenLabel: function() {
                var t = !0,
                    e = 0;
                for (var i in this.ranges) {
                    if (this.timePicker) {
                        if (this.startDate.isSame(this.ranges[i][0]) && this.endDate.isSame(this.ranges[i][1])) {
                            t = !1, this.chosenLabel = this.container.find(".ranges li:eq(" + e + ")").addClass("active").html();
                            break
                        }
                    } else if (this.startDate.format("YYYY-MM-DD") == this.ranges[i][0].format("YYYY-MM-DD") && this.endDate.format("YYYY-MM-DD") == this.ranges[i][1].format("YYYY-MM-DD")) {
                        t = !1, this.chosenLabel = this.container.find(".ranges li:eq(" + e + ")").addClass("active").html();
                        break
                    }
                    e++
                }
                t && this.showCustomRangeLabel && (this.chosenLabel = this.container.find(".ranges li:last").addClass("active").html(), this.showCalendars())
            },
            clickApply: function(t) {
                this.hide(), this.element.trigger("apply.daterangepicker", this)
            },
            clickCancel: function(t) {
                this.startDate = this.oldStartDate, this.endDate = this.oldEndDate, this.hide(), this.element.trigger("cancel.daterangepicker", this)
            },
            monthOrYearChanged: function(t) {
                var i = e(t.target).closest(".calendar").hasClass("left"),
                    n = i ? "left" : "right",
                    r = this.container.find(".calendar." + n),
                    a = parseInt(r.find(".monthselect").val(), 10),
                    o = r.find(".yearselect").val();
                i || (o < this.startDate.year() || o == this.startDate.year() && a < this.startDate.month()) && (a = this.startDate.month(), o = this.startDate.year()), this.minDate && (o < this.minDate.year() || o == this.minDate.year() && a < this.minDate.month()) && (a = this.minDate.month(), o = this.minDate.year()), this.maxDate && (o > this.maxDate.year() || o == this.maxDate.year() && a > this.maxDate.month()) && (a = this.maxDate.month(), o = this.maxDate.year()), i ? (this.leftCalendar.month.month(a).year(o), this.linkedCalendars && (this.rightCalendar.month = this.leftCalendar.month.clone().add(1, "month"))) : (this.rightCalendar.month.month(a).year(o), this.linkedCalendars && (this.leftCalendar.month = this.rightCalendar.month.clone().subtract(1, "month"))), this.updateCalendars()
            },
            timeChanged: function(t) {
                var i = e(t.target).closest(".calendar"),
                    n = i.hasClass("left"),
                    r = parseInt(i.find(".hourselect").val(), 10),
                    a = parseInt(i.find(".minuteselect").val(), 10),
                    o = this.timePickerSeconds ? parseInt(i.find(".secondselect").val(), 10) : 0;
                if (!this.timePicker24Hour) {
                    var s = i.find(".ampmselect").val();
                    "PM" === s && r < 12 && (r += 12), "AM" === s && 12 === r && (r = 0)
                }
                if (n) {
                    var l = this.startDate.clone();
                    l.hour(r), l.minute(a), l.second(o), this.setStartDate(l), this.singleDatePicker ? this.endDate = this.startDate.clone() : this.endDate && this.endDate.format("YYYY-MM-DD") == l.format("YYYY-MM-DD") && this.endDate.isBefore(l) && this.setEndDate(l.clone());
                } else if (this.endDate) {
                    var c = this.endDate.clone();
                    c.hour(r), c.minute(a), c.second(o), this.setEndDate(c)
                }
                this.updateCalendars(), this.updateFormInputs(), this.renderTimePicker("left"), this.renderTimePicker("right")
            },
            formInputsChanged: function(i) {
                var n = e(i.target).closest(".calendar").hasClass("right"),
                    r = t(this.container.find('input[name="daterangepicker_start"]').val(), this.locale.format),
                    a = t(this.container.find('input[name="daterangepicker_end"]').val(), this.locale.format);
                r.isValid() && a.isValid() && (n && a.isBefore(r) && (r = a.clone()), this.setStartDate(r), this.setEndDate(a), n ? this.container.find('input[name="daterangepicker_start"]').val(this.startDate.format(this.locale.format)) : this.container.find('input[name="daterangepicker_end"]').val(this.endDate.format(this.locale.format))), this.updateView()
            },
            formInputsFocused: function(t) {
                this.container.find('input[name="daterangepicker_start"], input[name="daterangepicker_end"]').removeClass("active"), e(t.target).addClass("active");
                var i = e(t.target).closest(".calendar").hasClass("right");
                i && (this.endDate = null, this.setStartDate(this.startDate.clone()), this.updateView())
            },
            formInputsBlurred: function(e) {
                if (!this.endDate) {
                    var i = this.container.find('input[name="daterangepicker_end"]').val(),
                        n = t(i, this.locale.format);
                    n.isValid() && (this.setEndDate(n), this.updateView())
                }
            },
            elementChanged: function() {
                if (this.element.is("input") && this.element.val().length && !(this.element.val().length < this.locale.format.length)) {
                    var e = this.element.val().split(this.locale.separator),
                        i = null,
                        n = null;
                    2 === e.length && (i = t(e[0], this.locale.format), n = t(e[1], this.locale.format)), (this.singleDatePicker || null === i || null === n) && (i = t(this.element.val(), this.locale.format), n = i), i.isValid() && n.isValid() && (this.setStartDate(i), this.setEndDate(n), this.updateView())
                }
            },
            keydown: function(t) {
                9 !== t.keyCode && 13 !== t.keyCode || this.hide()
            },
            updateElement: function() {
                this.element.is("input") && !this.singleDatePicker && this.autoUpdateInput ? (this.element.val(this.startDate.format(this.locale.format) + this.locale.separator + this.endDate.format(this.locale.format)), this.element.trigger("change")) : this.element.is("input") && this.autoUpdateInput && (this.element.val(this.startDate.format(this.locale.format)), this.element.trigger("change"))
            },
            remove: function() {
                this.container.remove(), this.element.off(".daterangepicker"), this.element.removeData()
            }
        }, e.fn.daterangepicker = function(t, n) {
            return this.each(function() {
                var r = e(this);
                r.data("daterangepicker") && r.data("daterangepicker").remove(), r.data("daterangepicker", new i(r, t, n))
            }), this
        }, i
    })
}, function(t, e, i) {
    var n = i(501);
    "string" == typeof n && (n = [[t.id, n, ""]]);
    i(307)(n, {});
    n.locals && (t.exports = n.locals)
}, function(t, e, i) {
    e = t.exports = i(301)(), e.push([t.id, '.daterangepicker{position:absolute;color:inherit;background:#fff;border-radius:4px;width:278px;padding:4px;margin-top:1px;top:100px;left:20px}.daterangepicker:after,.daterangepicker:before{position:absolute;display:inline-block;border-bottom-color:rgba(0,0,0,.2);content:""}.daterangepicker:before{top:-7px;border-right:7px solid transparent;border-left:7px solid transparent;border-bottom:7px solid #ccc}.daterangepicker:after{top:-6px;border-right:6px solid transparent;border-bottom:6px solid #fff;border-left:6px solid transparent}.daterangepicker.opensleft:before{right:9px}.daterangepicker.opensleft:after{right:10px}.daterangepicker.openscenter:after,.daterangepicker.openscenter:before{left:0;right:0;width:0;margin-left:auto;margin-right:auto}.daterangepicker.opensright:before{left:9px}.daterangepicker.opensright:after{left:10px}.daterangepicker.dropup{margin-top:-5px}.daterangepicker.dropup:before{top:auto;bottom:-7px;border-bottom:initial;border-top:7px solid #ccc}.daterangepicker.dropup:after{top:auto;bottom:-6px;border-bottom:initial;border-top:6px solid #fff}.daterangepicker.dropdown-menu{max-width:none;z-index:3001}.daterangepicker.single .calendar,.daterangepicker.single .ranges{float:none}.daterangepicker.show-calendar .calendar{display:block}.daterangepicker .calendar{display:none;max-width:270px;margin:4px}.daterangepicker .calendar.single .calendar-table{border:none}.daterangepicker .calendar td,.daterangepicker .calendar th{white-space:nowrap;text-align:center;min-width:32px}.daterangepicker .calendar-table{border:1px solid #fff;padding:4px;border-radius:4px;background:#fff}.daterangepicker table{width:100%;margin:0}.daterangepicker td,.daterangepicker th{text-align:center;width:20px;height:20px;border-radius:4px;border:1px solid transparent;white-space:nowrap;cursor:pointer}.daterangepicker td.available:hover,.daterangepicker th.available:hover{background-color:#eee;border-color:transparent;color:inherit}.daterangepicker td.week,.daterangepicker th.week{font-size:80%;color:#ccc}.daterangepicker td.off,.daterangepicker td.off.end-date,.daterangepicker td.off.in-range,.daterangepicker td.off.start-date{background-color:#fff;border-color:transparent;color:#999}.daterangepicker td.in-range{background-color:#ebf4f8;border-color:transparent;color:#000;border-radius:0}.daterangepicker td.start-date{border-radius:4px 0 0 4px}.daterangepicker td.end-date{border-radius:0 4px 4px 0}.daterangepicker td.start-date.end-date{border-radius:4px}.daterangepicker td.active,.daterangepicker td.active:hover{background-color:#357ebd;border-color:transparent;color:#fff}.daterangepicker th.month{width:auto}.daterangepicker option.disabled,.daterangepicker td.disabled{color:#999;cursor:not-allowed;text-decoration:line-through}.daterangepicker select.monthselect,.daterangepicker select.yearselect{font-size:12px;padding:1px;height:auto;margin:0;cursor:default}.daterangepicker select.monthselect{margin-right:2%;width:56%}.daterangepicker select.yearselect{width:40%}.daterangepicker select.ampmselect,.daterangepicker select.hourselect,.daterangepicker select.minuteselect,.daterangepicker select.secondselect{width:50px;margin-bottom:0}.daterangepicker .input-mini{border:1px solid #ccc;border-radius:4px;color:#555;height:30px;line-height:30px;display:block;vertical-align:middle;margin:0 0 5px;padding:0 6px 0 28px;width:100%}.daterangepicker .input-mini.active{border:1px solid #08c;border-radius:4px}.daterangepicker .daterangepicker_input{position:relative}.daterangepicker .daterangepicker_input i{position:absolute;left:8px;top:8px}.daterangepicker.rtl .input-mini{padding-right:28px;padding-left:6px}.daterangepicker.rtl .daterangepicker_input i{left:auto;right:8px}.daterangepicker .calendar-time{text-align:center;margin:5px auto;line-height:30px;position:relative;padding-left:28px}.daterangepicker .calendar-time select.disabled{color:#ccc;cursor:not-allowed}.ranges{font-size:11px;float:none;margin:4px;text-align:left}.ranges ul{list-style:none;margin:0 auto;padding:0;width:100%}.ranges li{font-size:13px;background:#f5f5f5;border:1px solid #f5f5f5;border-radius:4px;color:#08c;padding:3px 12px;margin-bottom:8px;cursor:pointer}.ranges li.active,.ranges li:hover{background:#08c;border:1px solid #08c;color:#fff}@media (min-width:564px){.daterangepicker{width:auto}.daterangepicker .ranges ul{width:160px}.daterangepicker.single .ranges ul{width:100%}.daterangepicker.single .calendar.left{clear:none}.daterangepicker.single.ltr .calendar,.daterangepicker.single.ltr .ranges{float:left}.daterangepicker.single.rtl .calendar,.daterangepicker.single.rtl .ranges{float:right}.daterangepicker.ltr{direction:ltr;text-align:left}.daterangepicker.ltr .calendar.left{clear:left;margin-right:0}.daterangepicker.ltr .calendar.left .calendar-table{border-right:none;border-top-right-radius:0;border-bottom-right-radius:0}.daterangepicker.ltr .calendar.right{margin-left:0}.daterangepicker.ltr .calendar.right .calendar-table{border-left:none;border-top-left-radius:0;border-bottom-left-radius:0}.daterangepicker.ltr .calendar.left .calendar-table,.daterangepicker.ltr .left .daterangepicker_input{padding-right:12px}.daterangepicker.ltr .calendar,.daterangepicker.ltr .ranges{float:left}.daterangepicker.rtl{direction:rtl;text-align:right}.daterangepicker.rtl .calendar.left{clear:right;margin-left:0}.daterangepicker.rtl .calendar.left .calendar-table{border-left:none;border-top-left-radius:0;border-bottom-left-radius:0}.daterangepicker.rtl .calendar.right{margin-right:0}.daterangepicker.rtl .calendar.right .calendar-table{border-right:none;border-top-right-radius:0;border-bottom-right-radius:0}.daterangepicker.rtl .calendar.left .calendar-table,.daterangepicker.rtl .left .daterangepicker_input{padding-left:12px}.daterangepicker.rtl .calendar,.daterangepicker.rtl .ranges{text-align:right;float:right}}@media (min-width:730px){.daterangepicker .ranges{width:auto}.daterangepicker.ltr .ranges{float:left}.daterangepicker.rtl .ranges{float:right}.daterangepicker .calendar.left{clear:none!important}}', ""])
}, function(t, e, i) {
    i(503), t.exports = "daterangepicker"
}, function(t, e, i) {
    (function(t) {
        (function() {
            var e;
            e = angular.module("daterangepicker", []), e.constant("dateRangePickerConfig", {
                clearLabel: "Clear",
                locale: {
                    separator: " - ",
                    format: "YYYY-MM-DD"
                }
            }), e.directive("dateRangePicker", ["$compile", "$timeout", "$parse", "dateRangePickerConfig", function(e, i, n, r) {
                return {
                    require: "ngModel",
                    restrict: "A",
                    scope: {
                        min: "=",
                        max: "=",
                        model: "=ngModel",
                        opts: "=options",
                        clearable: "="
                    },
                    link: function(e, i, n, a) {
                        var o,
                            s,
                            l,
                            c,
                            u,
                            h,
                            d,
                            p,
                            f,
                            g,
                            m,
                            v,
                            y,
                            x;
                        return c = function() {
                            var t,
                                e;
                            return e = angular.extend.apply(angular, Array.prototype.slice.call(arguments).map(function(t) {
                                return null != t ? t.locale : void 0
                            }).filter(function(t) {
                                return !!t
                            })), t = angular.extend.apply(angular, arguments), t.locale = e, t
                        }, y = $(i), v = e.opts, x = c({
                            locale: {}
                        }, r, v), u = null, o = function() {
                            return u.setStartDate(), u.setEndDate()
                        }, h = function(e) {
                            return function(i) {
                                if (u && i)
                                    return e(t(i))
                            }
                        }, p = h(function(t) {
                            return u.endDate < t && u.setEndDate(t), x.startDate = t, u.setStartDate(t)
                        }), d = h(function(t) {
                            return u.startDate > t && u.setStartDate(t), x.endDate = t, u.setEndDate(t)
                        }), f = function(e) {
                            return function(i, n) {
                                return !i || !n || e(t(i), t(n))
                            }
                        }, m = f(function(t, e) {
                            return t.isBefore(e) || t.isSame(e, "day")
                        }), g = f(function(t, e) {
                            return t.isAfter(e) || t.isSame(e, "day")
                        }), a.$formatters.push(function(e) {
                            var i;
                            return i = function(e) {
                                return t.isMoment(e) ? e.format(x.locale.format) : t(e).format(x.locale.format)
                            }, x.singleDatePicker && e ? i(e) : e.startDate ? [i(e.startDate), i(e.endDate)].join(x.locale.separator) : ""
                        }), a.$render = function() {
                            return a.$modelValue && a.$modelValue.startDate ? (p(a.$modelValue.startDate), d(a.$modelValue.endDate)) : o(), y.val(a.$viewValue)
                        }, a.$parsers.push(function(e) {
                            var i,
                                n,
                                r;
                            return i = function(e) {
                                return t(e, x.locale.format)
                            }, n = {
                                startDate: null,
                                endDate: null
                            }, angular.isString(e) && e.length > 0 && (x.singleDatePicker ? n = i(e) : (r = e.split(x.locale.separator).map(i), n.startDate = r[0], n.endDate = r[1])), n
                        }), a.$isEmpty = function(t) {
                            return !(angular.isString(t) && t.length > 0)
                        }, s = function() {
                            var t,
                                i;
                            y.daterangepicker(angular.extend(x, {
                                autoUpdateInput: !1
                            }), function(t, i) {
                                return e.$apply(function() {
                                    return e.model = x.singleDatePicker ? t : {
                                        startDate: t,
                                        endDate: i
                                    }
                                })
                            }), u = y.data("daterangepicker"), i = [];
                            for (t in x.eventHandlers)
                                i.push(y.on(t, function(t) {
                                    var i;
                                    return i = t.type + "." + t.namespace, e.$evalAsync(x.eventHandlers[i])
                                }));
                            return i
                        }, s(), e.$watch("model.startDate", function(t) {
                            return p(t)
                        }), e.$watch("model.endDate", function(t) {
                            return d(t)
                        }), l = function(i, r, o, l) {
                            if (n[i])
                                return a.$validators[i] = function(t) {
                                    return t && r(x[l], t[o])
                                }, e.$watch(i, function(e) {
                                    return x[l] = !!e && t(e), s()
                                })
                        }, l("min", m, "startDate", "minDate"), l("max", g, "endDate", "maxDate"), n.options && e.$watch("opts", function(t) {
                            return x = c(x, t), s()
                        }, !0), n.clearable && e.$watch("clearable", function(t) {
                            if (t && (x = c(x, {
                                locale: {
                                    cancelLabel: x.clearLabel
                                }
                            })), s(), t)
                                return y.on("cancel.daterangepicker", function() {
                                    return e.$apply(function() {
                                        return e.model = x.singleDatePicker ? null : {
                                            startDate: null,
                                            endDate: null
                                        }
                                    })
                                })
                        }), e.$on("$destroy", function() {
                            return null != u ? u.remove() : void 0
                        })
                    }
                }
            }])
        }).call(this)
    }).call(e, i(484))
}, function(t, e, i) {
    "use strict";
    var n = i(405),
        r = i(505),
        a = i(889);
    t.exports = n.module("echarts", []).constant("$echarts", r).component("echarts", {
        template: '\n      <div></div>\n      <div ng-show="$ctrl.noData" style="position: absolute; top: 0; bottom: 0; left: 0; right: 0;display: -webkit-flex; display: flex;justify-content: center;align-items: center;background: rgba(255, 255, 255, 0.9)">\n        <h2>暂无数据</h2>\n      </div>\n    ',
        bindings: {
            option: "<",
            height: "@",
            width: "@"
        },
        controller: ["$element", "$window", function(t, e) {
            "ngInject";
            var i = this;
            this.chartDiv = t.children("div")[0], this.noDataDiv = t.children("div")[1], this.noData = !0, this.initChart = function() {
                i.chart = r.init(i.chartDiv), i.chart.setOption({
                    tooltip: {
                        trigger: "axis"
                    },
                    legend: {
                        top: "bottom"
                    },
                    xAxis: {
                        min: 0
                    },
                    yAxis: {
                        min: 0
                    },
                    series: []
                })
            }, this.refreshChart = function() {
                i.resizeChart(), i.noData = i.option.noData, i.chart.setOption(i.option)
            }, this.resizeChart = function() {
                t.css("position", "relative"), t.css("display", "block"), i.height ? (t.height(i.height), $(i.chartDiv).height(i.height)) : (t.height(400), $(i.chartDiv).height(400)), i.width && (t.width(i.width), $(i.chartDiv).width(i.width)), i.chart || i.initChart(), i.chart.resize()
            }, this.$onInit = function() {
                i.observer = new a(function() {
                    i.resizeChart()
                }), i.observer.observe(i.chartDiv)
            }, this.$onChanges = function(t) {
                t.option && this.refreshChart()
            }, this.resizeChart()
        }]
    }).constant("$wFormatter", function(t) {
        return Math.abs(t) >= 1e4 ? {
            value: t / 1e4,
            unit: "W"
        } : {
            value: t,
            unit: ""
        }
    }).constant("$btyeFormatter", function(t) {
        for (var e = ["", "k", "M", "G", "T", "P", "E"], i = 0; i < e.length - 1 && t >= 1024;)
            t /= 1024, i++;
        return {
            value: t,
            unit: e[i]
        }
    })
}, function(t, e, i) {
    t.exports = i(506), i(605), i(640), i(645), i(654), i(658), i(668), i(689), i(701), i(722), i(726), i(730), i(745), i(751), i(758), i(764), i(768), i(776), i(780), i(618), i(781), i(787), i(791), i(802), i(731), i(805), i(811), i(822), i(823), i(837), i(852), i(858), i(861), i(864), i(873), i(885)
}, function(t, e, i) {
    (function(e) {
        function n(t) {
            return function(e, i, n) {
                e = e && e.toLowerCase(), z.prototype[t].call(this, e, i, n)
            }
        }
        function r() {
            z.call(this)
        }
        function a(t, e, i) {
            function n(t, e) {
                return t.prio - e.prio
            }
            i = i || {}, "string" == typeof e && (e = nt[e]), this.id, this.group, this._dom = t;
            var a = this._zr = E.init(t, {
                renderer: i.renderer || "canvas",
                devicePixelRatio: i.devicePixelRatio,
                width: i.width,
                height: i.height
            });
            this._throttledZrFlush = P.throttle(O.bind(a.flush, a), 17), this._theme = O.clone(e), this._chartsViews = [], this._chartsMap = {}, this._componentsViews = [], this._componentsMap = {}, this._api = new M(this), this._coordSysMgr = new S, z.call(this), this._messageCenter = new r, this._initEvents(), this.resize = O.bind(this.resize, this), this._pendingActions = [], V(it, n), V(tt, n), a.animation.on("frame", this._onframe, this)
        }
        function o(t, e, i) {
            var n,
                r = this._model,
                a = this._coordSysMgr.getCoordinateSystems();
            e = L.parseFinder(r, e);
            for (var o = 0; o < a.length; o++) {
                var s = a[o];
                if (s[t] && null != (n = s[t](r, e, i)))
                    return n
            }
            __DEV__ && console.warn("No coordinate system that supports " + t + " found by the given finder.")
        }
        function s(t, e) {
            var i = this._model;
            i && i.eachComponent({
                mainType: "series",
                query: e
            }, function(n, r) {
                var a = this._chartsMap[n.__viewId];
                a && a.__alive && a[t](n, i, this._api, e)
            }, this)
        }
        function l(t, e) {
            var i = J[t.type],
                n = i.actionInfo,
                r = n.update || "update";
            this[q] = !0;
            var a = [t],
                o = !1;
            t.batch && (o = !0, a = O.map(t.batch, function(e) {
                return e = O.defaults(O.extend({}, e), t), e.batch = null, e
            }));
            for (var s, l = [], c = "highlight" === t.type || "downplay" === t.type, u = 0; u < a.length; u++) {
                var h = a[u];
                s = i.action(h, this._model), s = s || O.extend({}, h), s.type = n.event || s.type, l.push(s), c && X[r].call(this, h)
            }
            "none" === r || c || (this[Z] ? (X.prepareAndUpdate.call(this, t), this[Z] = !1) : X[r].call(this, t)), s = o ? {
                type: n.event || t.type,
                batch: l
            } : l[0], this[q] = !1, !e && this._messageCenter.trigger(s.type, s)
        }
        function c(t) {
            for (var e = this._pendingActions; e.length;) {
                var i = e.shift();
                l.call(this, i, t)
            }
        }
        function u(t, e, i) {
            var n = this._api;
            N(this._componentsViews, function(r) {
                var a = r.__model;
                r[t](a, e, n, i), x(a, r)
            }, this), e.eachSeries(function(r, a) {
                var o = this._chartsMap[r.__viewId];
                o[t](r, e, n, i), x(r, o), y(r, o)
            }, this), v(this._zr, e)
        }
        function h(t, e) {
            for (var i = "component" === t, n = i ? this._componentsViews : this._chartsViews, r = i ? this._componentsMap : this._chartsMap, a = this._zr, o = 0; o < n.length; o++)
                n[o].__alive = !1;
            e[i ? "eachComponent" : "eachSeries"](function(t, o) {
                if (i) {
                    if ("series" === t)
                        return
                } else
                    o = t;
                var s = o.id + "_" + o.type,
                    l = r[s];
                if (!l) {
                    var c = I.parseClassType(o.type),
                        u = i ? k.getClass(c.main, c.sub) : T.getClass(c.sub);
                    if (!u)
                        return;
                    l = new u, l.init(e, this._api), r[s] = l, n.push(l), a.add(l.group)
                }
                o.__viewId = s, l.__alive = !0, l.__id = s, l.__model = o
            }, this);
            for (var o = 0; o < n.length;) {
                var s = n[o];
                s.__alive ? o++ : (a.remove(s.group), s.dispose(e, this._api), n.splice(o, 1), delete r[s.__id])
            }
        }
        function d(t, e) {
            N(tt, function(i) {
                i.func(t, e)
            })
        }
        function p(t) {
            var e = {};
            t.eachSeries(function(t) {
                var i = t.get("stack"),
                    n = t.getData();
                if (i && "list" === n.type) {
                    var r = e[i];
                    r && (n.stackedOn = r), e[i] = n
                }
            })
        }
        function f(t, e) {
            var i = this._api;
            N(it, function(n) {
                n.isLayout && n.func(t, i, e)
            })
        }
        function g(t, e) {
            var i = this._api;
            t.clearColorPalette(), t.eachSeries(function(t) {
                t.clearColorPalette()
            }), N(it, function(n) {
                n.func(t, i, e)
            })
        }
        function m(t, e) {
            var i = this._api;
            N(this._componentsViews, function(n) {
                var r = n.__model;
                n.render(r, t, i, e), x(r, n)
            }, this), N(this._chartsViews, function(t) {
                t.__alive = !1
            }, this), t.eachSeries(function(n, r) {
                var a = this._chartsMap[n.__viewId];
                a.__alive = !0, a.render(n, t, i, e), a.group.silent = !!n.get("silent"), x(n, a), y(n, a)
            }, this), v(this._zr, t), N(this._chartsViews, function(e) {
                e.__alive || e.remove(t, i)
            }, this)
        }
        function v(t, e) {
            var i = t.storage,
                n = 0;
            i.traverse(function(t) {
                t.isGroup || n++
            }), n > e.get("hoverLayerThreshold") && !b.node && i.traverse(function(t) {
                t.isGroup || (t.useHoverLayer = !0)
            })
        }
        function y(t, e) {
            var i = 0;
            e.group.traverse(function(t) {
                "group" === t.type || t.ignore || i++
            });
            var n = +t.get("progressive"),
                r = i > t.get("progressiveThreshold") && n && !b.node;
            r && e.group.traverse(function(t) {
                t.isGroup || (t.progressive = r ? Math.floor(i++ / n) : -1, r && t.stopAnimation(!0))
            });
            var a = t.get("blendMode") || null;
            __DEV__ && !b.canvasSupported && a && "source-over" !== a && console.warn("Only canvas support blendMode"), e.group.traverse(function(t) {
                t.isGroup || t.setStyle("blend", a)
            })
        }
        function x(t, e) {
            var i = t.get("z"),
                n = t.get("zlevel");
            e.group.traverse(function(t) {
                "group" !== t.type && (null != i && (t.z = i), null != n && (t.zlevel = n))
            })
        }
        function _(t) {
            function e(t, e) {
                for (var i = 0; i < t.length; i++) {
                    var n = t[i];
                    n[a] = e
                }
            }
            var i = 0,
                n = 1,
                r = 2,
                a = "__connectUpdateStatus";
            O.each(Q, function(o, s) {
                t._messageCenter.on(s, function(o) {
                    if (ot[t.group] && t[a] !== i) {
                        var s = t.makeActionFromEvent(o),
                            l = [];
                        O.each(at, function(e) {
                            e !== t && e.group === t.group && l.push(e)
                        }), e(l, i), N(l, function(t) {
                            t[a] !== n && t.dispatchAction(s)
                        }), e(l, r)
                    }
                })
            })
        }
        "undefined" == typeof __DEV__ && ("undefined" != typeof window ? window.__DEV__ = !0 : "undefined" != typeof e && (e.__DEV__ = !0)); /*!
	 * ECharts, a javascript interactive chart library.
	 *
	 * Copyright (c) 2015, Baidu Inc.
	 * All rights reserved.
	 *
	 * LICENSE
	 * https://github.com/ecomfe/echarts/blob/master/LICENSE.txt
	 */








        var b = i(507),
            w = i(508),
            M = i(530),
            S = i(531),
            A = i(532),
            I = i(524),
            D = i(533),
            k = i(534),
            T = i(547),
            C = i(548),
            L = i(510),
            P = i(586),
            E = i(587),
            O = i(509),
            R = i(544),
            z = i(538),
            V = i(591),
            N = O.each,
            B = 1e3,
            F = 5e3,
            H = 1e3,
            G = 2e3,
            $ = 3e3,
            W = 4e3,
            Y = 5e3,
            q = "__flagInMainProcess",
            U = "__hasGradientOrPatternBg",
            Z = "__optionUpdated";
        r.prototype.on = n("on"), r.prototype.off = n("off"), r.prototype.one = n("one"), O.mixin(r, z);
        var j = a.prototype;
        j._onframe = function() {
            this[Z] && (this[q] = !0, X.prepareAndUpdate.call(this), this[q] = !1, this[Z] = !1)
        }, j.getDom = function() {
            return this._dom
        }, j.getZr = function() {
            return this._zr
        }, j.setOption = function(t, e, i) {
            if (__DEV__ && O.assert(!this[q], "`setOption` should not be called during main process."), this[q] = !0, !this._model || e) {
                var n = new A(this._api),
                    r = this._theme,
                    a = this._model = new w(null, null, r, n);
                a.init(null, null, r, n)
            }
            this.__lastOnlyGraphic = !(!t || !t.graphic), O.each(t, function(t, e) {
                "graphic" !== e && (this.__lastOnlyGraphic = !1)
            }, this), this._model.setOption(t, et), i ? this[Z] = !0 : (X.prepareAndUpdate.call(this), this._zr.flush(), this[Z] = !1), this[q] = !1, c.call(this, !1)
        }, j.setTheme = function() {
            console.log("ECharts#setTheme() is DEPRECATED in ECharts 3.0")
        }, j.getModel = function() {
            return this._model
        }, j.getOption = function() {
            return this._model && this._model.getOption()
        }, j.getWidth = function() {
            return this._zr.getWidth()
        }, j.getHeight = function() {
            return this._zr.getHeight()
        }, j.getRenderedCanvas = function(t) {
            if (b.canvasSupported) {
                t = t || {}, t.pixelRatio = t.pixelRatio || 1, t.backgroundColor = t.backgroundColor || this._model.get("backgroundColor");
                var e = this._zr,
                    i = e.storage.getDisplayList();
                return O.each(i, function(t) {
                    t.stopAnimation(!0)
                }), e.painter.getRenderedCanvas(t)
            }
        }, j.getDataURL = function(t) {
            t = t || {};
            var e = t.excludeComponents,
                i = this._model,
                n = [],
                r = this;
            N(e, function(t) {
                i.eachComponent({
                    mainType: t
                }, function(t) {
                    var e = r._componentsMap[t.__viewId];
                    e.group.ignore || (n.push(e), e.group.ignore = !0)
                })
            });
            var a = this.getRenderedCanvas(t).toDataURL("image/" + (t && t.type || "png"));
            return N(n, function(t) {
                t.group.ignore = !1
            }), a
        }, j.getConnectedDataURL = function(t) {
            if (b.canvasSupported) {
                var e = this.group,
                    i = Math.min,
                    n = Math.max,
                    r = 1 / 0;
                if (ot[e]) {
                    var a = r,
                        o = r,
                        s = -r,
                        l = -r,
                        c = [],
                        u = t && t.pixelRatio || 1;
                    O.each(at, function(r, u) {
                        if (r.group === e) {
                            var h = r.getRenderedCanvas(O.clone(t)),
                                d = r.getDom().getBoundingClientRect();
                            a = i(d.left, a), o = i(d.top, o), s = n(d.right, s), l = n(d.bottom, l), c.push({
                                dom: h,
                                left: d.left,
                                top: d.top
                            })
                        }
                    }), a *= u, o *= u, s *= u, l *= u;
                    var h = s - a,
                        d = l - o,
                        p = O.createCanvas();
                    p.width = h, p.height = d;
                    var f = E.init(p);
                    return N(c, function(t) {
                        var e = new C.Image({
                            style: {
                                x: t.left * u - a,
                                y: t.top * u - o,
                                image: t.dom
                            }
                        });
                        f.add(e)
                    }), f.refreshImmediately(), p.toDataURL("image/" + (t && t.type || "png"))
                }
                return this.getDataURL(t)
            }
        }, j.convertToPixel = O.curry(o, "convertToPixel"), j.convertFromPixel = O.curry(o, "convertFromPixel"), j.containPixel = function(t, e) {
            var i,
                n = this._model;
            return t = L.parseFinder(n, t), O.each(t, function(t, n) {
                n.indexOf("Models") >= 0 && O.each(t, function(t) {
                    var r = t.coordinateSystem;
                    if (r && r.containPoint)
                        i |= !!r.containPoint(e);
                    else if ("seriesModels" === n) {
                        var a = this._chartsMap[t.__viewId];
                        a && a.containPoint ? i |= a.containPoint(e, t) : __DEV__ && console.warn(n + ": " + (a ? "The found component do not support containPoint." : "No view mapping to the found component."))
                    } else
                        __DEV__ && console.warn(n + ": containPoint is not supported")
                }, this)
            }, this), !!i
        }, j.getVisual = function(t, e) {
            var i = this._model;
            t = L.parseFinder(i, t, {
                defaultMainType: "series"
            });
            var n = t.seriesModel;
            __DEV__ && (n || console.warn("There is no specified seires model"));
            var r = n.getData(),
                a = t.hasOwnProperty("dataIndexInside") ? t.dataIndexInside : t.hasOwnProperty("dataIndex") ? r.indexOfRawIndex(t.dataIndex) : null;
            return null != a ? r.getItemVisual(a, e) : r.getVisual(e)
        };
        var X = {
            update: function(t) {
                var e = this._model,
                    i = this._api,
                    n = this._coordSysMgr,
                    r = this._zr;
                if (e) {
                    e.restoreData(), n.create(this._model, this._api), d.call(this, e, i), p.call(this, e), n.update(e, i), g.call(this, e, t), m.call(this, e, t);
                    var a = e.get("backgroundColor") || "transparent",
                        o = r.painter;
                    if (o.isSingleCanvas && o.isSingleCanvas())
                        r.configLayer(0, {
                            clearColor: a
                        });
                    else {
                        if (!b.canvasSupported) {
                            var s = R.parse(a);
                            a = R.stringify(s, "rgb"), 0 === s[3] && (a = "transparent")
                        }
                        a.colorStops || a.image ? (r.configLayer(0, {
                            clearColor: a
                        }), this[U] = !0, this._dom.style.background = "transparent") : (this[U] && r.configLayer(0, {
                            clearColor: null
                        }), this[U] = !1, this._dom.style.background = a)
                    }
                }
            },
            updateView: function(t) {
                var e = this._model;
                e && (e.eachSeries(function(t) {
                    t.getData().clearAllVisual()
                }), g.call(this, e, t), u.call(this, "updateView", e, t))
            },
            updateVisual: function(t) {
                var e = this._model;
                e && (e.eachSeries(function(t) {
                    t.getData().clearAllVisual()
                }), g.call(this, e, t), u.call(this, "updateVisual", e, t))
            },
            updateLayout: function(t) {
                var e = this._model;
                e && (f.call(this, e, t), u.call(this, "updateLayout", e, t))
            },
            highlight: function(t) {
                s.call(this, "highlight", t)
            },
            downplay: function(t) {
                s.call(this, "downplay", t)
            },
            prepareAndUpdate: function(t) {
                var e = this._model;
                h.call(this, "component", e), h.call(this, "chart", e), this.__lastOnlyGraphic ? (N(this._componentsViews, function(i) {
                    var n = i.__model;
                    n && "graphic" === n.mainType && (i.render(n, e, this._api, t), x(n, i))
                }, this), this.__lastOnlyGraphic = !1) : X.update.call(this, t)
            }
        };
        j.resize = function(t) {
            __DEV__ && O.assert(!this[q], "`resize` should not be called during main process."), this[q] = !0, this._zr.resize(t);
            var e = this._model && this._model.resetOption("media");
            X[e ? "prepareAndUpdate" : "update"].call(this), this._loadingFX && this._loadingFX.resize(), this[q] = !1, c.call(this)
        }, j.showLoading = function(t, e) {
            if (O.isObject(t) && (e = t, t = ""), t = t || "default", this.hideLoading(), !rt[t])
                return void (__DEV__ && console.warn("Loading effects " + t + " not exists."));
            var i = rt[t](this._api, e),
                n = this._zr;
            this._loadingFX = i, n.add(i)
        }, j.hideLoading = function() {
            this._loadingFX && this._zr.remove(this._loadingFX), this._loadingFX = null
        }, j.makeActionFromEvent = function(t) {
            var e = O.extend({}, t);
            return e.type = Q[t.type], e
        }, j.dispatchAction = function(t, e) {
            if (O.isObject(e) || (e = {
                silent: !!e
            }), J[t.type]) {
                if (this[q])
                    return void this._pendingActions.push(t);
                l.call(this, t, e.silent), e.flush ? this._zr.flush(!0) : e.flush !== !1 && b.browser.weChat && this._throttledZrFlush(), c.call(this, e.silent)
            }
        }, j.on = n("on"), j.off = n("off"), j.one = n("one");
        var K = ["click", "dblclick", "mouseover", "mouseout", "mousemove", "mousedown", "mouseup", "globalout", "contextmenu"];
        j._initEvents = function() {
            N(K, function(t) {
                this._zr.on(t, function(e) {
                    var i,
                        n = this.getModel(),
                        r = e.target;
                    if ("globalout" === t)
                        i = {};
                    else if (r && null != r.dataIndex) {
                        var a = r.dataModel || n.getSeriesByIndex(r.seriesIndex);
                        i = a && a.getDataParams(r.dataIndex, r.dataType) || {}
                    } else
                        r && r.eventData && (i = O.extend({}, r.eventData));
                    i && (i.event = e, i.type = t, this.trigger(t, i))
                }, this)
            }, this), N(Q, function(t, e) {
                this._messageCenter.on(e, function(t) {
                    this.trigger(e, t)
                }, this)
            }, this)
        }, j.isDisposed = function() {
            return this._disposed
        }, j.clear = function() {
            this.setOption({
                series: []
            }, !0)
        }, j.dispose = function() {
            if (this._disposed)
                return void (__DEV__ && console.warn("Instance " + this.id + " has been disposed"));
            this._disposed = !0;
            var t = this._api,
                e = this._model;
            N(this._componentsViews, function(i) {
                i.dispose(e, t)
            }), N(this._chartsViews, function(i) {
                i.dispose(e, t)
            }), this._zr.dispose(), delete at[this.id]
        }, O.mixin(a, z);
        var J = [],
            Q = {},
            tt = [],
            et = [],
            it = [],
            nt = {},
            rt = {},
            at = {},
            ot = {},
            st = new Date - 0,
            lt = new Date - 0,
            ct = "_echarts_instance_",
            ut = {
                version: "3.3.2",
                dependencies: {
                    zrender: "3.2.2"
                }
            };
        ut.init = function(t, e, i) {
            if (__DEV__) {
                if (E.version.replace(".", "") - 0 < ut.dependencies.zrender.replace(".", "") - 0)
                    throw new Error("ZRender " + E.version + " is too old for ECharts " + ut.version + ". Current version need ZRender " + ut.dependencies.zrender + "+");
                if (!t)
                    throw new Error("Initialize failed: invalid dom.");
                !O.isDom(t) || "CANVAS" === t.nodeName.toUpperCase() || t.clientWidth && t.clientHeight || console.warn("Can't get dom width or height")
            }
            var n = new a(t, e, i);
            return n.id = "ec_" + st++, at[n.id] = n, t.setAttribute && t.setAttribute(ct, n.id), _(n), n
        }, ut.connect = function(t) {
            if (O.isArray(t)) {
                var e = t;
                t = null, O.each(e, function(e) {
                    null != e.group && (t = e.group)
                }), t = t || "g_" + lt++, O.each(e, function(e) {
                    e.group = t
                })
            }
            return ot[t] = !0, t
        }, ut.disConnect = function(t) {
            ot[t] = !1
        }, ut.dispose = function(t) {
            O.isDom(t) ? t = ut.getInstanceByDom(t) : "string" == typeof t && (t = at[t]), t instanceof a && !t.isDisposed() && t.dispose()
        }, ut.getInstanceByDom = function(t) {
            var e = t.getAttribute(ct);
            return at[e]
        }, ut.getInstanceById = function(t) {
            return at[t]
        }, ut.registerTheme = function(t, e) {
            nt[t] = e
        }, ut.registerPreprocessor = function(t) {
            et.push(t)
        }, ut.registerProcessor = function(t, e) {
            if ("function" == typeof t && (e = t, t = B), __DEV__ && isNaN(t))
                throw new Error("Unkown processor priority");
            tt.push({
                prio: t,
                func: e
            })
        }, ut.registerAction = function(t, e, i) {
            "function" == typeof e && (i = e, e = "");
            var n = O.isObject(t) ? t.type : [t, t = {
                event: e
            }][0];
            t.event = (t.event || n).toLowerCase(), e = t.event, J[n] || (J[n] = {
                action: i,
                actionInfo: t
            }), Q[e] = n
        }, ut.registerCoordinateSystem = function(t, e) {
            S.register(t, e)
        }, ut.registerLayout = function(t, e) {
            if ("function" == typeof t && (e = t, t = H), __DEV__ && isNaN(t))
                throw new Error("Unkown layout priority");
            it.push({
                prio: t,
                func: e,
                isLayout: !0
            })
        }, ut.registerVisual = function(t, e) {
            if ("function" == typeof t && (e = t, t = $), __DEV__ && isNaN(t))
                throw new Error("Unkown visual priority");
            it.push({
                prio: t,
                func: e
            })
        }, ut.registerLoading = function(t, e) {
            rt[t] = e
        };
        var ht = I.parseClassType;
        ut.extendComponentModel = function(t, e) {
            var i = I;
            if (e) {
                var n = ht(e);
                i = I.getClass(n.main, n.sub, !0)
            }
            return i.extend(t)
        }, ut.extendComponentView = function(t, e) {
            var i = k;
            if (e) {
                var n = ht(e);
                i = k.getClass(n.main, n.sub, !0)
            }
            return i.extend(t)
        }, ut.extendSeriesModel = function(t, e) {
            var i = D;
            if (e) {
                e = "series." + e.replace("series.", "");
                var n = ht(e);
                i = I.getClass(n.main, n.sub, !0)
            }
            return i.extend(t)
        }, ut.extendChartView = function(t, e) {
            var i = T;
            if (e) {
                e.replace("series.", "");
                var n = ht(e);
                i = T.getClass(n.main, !0)
            }
            return i.extend(t)
        }, ut.setCanvasCreator = function(t) {
            O.createCanvas = t
        }, ut.registerVisual(G, i(599)), ut.registerPreprocessor(i(600)), ut.registerLoading("default", i(602)), ut.registerAction({
            type: "highlight",
            event: "highlight",
            update: "highlight"
        }, O.noop), ut.registerAction({
            type: "downplay",
            event: "downplay",
            update: "downplay"
        }, O.noop), ut.List = i(603), ut.Model = i(517), ut.graphic = i(548), ut.number = i(512), ut.format = i(511), ut.matrix = i(516), ut.vector = i(515), ut.color = i(544), ut.util = {}, N(["map", "each", "filter", "indexOf", "inherits", "reduce", "filter", "bind", "curry", "isArray", "isString", "isObject", "isFunction", "extend", "defaults", "clone"], function(t) {
            ut.util[t] = O[t]
        }), ut.PRIORITY = {
            PROCESSOR: {
                FILTER: B,
                STATISTIC: F
            },
            VISUAL: {
                LAYOUT: H,
                GLOBAL: G,
                CHART: $,
                COMPONENT: W,
                BRUSH: Y
            }
        }, t.exports = ut
    }).call(e, function() {
        return this
    }())
}, function(t, e) {
    function i(t) {
        var e = {},
            i = {},
            n = t.match(/Firefox\/([\d.]+)/),
            r = t.match(/MSIE\s([\d.]+)/) || t.match(/Trident\/.+?rv:(([\d.]+))/),
            a = t.match(/Edge\/([\d.]+)/),
            o = /micromessenger/i.test(t);
        return n && (i.firefox = !0, i.version = n[1]), r && (i.ie = !0, i.version = r[1]), a && (i.edge = !0, i.version = a[1]), o && (i.weChat = !0), {
            browser: i,
            os: e,
            node: !1,
            canvasSupported: !!document.createElement("canvas").getContext,
            touchEventsSupported: "ontouchstart" in window && !i.ie && !i.edge,
            pointerEventsSupported: "onpointerdown" in window && (i.edge || i.ie && i.version >= 10)
        }
    }
    var n = {};
    n = "undefined" == typeof navigator ? {
        browser: {},
        os: {},
        node: !0,
        canvasSupported: !0
    } : i(navigator.userAgent), t.exports = n
}, function(t, e, i) {
    function n(t, e) {
        u.each(e, function(e, i) {
            x.hasClass(i) || ("object" == typeof e ? t[i] = t[i] ? u.merge(t[i], e, !1) : u.clone(e) : null == t[i] && (t[i] = e))
        })
    }
    function r(t) {
        t = t, this.option = {}, this.option[b] = 1, this._componentsMap = {}, this._seriesIndices = null, n(t, this._theme.option), u.merge(t, _, !1), this.mergeOption(t)
    }
    function a(t, e) {
        u.isArray(e) || (e = e ? [e] : []);
        var i = {};
        return p(e, function(e) {
            i[e] = (t[e] || []).slice()
        }), i
    }
    function o(t, e, i) {
        var n = e.type ? e.type : i ? i.subType : x.determineSubType(t, e);
        return n
    }
    function s(t) {
        return g(t, function(t) {
                return t.componentIndex
            }) || []
    }
    function l(t, e) {
        return e.hasOwnProperty("subType") ? f(t, function(t) {
            return t.subType === e.subType
        }) : t
    }
    function c(t) {
        if (__DEV__ && !t._seriesIndices)
            throw new Error("Series has not been initialized yet.")
    }
    var u = i(509),
        h = i(510),
        d = i(517),
        p = u.each,
        f = u.filter,
        g = u.map,
        m = u.isArray,
        v = u.indexOf,
        y = u.isObject,
        x = i(524),
        _ = i(528),
        b = "\0_ec_inner",
        w = d.extend({
            constructor: w,
            init: function(t, e, i, n) {
                i = i || {}, this.option = null, this._theme = new d(i), this._optionManager = n
            },
            setOption: function(t, e) {
                u.assert(!(b in t), "please use chart.getOption()"), this._optionManager.setOption(t, e), this.resetOption()
            },
            resetOption: function(t) {
                var e = !1,
                    i = this._optionManager;
                if (!t || "recreate" === t) {
                    var n = i.mountOption("recreate" === t);
                    this.option && "recreate" !== t ? (this.restoreData(), this.mergeOption(n)) : r.call(this, n), e = !0
                }
                if ("timeline" !== t && "media" !== t || this.restoreData(), !t || "recreate" === t || "timeline" === t) {
                    var a = i.getTimelineOption(this);
                    a && (this.mergeOption(a), e = !0)
                }
                if (!t || "recreate" === t || "media" === t) {
                    var o = i.getMediaOption(this, this._api);
                    o.length && p(o, function(t) {
                        this.mergeOption(t, e = !0)
                    }, this)
                }
                return e
            },
            mergeOption: function(t) {
                function e(e, r) {
                    var l = h.normalizeToArray(t[e]),
                        c = h.mappingToExists(n[e], l);
                    h.makeIdAndName(c), p(c, function(t, i) {
                        var n = t.option;
                        y(n) && (t.keyInfo.mainType = e, t.keyInfo.subType = o(e, n, t.exist))
                    });
                    var d = a(n, r);
                    i[e] = [], n[e] = [], p(c, function(t, r) {
                        var a = t.exist,
                            o = t.option;
                        if (u.assert(y(o) || a, "Empty component definition"), o) {
                            var s = x.getClass(e, t.keyInfo.subType, !0);
                            if (a && a instanceof s)
                                a.name = t.keyInfo.name, a.mergeOption(o, this), a.optionUpdated(o, !1);
                            else {
                                var l = u.extend({
                                    dependentModels: d,
                                    componentIndex: r
                                }, t.keyInfo);
                                a = new s(o, this, this, l), u.extend(a, l), a.init(o, this, this, l), a.optionUpdated(null, !0)
                            }
                        } else
                            a.mergeOption({}, this), a.optionUpdated({}, !1);
                        n[e][r] = a, i[e][r] = a.option
                    }, this), "series" === e && (this._seriesIndices = s(n.series))
                }
                var i = this.option,
                    n = this._componentsMap,
                    r = [];
                p(t, function(t, e) {
                    null != t && (x.hasClass(e) ? r.push(e) : i[e] = null == i[e] ? u.clone(t) : u.merge(i[e], t, !0))
                }), x.topologicalTravel(r, x.getAllClassMainTypes(), e, this), this._seriesIndices = this._seriesIndices || []
            },
            getOption: function() {
                var t = u.clone(this.option);
                return p(t, function(e, i) {
                    if (x.hasClass(i)) {
                        for (var e = h.normalizeToArray(e), n = e.length - 1; n >= 0; n--)
                            h.isIdInner(e[n]) && e.splice(n, 1);
                        t[i] = e
                    }
                }), delete t[b], t
            },
            getTheme: function() {
                return this._theme
            },
            getComponent: function(t, e) {
                var i = this._componentsMap[t];
                if (i)
                    return i[e || 0]
            },
            queryComponents: function(t) {
                var e = t.mainType;
                if (!e)
                    return [];
                var i = t.index,
                    n = t.id,
                    r = t.name,
                    a = this._componentsMap[e];
                if (!a || !a.length)
                    return [];
                var o;
                if (null != i)
                    m(i) || (i = [i]), o = f(g(i, function(t) {
                        return a[t]
                    }), function(t) {
                        return !!t
                    });
                else if (null != n) {
                    var s = m(n);
                    o = f(a, function(t) {
                        return s && v(n, t.id) >= 0 || !s && t.id === n
                    })
                } else if (null != r) {
                    var c = m(r);
                    o = f(a, function(t) {
                        return c && v(r, t.name) >= 0 || !c && t.name === r
                    })
                } else
                    o = a;
                return l(o, t)
            },
            findComponents: function(t) {
                function e(t) {
                    var e = r + "Index",
                        i = r + "Id",
                        n = r + "Name";
                    return t && (t.hasOwnProperty(e) || t.hasOwnProperty(i) || t.hasOwnProperty(n)) ? {
                        mainType: r,
                        index: t[e],
                        id: t[i],
                        name: t[n]
                    } : null
                }
                function i(e) {
                    return t.filter ? f(e, t.filter) : e
                }
                var n = t.query,
                    r = t.mainType,
                    a = e(n),
                    o = a ? this.queryComponents(a) : this._componentsMap[r];
                return i(l(o, t))
            },
            eachComponent: function(t, e, i) {
                var n = this._componentsMap;
                if ("function" == typeof t)
                    i = e, e = t, p(n, function(t, n) {
                        p(t, function(t, r) {
                            e.call(i, n, t, r)
                        })
                    });
                else if (u.isString(t))
                    p(n[t], e, i);
                else if (y(t)) {
                    var r = this.findComponents(t);
                    p(r, e, i)
                }
            },
            getSeriesByName: function(t) {
                var e = this._componentsMap.series;
                return f(e, function(e) {
                    return e.name === t
                })
            },
            getSeriesByIndex: function(t) {
                return this._componentsMap.series[t]
            },
            getSeriesByType: function(t) {
                var e = this._componentsMap.series;
                return f(e, function(e) {
                    return e.subType === t
                })
            },
            getSeries: function() {
                return this._componentsMap.series.slice()
            },
            eachSeries: function(t, e) {
                c(this), p(this._seriesIndices, function(i) {
                    var n = this._componentsMap.series[i];
                    t.call(e, n, i)
                }, this)
            },
            eachRawSeries: function(t, e) {
                p(this._componentsMap.series, t, e)
            },
            eachSeriesByType: function(t, e, i) {
                c(this), p(this._seriesIndices, function(n) {
                    var r = this._componentsMap.series[n];
                    r.subType === t && e.call(i, r, n)
                }, this)
            },
            eachRawSeriesByType: function(t, e, i) {
                return p(this.getSeriesByType(t), e, i)
            },
            isSeriesFiltered: function(t) {
                return c(this), u.indexOf(this._seriesIndices, t.componentIndex) < 0
            },
            filterSeries: function(t, e) {
                c(this);
                var i = f(this._componentsMap.series, t, e);
                this._seriesIndices = s(i)
            },
            restoreData: function() {
                var t = this._componentsMap;
                this._seriesIndices = s(t.series);
                var e = [];
                p(t, function(t, i) {
                    e.push(i)
                }), x.topologicalTravel(e, x.getAllClassMainTypes(), function(e, i) {
                    p(t[e], function(t) {
                        t.restoreData()
                    })
                })
            }
        });
    u.mixin(w, i(529)), t.exports = w
}, function(t, e) {
    function i(t) {
        if (null == t || "object" != typeof t)
            return t;
        var e = t,
            n = P.call(t);
        if ("[object Array]" === n) {
            e = [];
            for (var r = 0, a = t.length; r < a; r++)
                e[r] = i(t[r])
        } else if (L[n])
            e = t.constructor.from(t);
        else if (!C[n] && !A(t)) {
            e = {};
            for (var o in t)
                t.hasOwnProperty(o) && (e[o] = i(t[o]))
        }
        return e
    }
    function n(t, e, r) {
        if (!M(e) || !M(t))
            return r ? i(e) : t;
        for (var a in e)
            if (e.hasOwnProperty(a)) {
                var o = t[a],
                    s = e[a];
                !M(s) || !M(o) || _(s) || _(o) || A(s) || A(o) || S(s) || S(o) ? !r && a in t || (t[a] = i(e[a], !0)) : n(o, s, r)
            }
        return t
    }
    function r(t, e) {
        for (var i = t[0], r = 1, a = t.length; r < a; r++)
            i = n(i, t[r], e);
        return i
    }
    function a(t, e) {
        for (var i in e)
            e.hasOwnProperty(i) && (t[i] = e[i]);
        return t
    }
    function o(t, e, i) {
        for (var n in e)
            e.hasOwnProperty(n) && (i ? null != e[n] : null == t[n]) && (t[n] = e[n]);
        return t
    }
    function s() {
        return document.createElement("canvas")
    }
    function l() {
        return T || (T = B.createCanvas().getContext("2d")), T
    }
    function c(t, e) {
        if (t) {
            if (t.indexOf)
                return t.indexOf(e);
            for (var i = 0, n = t.length; i < n; i++)
                if (t[i] === e)
                    return i
        }
        return -1
    }
    function u(t, e) {
        function i() {}
        var n = t.prototype;
        i.prototype = e.prototype, t.prototype = new i;
        for (var r in n)
            t.prototype[r] = n[r];
        t.prototype.constructor = t, t.superClass = e
    }
    function h(t, e, i) {
        t = "prototype" in t ? t.prototype : t, e = "prototype" in e ? e.prototype : e, o(t, e, i)
    }
    function d(t) {
        if (t)
            return "string" != typeof t && "number" == typeof t.length
    }
    function p(t, e, i) {
        if (t && e)
            if (t.forEach && t.forEach === O)
                t.forEach(e, i);
            else if (t.length === +t.length)
                for (var n = 0, r = t.length; n < r; n++)
                    e.call(i, t[n], n, t);
            else
                for (var a in t)
                    t.hasOwnProperty(a) && e.call(i, t[a], a, t)
    }
    function f(t, e, i) {
        if (t && e) {
            if (t.map && t.map === V)
                return t.map(e, i);
            for (var n = [], r = 0, a = t.length; r < a; r++)
                n.push(e.call(i, t[r], r, t));
            return n
        }
    }
    function g(t, e, i, n) {
        if (t && e) {
            if (t.reduce && t.reduce === N)
                return t.reduce(e, i, n);
            for (var r = 0, a = t.length; r < a; r++)
                i = e.call(n, i, t[r], r, t);
            return i
        }
    }
    function m(t, e, i) {
        if (t && e) {
            if (t.filter && t.filter === R)
                return t.filter(e, i);
            for (var n = [], r = 0, a = t.length; r < a; r++)
                e.call(i, t[r], r, t) && n.push(t[r]);
            return n
        }
    }
    function v(t, e, i) {
        if (t && e)
            for (var n = 0, r = t.length; n < r; n++)
                if (e.call(i, t[n], n, t))
                    return t[n]
    }
    function y(t, e) {
        var i = z.call(arguments, 2);
        return function() {
            return t.apply(e, i.concat(z.call(arguments)))
        }
    }
    function x(t) {
        var e = z.call(arguments, 1);
        return function() {
            return t.apply(this, e.concat(z.call(arguments)))
        }
    }
    function _(t) {
        return "[object Array]" === P.call(t)
    }
    function b(t) {
        return "function" == typeof t
    }
    function w(t) {
        return "[object String]" === P.call(t)
    }
    function M(t) {
        var e = typeof t;
        return "function" === e || !!t && "object" == e
    }
    function S(t) {
        return !!C[P.call(t)]
    }
    function A(t) {
        return "object" == typeof t && "number" == typeof t.nodeType && "object" == typeof t.ownerDocument
    }
    function I(t) {
        for (var e = 0, i = arguments.length; e < i; e++)
            if (null != arguments[e])
                return arguments[e]
    }
    function D() {
        return Function.call.apply(z, arguments)
    }
    function k(t, e) {
        if (!t)
            throw new Error(e)
    }
    var T,
        C = {
            "[object Function]": 1,
            "[object RegExp]": 1,
            "[object Date]": 1,
            "[object Error]": 1,
            "[object CanvasGradient]": 1,
            "[object CanvasPattern]": 1,
            "[object Image]": 1,
            "[object Canvas]": 1
        },
        L = {
            "[object Int8Array]": 1,
            "[object Uint8Array]": 1,
            "[object Uint8ClampedArray]": 1,
            "[object Int16Array]": 1,
            "[object Uint16Array]": 1,
            "[object Int32Array]": 1,
            "[object Uint32Array]": 1,
            "[object Float32Array]": 1,
            "[object Float64Array]": 1
        },
        P = Object.prototype.toString,
        E = Array.prototype,
        O = E.forEach,
        R = E.filter,
        z = E.slice,
        V = E.map,
        N = E.reduce,
        B = {
            inherits: u,
            mixin: h,
            clone: i,
            merge: n,
            mergeAll: r,
            extend: a,
            defaults: o,
            getContext: l,
            createCanvas: s,
            indexOf: c,
            slice: D,
            find: v,
            isArrayLike: d,
            each: p,
            map: f,
            reduce: g,
            filter: m,
            bind: y,
            curry: x,
            isArray: _,
            isString: w,
            isObject: M,
            isFunction: b,
            isBuildInObject: S,
            isDom: A,
            retrieve: I,
            assert: k,
            noop: function() {}
        };
    t.exports = B
}, function(t, e, i) {
    function n(t, e) {
        return t && t.hasOwnProperty(e)
    }
    var r = i(511),
        a = i(512),
        o = i(517),
        s = i(509),
        l = s.each,
        c = s.isObject,
        u = {};
    u.normalizeToArray = function(t) {
        return t instanceof Array ? t : null == t ? [] : [t]
    }, u.defaultEmphasis = function(t, e) {
        if (t) {
            var i = t.emphasis = t.emphasis || {},
                n = t.normal = t.normal || {};
            l(e, function(t) {
                var e = s.retrieve(i[t], n[t]);
                null != e && (i[t] = e)
            })
        }
    }, u.LABEL_OPTIONS = ["position", "show", "textStyle", "distance", "formatter"], u.getDataItemValue = function(t) {
        return t && (null == t.value ? t : t.value)
    }, u.isDataItemOption = function(t) {
        return c(t) && !(t instanceof Array)
    }, u.converDataValue = function(t, e) {
        var i = e && e.type;
        return "ordinal" === i ? t : ("time" !== i || isFinite(t) || null == t || "-" === t || (t = +a.parseDate(t)), null == t || "" === t ? NaN : +t)
    }, u.createDataFormatModel = function(t, e) {
        var i = new o;
        return s.mixin(i, u.dataFormatMixin), i.seriesIndex = e.seriesIndex, i.name = e.name || "", i.mainType = e.mainType, i.subType = e.subType, i.getData = function() {
            return t
        }, i
    }, u.dataFormatMixin = {
        getDataParams: function(t, e) {
            var i = this.getData(e),
                n = this.seriesIndex,
                r = this.name,
                a = this.getRawValue(t, e),
                o = i.getRawIndex(t),
                s = i.getName(t, !0),
                l = i.getRawDataItem(t);
            return {
                componentType: this.mainType,
                componentSubType: this.subType,
                seriesType: "series" === this.mainType ? this.subType : null,
                seriesIndex: n,
                seriesName: r,
                name: s,
                dataIndex: o,
                data: l,
                dataType: e,
                value: a,
                color: i.getItemVisual(t, "color"),
                $vars: ["seriesName", "name", "value"]
            }
        },
        getFormattedLabel: function(t, e, i, n) {
            e = e || "normal";
            var a = this.getData(i),
                o = a.getItemModel(t),
                s = this.getDataParams(t, i);
            null != n && s.value instanceof Array && (s.value = s.value[n]);
            var l = o.get(["label", e, "formatter"]);
            return "function" == typeof l ? (s.status = e, l(s)) : "string" == typeof l ? r.formatTpl(l, s) : void 0
        },
        getRawValue: function(t, e) {
            var i = this.getData(e),
                n = i.getRawDataItem(t);
            if (null != n)
                return !c(n) || n instanceof Array ? n : n.value
        },
        formatTooltip: s.noop
    }, u.mappingToExists = function(t, e) {
        e = (e || []).slice();
        var i = s.map(t || [], function(t, e) {
            return {
                exist: t
            }
        });
        return l(e, function(t, n) {
            if (c(t)) {
                for (var r = 0; r < i.length; r++)
                    if (!i[r].option && null != t.id && i[r].exist.id === t.id + "")
                        return i[r].option = t, void (e[n] = null);
                for (var r = 0; r < i.length; r++) {
                    var a = i[r].exist;
                    if (!(i[r].option || null != a.id && null != t.id || null == t.name || u.isIdInner(t) || u.isIdInner(a) || a.name !== t.name + ""))
                        return i[r].option = t, void (e[n] = null)
                }
            }
        }), l(e, function(t, e) {
            if (c(t)) {
                for (var n = 0; n < i.length; n++) {
                    var r = i[n].exist;
                    if (!i[n].option && !u.isIdInner(r) && null == t.id) {
                        i[n].option = t;
                        break
                    }
                }
                n >= i.length && i.push({
                    option: t
                })
            }
        }), i
    }, u.makeIdAndName = function(t) {
        var e = {};
        l(t, function(t, i) {
            var n = t.exist;
            n && (e[n.id] = t)
        }), l(t, function(t, i) {
            var n = t.option;
            s.assert(!n || null == n.id || !e[n.id] || e[n.id] === t, "id duplicates: " + (n && n.id)), n && null != n.id && (e[n.id] = t), !t.keyInfo && (t.keyInfo = {})
        }), l(t, function(t, i) {
            var n = t.exist,
                r = t.option,
                a = t.keyInfo;
            if (c(r)) {
                if (a.name = null != r.name ? r.name + "" : n ? n.name : "\0-", n)
                    a.id = n.id;
                else if (null != r.id)
                    a.id = r.id + "";
                else {
                    var o = 0;
                    do a.id = "\0" + a.name + "\0" + o++;
                    while (e[a.id])
                }
                e[a.id] = t
            }
        })
    }, u.isIdInner = function(t) {
        return c(t) && t.id && 0 === (t.id + "").indexOf("\0_ec_\0")
    }, u.compressBatches = function(t, e) {
        function i(t, e, i) {
            for (var n = 0, r = t.length; n < r; n++)
                for (var a = t[n].seriesId, o = u.normalizeToArray(t[n].dataIndex), s = i && i[a], l = 0, c = o.length; l < c; l++) {
                    var h = o[l];
                    s && s[h] ? s[h] = null : (e[a] || (e[a] = {}))[h] = 1
                }
        }
        function n(t, e) {
            var i = [];
            for (var r in t)
                if (t.hasOwnProperty(r) && null != t[r])
                    if (e)
                        i.push(+r);
                    else {
                        var a = n(t[r], !0);
                        a.length && i.push({
                            seriesId: r,
                            dataIndex: a
                        })
                    }
            return i
        }
        var r = {},
            a = {};
        return i(t || [], r), i(e || [], a, r), [n(r), n(a)]
    }, u.queryDataIndex = function(t, e) {
        return null != e.dataIndexInside ? e.dataIndexInside : null != e.dataIndex ? s.isArray(e.dataIndex) ? s.map(e.dataIndex, function(e) {
            return t.indexOfRawIndex(e)
        }) : t.indexOfRawIndex(e.dataIndex) : null != e.name ? s.isArray(e.name) ? s.map(e.name, function(e) {
            return t.indexOfName(e)
        }) : t.indexOfName(e.name) : void 0
    }, u.parseFinder = function(t, e, i) {
        if (s.isString(e)) {
            var r = {};
            r[e + "Index"] = 0, e = r
        }
        var a = i && i.defaultMainType;
        !a || n(e, a + "Index") || n(e, a + "Id") || n(e, a + "Name") || (e[a + "Index"] = 0);
        var o = {};
        return l(e, function(i, n) {
            var i = e[n];
            if ("dataIndex" === n || "dataIndexInside" === n)
                return void (o[n] = i);
            var r = n.match(/^(\w+)(Index|Id|Name)$/) || [],
                a = r[1],
                s = r[2];
            if (a && s) {
                var l = {
                    mainType: a
                };
                l[s.toLowerCase()] = i;
                var c = t.queryComponents(l);
                o[a + "Models"] = c, o[a + "Model"] = c[0]
            }
        }), o
    }, t.exports = u
}, function(t, e, i) {
    var n = i(509),
        r = i(512),
        a = i(513),
        o = {};
    o.addCommas = function(t) {
        return isNaN(t) ? "-" : (t = (t + "").split("."), t[0].replace(/(\d{1,3})(?=(?:\d{3})+(?!\d))/g, "$1,") + (t.length > 1 ? "." + t[1] : ""))
    }, o.toCamelCase = function(t, e) {
        return t = (t || "").toLowerCase().replace(/-(.)/g, function(t, e) {
            return e.toUpperCase()
        }), e && t && (t = t.charAt(0).toUpperCase() + t.slice(1)), t
    }, o.normalizeCssArray = function(t) {
        var e = t.length;
        return "number" == typeof t ? [t, t, t, t] : 2 === e ? [t[0], t[1], t[0], t[1]] : 3 === e ? [t[0], t[1], t[2], t[1]] : t
    }, o.encodeHTML = function(t) {
        return String(t).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#39;")
    };
    var s = ["a", "b", "c", "d", "e", "f", "g"],
        l = function(t, e) {
            return "{" + t + (null == e ? "" : e) + "}"
        };
    o.formatTpl = function(t, e) {
        n.isArray(e) || (e = [e]);
        var i = e.length;
        if (!i)
            return "";
        for (var r = e[0].$vars || [], a = 0; a < r.length; a++) {
            var o = s[a];
            t = t.replace(l(o), l(o, 0))
        }
        for (var c = 0; c < i; c++)
            for (var u = 0; u < r.length; u++)
                t = t.replace(l(s[u], c), e[c][r[u]]);
        return t
    };
    var c = function(t) {
        return t < 10 ? "0" + t : t
    };
    o.formatTime = function(t, e) {
        "week" !== t && "month" !== t && "quarter" !== t && "half-year" !== t && "year" !== t || (t = "MM-dd\nyyyy");
        var i = r.parseDate(e),
            n = i.getFullYear(),
            a = i.getMonth() + 1,
            o = i.getDate(),
            s = i.getHours(),
            l = i.getMinutes(),
            u = i.getSeconds();
        return t = t.replace("MM", c(a)).toLowerCase().replace("yyyy", n).replace("yy", n % 100).replace("dd", c(o)).replace("d", o).replace("hh", c(s)).replace("h", s).replace("mm", c(l)).replace("m", l).replace("ss", c(u)).replace("s", u)
    }, o.capitalFirst = function(t) {
        return t ? t.charAt(0).toUpperCase() + t.substr(1) : t
    }, o.truncateText = a.truncateText, t.exports = o
}, function(t, e) {
    function i(t) {
        return t.replace(/^\s+/, "").replace(/\s+$/, "")
    }
    var n = {},
        r = 1e-4;
    n.linearMap = function(t, e, i, n) {
        var r = e[1] - e[0],
            a = i[1] - i[0];
        if (0 === r)
            return 0 === a ? i[0] : (i[0] + i[1]) / 2;
        if (n)
            if (r > 0) {
                if (t <= e[0])
                    return i[0];
                if (t >= e[1])
                    return i[1]
            } else {
                if (t >= e[0])
                    return i[0];
                if (t <= e[1])
                    return i[1]
            }
        else {
            if (t === e[0])
                return i[0];
            if (t === e[1])
                return i[1]
        }
        return (t - e[0]) / r * a + i[0]
    }, n.parsePercent = function(t, e) {
        switch (t) {
        case "center":
        case "middle":
            t = "50%";
            break;
        case "left":
        case "top":
            t = "0%";
            break;
        case "right":
        case "bottom":
            t = "100%"
        }
        return "string" == typeof t ? i(t).match(/%$/) ? parseFloat(t) / 100 * e : parseFloat(t) : null == t ? NaN : +t
    }, n.round = function(t, e) {
        return null == e && (e = 10), e = Math.min(Math.max(0, e), 20), +(+t).toFixed(e)
    }, n.asc = function(t) {
        return t.sort(function(t, e) {
            return t - e
        }), t
    }, n.getPrecision = function(t) {
        if (t = +t, isNaN(t))
            return 0;
        for (var e = 1, i = 0; Math.round(t * e) / e !== t;)
            e *= 10, i++;
        return i
    }, n.getPrecisionSafe = function(t) {
        var e = t.toString(),
            i = e.indexOf(".");
        return i < 0 ? 0 : e.length - 1 - i
    }, n.getPixelPrecision = function(t, e) {
        var i = Math.log,
            n = Math.LN10,
            r = Math.floor(i(t[1] - t[0]) / n),
            a = Math.round(i(Math.abs(e[1] - e[0])) / n);
        return Math.max(-r + a, 0)
    }, n.MAX_SAFE_INTEGER = 9007199254740991, n.remRadian = function(t) {
        var e = 2 * Math.PI;
        return (t % e + e) % e
    }, n.isRadianAroundZero = function(t) {
        return t > -r && t < r
    }, n.parseDate = function(t) {
        if (t instanceof Date)
            return t;
        if ("string" == typeof t) {
            var e = new Date(t);
            return isNaN(+e) && (e = new Date(new Date(t.replace(/-/g, "/")) - new Date("1970/01/01"))), e
        }
        return new Date(Math.round(t))
    }, n.quantity = function(t) {
        return Math.pow(10, Math.floor(Math.log(t) / Math.LN10))
    }, n.nice = function(t, e) {
        var i,
            r = n.quantity(t),
            a = t / r;
        return i = e ? a < 1.5 ? 1 : a < 2.5 ? 2 : a < 4 ? 3 : a < 7 ? 5 : 10 : a < 1 ? 1 : a < 2 ? 2 : a < 3 ? 3 : a < 5 ? 5 : 10, i * r
    }, n.reformIntervals = function(t) {
        function e(t, i, n) {
            return t.interval[n] < i.interval[n] || t.interval[n] === i.interval[n] && (t.close[n] - i.close[n] === (n ? -1 : 1) || !n && e(t, i, 1))
        }
        t.sort(function(t, i) {
            return e(t, i, 0) ? -1 : 1
        });
        for (var i = -(1 / 0), n = 1, r = 0; r < t.length;) {
            for (var a = t[r].interval, o = t[r].close, s = 0; s < 2; s++)
                a[s] <= i && (a[s] = i, o[s] = s ? 1 : 1 - n), i = a[s], n = o[s];
            a[0] === a[1] && o[0] * o[1] !== 1 ? t.splice(r, 1) : r++
        }
        return t
    }, t.exports = n
}, function(t, e, i) {
    function n(t, e) {
        var i = t + ":" + e;
        if (l[i])
            return l[i];
        for (var n = (t + "").split("\n"), r = 0, a = 0, o = n.length; a < o; a++)
            r = Math.max(f.measureText(n[a], e).width, r);
        return c > u && (c = 0, l = {}), c++, l[i] = r, r
    }
    function r(t, e, i, r) {
        var a = ((t || "") + "").split("\n").length,
            o = n(t, e),
            s = n("国", e),
            l = a * s,
            c = new d(0, 0, o, l);
        switch (c.lineHeight = s, r) {
        case "bottom":
        case "alphabetic":
            c.y -= s;
            break;
        case "middle":
            c.y -= s / 2
        }
        switch (i) {
        case "end":
        case "right":
            c.x -= c.width;
            break;
        case "center":
            c.x -= c.width / 2
        }
        return c
    }
    function a(t, e, i, n) {
        var r = e.x,
            a = e.y,
            o = e.height,
            s = e.width,
            l = i.height,
            c = o / 2 - l / 2,
            u = "left";
        switch (t) {
        case "left":
            r -= n, a += c, u = "right";
            break;
        case "right":
            r += n + s, a += c, u = "left";
            break;
        case "top":
            r += s / 2, a -= n + l, u = "center";
            break;
        case "bottom":
            r += s / 2, a += o + n, u = "center";
            break;
        case "inside":
            r += s / 2, a += c, u = "center";
            break;
        case "insideLeft":
            r += n, a += c, u = "left";
            break;
        case "insideRight":
            r += s - n, a += c, u = "right";
            break;
        case "insideTop":
            r += s / 2, a += n, u = "center";
            break;
        case "insideBottom":
            r += s / 2, a += o - l - n, u = "center";
            break;
        case "insideTopLeft":
            r += n, a += n, u = "left";
            break;
        case "insideTopRight":
            r += s - n, a += n, u = "right";
            break;
        case "insideBottomLeft":
            r += n, a += o - l - n;
            break;
        case "insideBottomRight":
            r += s - n, a += o - l - n, u = "right"
        }
        return {
            x: r,
            y: a,
            textAlign: u,
            textBaseline: "top"
        }
    }
    function o(t, e, i, r, a) {
        if (!e)
            return "";
        a = a || {}, r = p(r, "...");
        for (var o = p(a.maxIterations, 2), l = p(a.minChar, 0), c = n("国", i), u = n("a", i), h = p(a.placeholder, ""), d = e = Math.max(0, e - 1), f = 0; f < l && d >= u; f++)
            d -= u;
        var g = n(r);
        g > d && (r = "", g = 0), d = e - g;
        for (var m = (t + "").split("\n"), f = 0, v = m.length; f < v; f++) {
            var y = m[f],
                x = n(y, i);
            if (!(x <= e)) {
                for (var _ = 0;; _++) {
                    if (x <= d || _ >= o) {
                        y += r;
                        break
                    }
                    var b = 0 === _ ? s(y, d, u, c) : x > 0 ? Math.floor(y.length * d / x) : 0;
                    y = y.substr(0, b), x = n(y, i)
                }
                "" === y && (y = h), m[f] = y
            }
        }
        return m.join("\n")
    }
    function s(t, e, i, n) {
        for (var r = 0, a = 0, o = t.length; a < o && r < e; a++) {
            var s = t.charCodeAt(a);
            r += 0 <= s && s <= 127 ? i : n
        }
        return a
    }
    var l = {},
        c = 0,
        u = 5e3,
        h = i(509),
        d = i(514),
        p = h.retrieve,
        f = {
            getWidth: n,
            getBoundingRect: r,
            adjustTextPositionOnRect: a,
            truncateText: o,
            measureText: function(t, e) {
                var i = h.getContext();
                return i.font = e || "12px sans-serif", i.measureText(t)
            }
        };
    t.exports = f
}, function(t, e, i) {
    "use strict";
    function n(t, e, i, n) {
        i < 0 && (t += i, i = -i), n < 0 && (e += n, n = -n), this.x = t, this.y = e, this.width = i, this.height = n
    }
    var r = i(515),
        a = i(516),
        o = r.applyTransform,
        s = Math.min,
        l = Math.max;
    n.prototype = {
        constructor: n,
        union: function(t) {
            var e = s(t.x, this.x),
                i = s(t.y, this.y);
            this.width = l(t.x + t.width, this.x + this.width) - e, this.height = l(t.y + t.height, this.y + this.height) - i, this.x = e, this.y = i
        },
        applyTransform: function() {
            var t = [],
                e = [],
                i = [],
                n = [];
            return function(r) {
                if (r) {
                    t[0] = i[0] = this.x, t[1] = n[1] = this.y, e[0] = n[0] = this.x + this.width, e[1] = i[1] = this.y + this.height, o(t, t, r), o(e, e, r), o(i, i, r), o(n, n, r), this.x = s(t[0], e[0], i[0], n[0]), this.y = s(t[1], e[1], i[1], n[1]);
                    var a = l(t[0], e[0], i[0], n[0]),
                        c = l(t[1], e[1], i[1], n[1]);
                    this.width = a - this.x, this.height = c - this.y
                }
            }
        }(),
        calculateTransform: function(t) {
            var e = this,
                i = t.width / e.width,
                n = t.height / e.height,
                r = a.create();
            return a.translate(r, r, [-e.x, -e.y]), a.scale(r, r, [i, n]), a.translate(r, r, [t.x, t.y]), r
        },
        intersect: function(t) {
            if (!t)
                return !1;
            t instanceof n || (t = n.create(t));
            var e = this,
                i = e.x,
                r = e.x + e.width,
                a = e.y,
                o = e.y + e.height,
                s = t.x,
                l = t.x + t.width,
                c = t.y,
                u = t.y + t.height;
            return !(r < s || l < i || o < c || u < a)
        },
        contain: function(t, e) {
            var i = this;
            return t >= i.x && t <= i.x + i.width && e >= i.y && e <= i.y + i.height
        },
        clone: function() {
            return new n(this.x, this.y, this.width, this.height)
        },
        copy: function(t) {
            this.x = t.x, this.y = t.y, this.width = t.width, this.height = t.height
        },
        plain: function() {
            return {
                x: this.x,
                y: this.y,
                width: this.width,
                height: this.height
            }
        }
    }, n.create = function(t) {
        return new n(t.x, t.y, t.width, t.height)
    }, t.exports = n
}, function(t, e) {
    var i = "undefined" == typeof Float32Array ? Array : Float32Array,
        n = {
            create: function(t, e) {
                var n = new i(2);
                return null == t && (t = 0), null == e && (e = 0), n[0] = t, n[1] = e, n
            },
            copy: function(t, e) {
                return t[0] = e[0], t[1] = e[1], t
            },
            clone: function(t) {
                var e = new i(2);
                return e[0] = t[0], e[1] = t[1], e
            },
            set: function(t, e, i) {
                return t[0] = e, t[1] = i, t
            },
            add: function(t, e, i) {
                return t[0] = e[0] + i[0], t[1] = e[1] + i[1], t
            },
            scaleAndAdd: function(t, e, i, n) {
                return t[0] = e[0] + i[0] * n, t[1] = e[1] + i[1] * n, t
            },
            sub: function(t, e, i) {
                return t[0] = e[0] - i[0], t[1] = e[1] - i[1], t
            },
            len: function(t) {
                return Math.sqrt(this.lenSquare(t))
            },
            lenSquare: function(t) {
                return t[0] * t[0] + t[1] * t[1]
            },
            mul: function(t, e, i) {
                return t[0] = e[0] * i[0], t[1] = e[1] * i[1], t
            },
            div: function(t, e, i) {
                return t[0] = e[0] / i[0], t[1] = e[1] / i[1],
                t
            },
            dot: function(t, e) {
                return t[0] * e[0] + t[1] * e[1]
            },
            scale: function(t, e, i) {
                return t[0] = e[0] * i, t[1] = e[1] * i, t
            },
            normalize: function(t, e) {
                var i = n.len(e);
                return 0 === i ? (t[0] = 0, t[1] = 0) : (t[0] = e[0] / i, t[1] = e[1] / i), t
            },
            distance: function(t, e) {
                return Math.sqrt((t[0] - e[0]) * (t[0] - e[0]) + (t[1] - e[1]) * (t[1] - e[1]))
            },
            distanceSquare: function(t, e) {
                return (t[0] - e[0]) * (t[0] - e[0]) + (t[1] - e[1]) * (t[1] - e[1])
            },
            negate: function(t, e) {
                return t[0] = -e[0], t[1] = -e[1], t
            },
            lerp: function(t, e, i, n) {
                return t[0] = e[0] + n * (i[0] - e[0]), t[1] = e[1] + n * (i[1] - e[1]), t
            },
            applyTransform: function(t, e, i) {
                var n = e[0],
                    r = e[1];
                return t[0] = i[0] * n + i[2] * r + i[4], t[1] = i[1] * n + i[3] * r + i[5], t
            },
            min: function(t, e, i) {
                return t[0] = Math.min(e[0], i[0]), t[1] = Math.min(e[1], i[1]), t
            },
            max: function(t, e, i) {
                return t[0] = Math.max(e[0], i[0]), t[1] = Math.max(e[1], i[1]), t
            }
        };
    n.length = n.len, n.lengthSquare = n.lenSquare, n.dist = n.distance, n.distSquare = n.distanceSquare, t.exports = n
}, function(t, e) {
    var i = "undefined" == typeof Float32Array ? Array : Float32Array,
        n = {
            create: function() {
                var t = new i(6);
                return n.identity(t), t
            },
            identity: function(t) {
                return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 1, t[4] = 0, t[5] = 0, t
            },
            copy: function(t, e) {
                return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t
            },
            mul: function(t, e, i) {
                var n = e[0] * i[0] + e[2] * i[1],
                    r = e[1] * i[0] + e[3] * i[1],
                    a = e[0] * i[2] + e[2] * i[3],
                    o = e[1] * i[2] + e[3] * i[3],
                    s = e[0] * i[4] + e[2] * i[5] + e[4],
                    l = e[1] * i[4] + e[3] * i[5] + e[5];
                return t[0] = n, t[1] = r, t[2] = a, t[3] = o, t[4] = s, t[5] = l, t
            },
            translate: function(t, e, i) {
                return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4] + i[0], t[5] = e[5] + i[1], t
            },
            rotate: function(t, e, i) {
                var n = e[0],
                    r = e[2],
                    a = e[4],
                    o = e[1],
                    s = e[3],
                    l = e[5],
                    c = Math.sin(i),
                    u = Math.cos(i);
                return t[0] = n * u + o * c, t[1] = -n * c + o * u, t[2] = r * u + s * c, t[3] = -r * c + u * s, t[4] = u * a + c * l, t[5] = u * l - c * a, t
            },
            scale: function(t, e, i) {
                var n = i[0],
                    r = i[1];
                return t[0] = e[0] * n, t[1] = e[1] * r, t[2] = e[2] * n, t[3] = e[3] * r, t[4] = e[4] * n, t[5] = e[5] * r, t
            },
            invert: function(t, e) {
                var i = e[0],
                    n = e[2],
                    r = e[4],
                    a = e[1],
                    o = e[3],
                    s = e[5],
                    l = i * o - a * n;
                return l ? (l = 1 / l, t[0] = o * l, t[1] = -a * l, t[2] = -n * l, t[3] = i * l, t[4] = (n * s - o * r) * l, t[5] = (a * r - i * s) * l, t) : null
            }
        };
    t.exports = n
}, function(t, e, i) {
    function n(t, e, i) {
        this.parentModel = e, this.ecModel = i, this.option = t
    }
    var r = i(509),
        a = i(518);
    n.prototype = {
        constructor: n,
        init: null,
        mergeOption: function(t) {
            r.merge(this.option, t, !0)
        },
        get: function(t, e) {
            if (!t)
                return this.option;
            "string" == typeof t && (t = t.split("."));
            for (var i = this.option, n = this.parentModel, r = 0; r < t.length && (!t[r] || (i = i && "object" == typeof i ? i[t[r]] : null, null != i)); r++)
                ;
            return null == i && n && !e && (i = n.get(t)), i
        },
        getShallow: function(t, e) {
            var i = this.option,
                n = null == i ? i : i[t],
                r = this.parentModel;
            return null == n && r && !e && (n = r.getShallow(t)), n
        },
        getModel: function(t, e) {
            var i = this.get(t, !0),
                r = this.parentModel,
                a = new n(i, e || r && r.getModel(t), this.ecModel);
            return a
        },
        isEmpty: function() {
            return null == this.option
        },
        restoreData: function() {},
        clone: function() {
            var t = this.constructor;
            return new t(r.clone(this.option))
        },
        setReadOnly: function(t) {
            a.setReadOnly(this, t)
        }
    }, a.enableClassExtend(n);
    var o = r.mixin;
    o(n, i(519)), o(n, i(521)), o(n, i(522)), o(n, i(523)), t.exports = n
}, function(t, e, i) {
    function n(t, e) {
        var i = a.slice(arguments, 2);
        return this.superClass.prototype[e].apply(t, i)
    }
    function r(t, e, i) {
        return this.superClass.prototype[e].apply(t, i)
    }
    var a = i(509),
        o = {},
        s = ".",
        l = "___EC__COMPONENT__CONTAINER___",
        c = o.parseClassType = function(t) {
            var e = {
                main: "",
                sub: ""
            };
            return t && (t = t.split(s), e.main = t[0] || "", e.sub = t[1] || ""), e
        };
    o.enableClassExtend = function(t, e) {
        t.$constructor = t, t.extend = function(t) {
            __DEV__ && a.each(e, function(e) {
                t[e] || console.warn("Method `" + e + "` should be implemented" + (t.type ? " in " + t.type : "") + ".")
            });
            var i = this,
                o = function() {
                    t.$constructor ? t.$constructor.apply(this, arguments) : i.apply(this, arguments)
                };
            return a.extend(o.prototype, t), o.extend = this.extend, o.superCall = n, o.superApply = r, a.inherits(o, this), o.superClass = i, o
        }
    }, o.enableClassManagement = function(t, e) {
        function i(t) {
            var e = n[t.main];
            return e && e[l] || (e = n[t.main] = {}, e[l] = !0), e
        }
        e = e || {};
        var n = {};
        if (t.registerClass = function(t, e) {
            if (e)
                if (e = c(e), e.sub) {
                    if (e.sub !== l) {
                        var r = i(e);
                        r[e.sub] = t
                    }
                } else
                    __DEV__ && n[e.main] && console.warn(e.main + " exists."), n[e.main] = t;
            return t
        }, t.getClass = function(t, e, i) {
            var r = n[t];
            if (r && r[l] && (r = e ? r[e] : null), i && !r)
                throw new Error("Component " + t + "." + (e || "") + " not exists. Load it first.");
            return r
        }, t.getClassesByMainType = function(t) {
            t = c(t);
            var e = [],
                i = n[t.main];
            return i && i[l] ? a.each(i, function(t, i) {
                i !== l && e.push(t)
            }) : e.push(i), e
        }, t.hasClass = function(t) {
            return t = c(t), !!n[t.main]
        }, t.getAllClassMainTypes = function() {
            var t = [];
            return a.each(n, function(e, i) {
                t.push(i)
            }), t
        }, t.hasSubTypes = function(t) {
            t = c(t);
            var e = n[t.main];
            return e && e[l]
        }, t.parseClassType = c, e.registerWhenExtend) {
            var r = t.extend;
            r && (t.extend = function(e) {
                var i = r.call(this, e);
                return t.registerClass(i, e.type)
            })
        }
        return t
    }, o.setReadOnly = function(t, e) {}, t.exports = o
}, function(t, e, i) {
    var n = i(520)([["lineWidth", "width"], ["stroke", "color"], ["opacity"], ["shadowBlur"], ["shadowOffsetX"], ["shadowOffsetY"], ["shadowColor"]]);
    t.exports = {
        getLineStyle: function(t) {
            var e = n.call(this, t),
                i = this.getLineDash(e.lineWidth);
            return i && (e.lineDash = i), e
        },
        getLineDash: function(t) {
            null == t && (t = 1);
            var e = this.get("type"),
                i = Math.max(t, 2),
                n = 4 * t;
            return "solid" === e || null == e ? null : "dashed" === e ? [n, n] : [i, i]
        }
    }
}, function(t, e, i) {
    var n = i(509);
    t.exports = function(t) {
        for (var e = 0; e < t.length; e++)
            t[e][1] || (t[e][1] = t[e][0]);
        return function(e) {
            for (var i = {}, r = 0; r < t.length; r++) {
                var a = t[r][1];
                if (!(e && n.indexOf(e, a) >= 0)) {
                    var o = this.getShallow(a);
                    null != o && (i[t[r][0]] = o)
                }
            }
            return i
        }
    }
}, function(t, e, i) {
    t.exports = {
        getAreaStyle: i(520)([["fill", "color"], ["shadowBlur"], ["shadowOffsetX"], ["shadowOffsetY"], ["opacity"], ["shadowColor"]])
    }
}, function(t, e, i) {
    function n(t, e) {
        return t && t.getShallow(e)
    }
    var r = i(513);
    t.exports = {
        getTextColor: function() {
            var t = this.ecModel;
            return this.getShallow("color") || t && t.get("textStyle.color")
        },
        getFont: function() {
            var t = this.ecModel,
                e = t && t.getModel("textStyle");
            return [this.getShallow("fontStyle") || n(e, "fontStyle"), this.getShallow("fontWeight") || n(e, "fontWeight"), (this.getShallow("fontSize") || n(e, "fontSize") || 12) + "px", this.getShallow("fontFamily") || n(e, "fontFamily") || "sans-serif"].join(" ")
        },
        getTextRect: function(t) {
            return r.getBoundingRect(t, this.getFont(), this.getShallow("align"), this.getShallow("baseline"))
        },
        truncateText: function(t, e, i, n) {
            return r.truncateText(t, e, this.getFont(), i, n)
        }
    }
}, function(t, e, i) {
    var n = i(520)([["fill", "color"], ["stroke", "borderColor"], ["lineWidth", "borderWidth"], ["opacity"], ["shadowBlur"], ["shadowOffsetX"], ["shadowOffsetY"], ["shadowColor"], ["textPosition"], ["textAlign"]]);
    t.exports = {
        getItemStyle: function(t) {
            var e = n.call(this, t),
                i = this.getBorderLineDash();
            return i && (e.lineDash = i), e
        },
        getBorderLineDash: function() {
            var t = this.get("borderType");
            return "solid" === t || null == t ? null : "dashed" === t ? [5, 5] : [1, 1]
        }
    }
}, function(t, e, i) {
    function n(t) {
        var e = [];
        return a.each(u.getClassesByMainType(t), function(t) {
            o.apply(e, t.prototype.dependencies || [])
        }), a.map(e, function(t) {
            return l.parseClassType(t).main
        })
    }
    var r = i(517),
        a = i(509),
        o = Array.prototype.push,
        s = i(525),
        l = i(518),
        c = i(526),
        u = r.extend({
            type: "component",
            id: "",
            name: "",
            mainType: "",
            subType: "",
            componentIndex: 0,
            defaultOption: null,
            ecModel: null,
            dependentModels: [],
            uid: null,
            layoutMode: null,
            $constructor: function(t, e, i, n) {
                r.call(this, t, e, i, n), this.uid = s.getUID("componentModel")
            },
            init: function(t, e, i, n) {
                this.mergeDefaultAndTheme(t, i)
            },
            mergeDefaultAndTheme: function(t, e) {
                var i = this.layoutMode,
                    n = i ? c.getLayoutParams(t) : {},
                    r = e.getTheme();
                a.merge(t, r.get(this.mainType)), a.merge(t, this.getDefaultOption()), i && c.mergeLayoutParam(t, n, i)
            },
            mergeOption: function(t, e) {
                a.merge(this.option, t, !0);
                var i = this.layoutMode;
                i && c.mergeLayoutParam(this.option, t, i)
            },
            optionUpdated: function(t, e) {},
            getDefaultOption: function() {
                if (!this.hasOwnProperty("__defaultOption")) {
                    for (var t = [], e = this.constructor; e;) {
                        var i = e.prototype.defaultOption;
                        i && t.push(i), e = e.superClass
                    }
                    for (var n = {}, r = t.length - 1; r >= 0; r--)
                        n = a.merge(n, t[r], !0);
                    this.__defaultOption = n
                }
                return this.__defaultOption
            },
            getReferringComponents: function(t) {
                return this.ecModel.queryComponents({
                    mainType: t,
                    index: this.get(t + "Index", !0),
                    id: this.get(t + "Id", !0)
                })
            }
        });
    l.enableClassManagement(u, {
        registerWhenExtend: !0
    }), s.enableSubTypeDefaulter(u), s.enableTopologicalTravel(u, n), a.mixin(u, i(527)), t.exports = u
}, function(t, e, i) {
    var n = i(509),
        r = i(518),
        a = r.parseClassType,
        o = 0,
        s = {},
        l = "_";
    s.getUID = function(t) {
        return [t || "", o++, Math.random()].join(l)
    }, s.enableSubTypeDefaulter = function(t) {
        var e = {};
        return t.registerSubTypeDefaulter = function(t, i) {
            t = a(t), e[t.main] = i
        }, t.determineSubType = function(i, n) {
            var r = n.type;
            if (!r) {
                var o = a(i).main;
                t.hasSubTypes(i) && e[o] && (r = e[o](n))
            }
            return r
        }, t
    }, s.enableTopologicalTravel = function(t, e) {
        function i(t) {
            var i = {},
                o = [];
            return n.each(t, function(s) {
                var l = r(i, s),
                    c = l.originalDeps = e(s),
                    u = a(c, t);
                l.entryCount = u.length, 0 === l.entryCount && o.push(s), n.each(u, function(t) {
                    n.indexOf(l.predecessor, t) < 0 && l.predecessor.push(t);
                    var e = r(i, t);
                    n.indexOf(e.successor, t) < 0 && e.successor.push(s)
                })
            }), {
                graph: i,
                noEntryList: o
            }
        }
        function r(t, e) {
            return t[e] || (t[e] = {
                predecessor: [],
                successor: []
            }), t[e]
        }
        function a(t, e) {
            var i = [];
            return n.each(t, function(t) {
                n.indexOf(e, t) >= 0 && i.push(t)
            }), i
        }
        t.topologicalTravel = function(t, e, r, a) {
            function o(t) {
                c[t].entryCount--, 0 === c[t].entryCount && u.push(t)
            }
            function s(t) {
                h[t] = !0, o(t)
            }
            if (t.length) {
                var l = i(e),
                    c = l.graph,
                    u = l.noEntryList,
                    h = {};
                for (n.each(t, function(t) {
                    h[t] = !0
                }); u.length;) {
                    var d = u.pop(),
                        p = c[d],
                        f = !!h[d];
                    f && (r.call(a, d, p.originalDeps.slice()), delete h[d]), n.each(p.successor, f ? s : o)
                }
                n.each(h, function() {
                    throw new Error("Circle dependency may exists")
                })
            }
        }
    }, t.exports = s
}, function(t, e, i) {
    "use strict";
    function n(t, e, i, n, r) {
        var a = 0,
            o = 0;
        null == n && (n = 1 / 0), null == r && (r = 1 / 0);
        var s = 0;
        e.eachChild(function(l, c) {
            var u,
                h,
                d = l.position,
                p = l.getBoundingRect(),
                f = e.childAt(c + 1),
                g = f && f.getBoundingRect();
            if ("horizontal" === t) {
                var m = p.width + (g ? -g.x + p.x : 0);
                u = a + m, u > n || l.newline ? (a = 0, u = m, o += s + i, s = p.height) : s = Math.max(s, p.height)
            } else {
                var v = p.height + (g ? -g.y + p.y : 0);
                h = o + v, h > r || l.newline ? (a += s + i, o = 0, h = v, s = p.width) : s = Math.max(s, p.width)
            }
            l.newline || (d[0] = a, d[1] = o, "horizontal" === t ? a = u + i : o = h + i)
        })
    }
    var r = i(509),
        a = i(514),
        o = i(512),
        s = i(511),
        l = o.parsePercent,
        c = r.each,
        u = {},
        h = u.LOCATION_PARAMS = ["left", "right", "top", "bottom", "width", "height"];
    u.box = n, u.vbox = r.curry(n, "vertical"), u.hbox = r.curry(n, "horizontal"), u.getAvailableSize = function(t, e, i) {
        var n = e.width,
            r = e.height,
            a = l(t.x, n),
            o = l(t.y, r),
            c = l(t.x2, n),
            u = l(t.y2, r);
        return (isNaN(a) || isNaN(parseFloat(t.x))) && (a = 0), (isNaN(c) || isNaN(parseFloat(t.x2))) && (c = n), (isNaN(o) || isNaN(parseFloat(t.y))) && (o = 0), (isNaN(u) || isNaN(parseFloat(t.y2))) && (u = r), i = s.normalizeCssArray(i || 0), {
            width: Math.max(c - a - i[1] - i[3], 0),
            height: Math.max(u - o - i[0] - i[2], 0)
        }
    }, u.getLayoutRect = function(t, e, i) {
        i = s.normalizeCssArray(i || 0);
        var n = e.width,
            r = e.height,
            o = l(t.left, n),
            c = l(t.top, r),
            u = l(t.right, n),
            h = l(t.bottom, r),
            d = l(t.width, n),
            p = l(t.height, r),
            f = i[2] + i[0],
            g = i[1] + i[3],
            m = t.aspect;
        switch (isNaN(d) && (d = n - u - g - o), isNaN(p) && (p = r - h - f - c), isNaN(d) && isNaN(p) && (m > n / r ? d = .8 * n : p = .8 * r), null != m && (isNaN(d) && (d = m * p), isNaN(p) && (p = d / m)), isNaN(o) && (o = n - u - d - g), isNaN(c) && (c = r - h - p - f), t.left || t.right) {
        case "center":
            o = n / 2 - d / 2 - i[3];
            break;
        case "right":
            o = n - d - g
        }
        switch (t.top || t.bottom) {
        case "middle":
        case "center":
            c = r / 2 - p / 2 - i[0];
            break;
        case "bottom":
            c = r - p - f
        }
        o = o || 0, c = c || 0, isNaN(d) && (d = n - o - (u || 0)), isNaN(p) && (p = r - c - (h || 0));
        var v = new a(o + i[3], c + i[0], d, p);
        return v.margin = i, v
    }, u.positionElement = function(t, e, i, n, o) {
        var s = !o || !o.hv || o.hv[0],
            l = !o || !o.hv || o.hv[1],
            c = o && o.boundingMode || "all";
        if (s || l) {
            var h;
            if ("raw" === c)
                h = "group" === t.type ? new a(0, 0, +e.width || 0, +e.height || 0) : t.getBoundingRect();
            else if (h = t.getBoundingRect(), t.needLocalTransform()) {
                var d = t.getLocalTransform();
                h = h.clone(), h.applyTransform(d)
            }
            e = u.getLayoutRect(r.defaults({
                width: h.width,
                height: h.height
            }, e), i, n);
            var p = t.position,
                f = s ? e.x - h.x : 0,
                g = l ? e.y - h.y : 0;
            t.attr("position", "raw" === c ? [f, g] : [p[0] + f, p[1] + g])
        }
    }, u.mergeLayoutParam = function(t, e, i) {
        function n(n) {
            var r = {},
                s = 0,
                l = {},
                u = 0,
                h = i.ignoreSize ? 1 : 2;
            if (c(n, function(e) {
                l[e] = t[e]
            }), c(n, function(t) {
                a(e, t) && (r[t] = l[t] = e[t]), o(r, t) && s++, o(l, t) && u++
            }), u !== h && s) {
                if (s >= h)
                    return r;
                for (var d = 0; d < n.length; d++) {
                    var p = n[d];
                    if (!a(r, p) && a(t, p)) {
                        r[p] = t[p];
                        break
                    }
                }
                return r
            }
            return l
        }
        function a(t, e) {
            return t.hasOwnProperty(e)
        }
        function o(t, e) {
            return null != t[e] && "auto" !== t[e]
        }
        function s(t, e, i) {
            c(t, function(t) {
                e[t] = i[t]
            })
        }
        !r.isObject(i) && (i = {});
        var l = ["width", "left", "right"],
            u = ["height", "top", "bottom"],
            h = n(l),
            d = n(u);
        s(l, t, h), s(u, t, d)
    }, u.getLayoutParams = function(t) {
        return u.copyLayoutParams({}, t)
    }, u.copyLayoutParams = function(t, e) {
        return e && t && c(h, function(i) {
            e.hasOwnProperty(i) && (t[i] = e[i])
        }), t
    }, t.exports = u
}, function(t, e) {
    t.exports = {
        getBoxLayoutParams: function() {
            return {
                left: this.get("left"),
                top: this.get("top"),
                right: this.get("right"),
                bottom: this.get("bottom"),
                width: this.get("width"),
                height: this.get("height")
            }
        }
    }
}, function(t, e) {
    var i = "";
    "undefined" != typeof navigator && (i = navigator.platform || ""), t.exports = {
        color: ["#c23531", "#2f4554", "#61a0a8", "#d48265", "#91c7ae", "#749f83", "#ca8622", "#bda29a", "#6e7074", "#546570", "#c4ccd3"],
        textStyle: {
            fontFamily: i.match(/^Win/) ? "Microsoft YaHei" : "sans-serif",
            fontSize: 12,
            fontStyle: "normal",
            fontWeight: "normal"
        },
        blendMode: null,
        animation: !0,
        animationDuration: 1e3,
        animationDurationUpdate: 300,
        animationEasing: "exponentialOut",
        animationEasingUpdate: "cubicOut",
        animationThreshold: 2e3,
        progressiveThreshold: 3e3,
        progressive: 400,
        hoverLayerThreshold: 3e3
    }
}, function(t, e) {
    t.exports = {
        clearColorPalette: function() {
            this._colorIdx = 0, this._colorNameMap = {}
        },
        getColorFromPalette: function(t, e) {
            e = e || this;
            var i = e._colorIdx || 0,
                n = e._colorNameMap || (e._colorNameMap = {});
            if (n[t])
                return n[t];
            var r = this.get("color", !0) || [];
            if (r.length) {
                var a = r[i];
                return t && (n[t] = a), e._colorIdx = (i + 1) % r.length, a
            }
        }
    }
}, function(t, e, i) {
    "use strict";
    function n(t) {
        r.each(a, function(e) {
            this[e] = r.bind(t[e], t)
        }, this)
    }
    var r = i(509),
        a = ["getDom", "getZr", "getWidth", "getHeight", "dispatchAction", "isDisposed", "on", "off", "getDataURL", "getConnectedDataURL", "getModel", "getOption"];
    t.exports = n
}, function(t, e, i) {
    "use strict";
    function n() {
        this._coordinateSystems = []
    }
    var r = i(509),
        a = {};
    n.prototype = {
        constructor: n,
        create: function(t, e) {
            var i = [];
            r.each(a, function(n, r) {
                var a = n.create(t, e);
                i = i.concat(a || [])
            }), this._coordinateSystems = i
        },
        update: function(t, e) {
            r.each(this._coordinateSystems, function(i) {
                i.update && i.update(t, e)
            })
        },
        getCoordinateSystems: function() {
            return this._coordinateSystems.slice()
        }
    }, n.register = function(t, e) {
        a[t] = e
    }, n.get = function(t) {
        return a[t]
    }, t.exports = n
}, function(t, e, i) {
    function n(t) {
        this._api = t, this._timelineOptions = [], this._mediaList = [], this._mediaDefault, this._currentMediaIndices = [], this._optionBackup, this._newBaseOption
    }
    function r(t, e, i) {
        var n,
            r,
            a = [],
            o = [],
            s = t.timeline;
        if (t.baseOption && (r = t.baseOption), (s || t.options) && (r = r || {}, a = (t.options || []).slice()), t.media) {
            r = r || {};
            var l = t.media;
            d(l, function(t) {
                t && t.option && (t.query ? o.push(t) : n || (n = t))
            })
        }
        return r || (r = t), r.timeline || (r.timeline = s), d([r].concat(a).concat(c.map(o, function(t) {
            return t.option
        })), function(t) {
            d(e, function(e) {
                e(t, i)
            })
        }), {
            baseOption: r,
            timelineOptions: a,
            mediaDefault: n,
            mediaList: o
        }
    }
    function a(t, e, i) {
        var n = {
                width: e,
                height: i,
                aspectratio: e / i
            },
            r = !0;
        return c.each(t, function(t, e) {
            var i = e.match(m);
            if (i && i[1] && i[2]) {
                var a = i[1],
                    s = i[2].toLowerCase();
                o(n[s], t, a) || (r = !1)
            }
        }), r
    }
    function o(t, e, i) {
        return "min" === i ? t >= e : "max" === i ? t <= e : t === e
    }
    function s(t, e) {
        return t.join(",") === e.join(",")
    }
    function l(t, e) {
        e = e || {}, d(e, function(e, i) {
            if (null != e) {
                var n = t[i];
                if (h.hasClass(i)) {
                    e = u.normalizeToArray(e), n = u.normalizeToArray(n);
                    var r = u.mappingToExists(n, e);
                    t[i] = f(r, function(t) {
                        return t.option && t.exist ? g(t.exist, t.option, !0) : t.exist || t.option
                    })
                } else
                    t[i] = g(n, e, !0)
            }
        })
    }
    var c = i(509),
        u = i(510),
        h = i(524),
        d = c.each,
        p = c.clone,
        f = c.map,
        g = c.merge,
        m = /^(min|max)?(.+)$/;
    n.prototype = {
        constructor: n,
        setOption: function(t, e) {
            t = p(t, !0);
            var i = this._optionBackup,
                n = r.call(this, t, e, !i);
            this._newBaseOption = n.baseOption, i ? (l(i.baseOption, n.baseOption), n.timelineOptions.length && (i.timelineOptions = n.timelineOptions), n.mediaList.length && (i.mediaList = n.mediaList), n.mediaDefault && (i.mediaDefault = n.mediaDefault)) : this._optionBackup = n
        },
        mountOption: function(t) {
            var e = this._optionBackup;
            return this._timelineOptions = f(e.timelineOptions, p), this._mediaList = f(e.mediaList, p), this._mediaDefault = p(e.mediaDefault), this._currentMediaIndices = [], p(t ? e.baseOption : this._newBaseOption)
        },
        getTimelineOption: function(t) {
            var e,
                i = this._timelineOptions;
            if (i.length) {
                var n = t.getComponent("timeline");
                n && (e = p(i[n.getCurrentIndex()], !0))
            }
            return e
        },
        getMediaOption: function(t) {
            var e = this._api.getWidth(),
                i = this._api.getHeight(),
                n = this._mediaList,
                r = this._mediaDefault,
                o = [],
                l = [];
            if (!n.length && !r)
                return l;
            for (var c = 0, u = n.length; c < u; c++)
                a(n[c].query, e, i) && o.push(c);
            return !o.length && r && (o = [-1]), o.length && !s(o, this._currentMediaIndices) && (l = f(o, function(t) {
                return p(t === -1 ? r.option : n[t].option)
            })), this._currentMediaIndices = o, l
        }
    }, t.exports = n
}, function(t, e, i) {
    "use strict";
    var n = i(509),
        r = i(511),
        a = i(510),
        o = i(524),
        s = i(529),
        l = i(507),
        c = i(526),
        u = r.encodeHTML,
        h = r.addCommas,
        d = o.extend({
            type: "series.__base__",
            seriesIndex: 0,
            coordinateSystem: null,
            defaultOption: null,
            legendDataProvider: null,
            visualColorAccessPath: "itemStyle.normal.color",
            layoutMode: null,
            init: function(t, e, i, n) {
                this.seriesIndex = this.componentIndex, this.mergeDefaultAndTheme(t, i), this._dataBeforeProcessed = this.getInitialData(t, i), this._data = this._dataBeforeProcessed.cloneShallow()
            },
            mergeDefaultAndTheme: function(t, e) {
                var i = this.layoutMode,
                    r = i ? c.getLayoutParams(t) : {};
                n.merge(t, e.getTheme().get(this.subType)), n.merge(t, this.getDefaultOption()), a.defaultEmphasis(t.label, a.LABEL_OPTIONS), this.fillDataTextStyle(t.data), i && c.mergeLayoutParam(t, r, i)
            },
            mergeOption: function(t, e) {
                t = n.merge(this.option, t, !0), this.fillDataTextStyle(t.data);
                var i = this.layoutMode;
                i && c.mergeLayoutParam(this.option, t, i);
                var r = this.getInitialData(t, e);
                r && (this._data = r, this._dataBeforeProcessed = r.cloneShallow())
            },
            fillDataTextStyle: function(t) {
                if (t)
                    for (var e = 0; e < t.length; e++)
                        t[e] && t[e].label && a.defaultEmphasis(t[e].label, a.LABEL_OPTIONS)
            },
            getInitialData: function() {},
            getData: function(t) {
                return null == t ? this._data : this._data.getLinkedData(t)
            },
            setData: function(t) {
                this._data = t
            },
            getRawData: function() {
                return this._dataBeforeProcessed
            },
            coordDimToDataDim: function(t) {
                return [t]
            },
            dataDimToCoordDim: function(t) {
                return t
            },
            getBaseAxis: function() {
                var t = this.coordinateSystem;
                return t && t.getBaseAxis && t.getBaseAxis()
            },
            formatTooltip: function(t, e, i) {
                function a(t) {
                    var i = [];
                    return n.each(t, function(t, n) {
                        var a,
                            s = o.getDimensionInfo(n),
                            l = s && s.type;
                        a = "ordinal" === l ? t + "" : "time" === l ? e ? "" : r.formatTime("yyyy/MM/dd hh:mm:ss", t) : h(t), a && i.push(a)
                    }), i.join(", ")
                }
                var o = this._data,
                    s = this.getRawValue(t),
                    l = n.isArray(s) ? a(s) : h(s),
                    c = o.getName(t),
                    d = o.getItemVisual(t, "color");
                n.isObject(d) && d.colorStops && (d = (d.colorStops[0] || {}).color), d = d || "transparent";
                var p = '<span style="display:inline-block;margin-right:5px;border-radius:10px;width:9px;height:9px;background-color:' + d + '"></span>',
                    f = this.name;
                return "\0-" === f && (f = ""), e ? p + u(this.name) + " : " + l : (f && u(f) + "<br />") + p + (c ? u(c) + " : " + l : l)
            },
            ifEnableAnimation: function() {
                if (l.node)
                    return !1;
                var t = this.getShallow("animation");
                return t && this.getData().count() > this.getShallow("animationThreshold") && (t = !1), t
            },
            restoreData: function() {
                this._data = this._dataBeforeProcessed.cloneShallow()
            },
            getColorFromPalette: function(t, e) {
                var i = this.ecModel,
                    n = s.getColorFromPalette.call(this, t, e);
                return n || (n = i.getColorFromPalette(t, e)), n
            },
            getAxisTooltipDataIndex: null,
            getTooltipPosition: null
        });
    n.mixin(d, a.dataFormatMixin), n.mixin(d, s), t.exports = d
}, function(t, e, i) {
    var n = i(535),
        r = i(525),
        a = i(518),
        o = function() {
            this.group = new n, this.uid = r.getUID("viewComponent")
        };
    o.prototype = {
        constructor: o,
        init: function(t, e) {},
        render: function(t, e, i, n) {},
        dispose: function() {}
    };
    var s = o.prototype;
    s.updateView = s.updateLayout = s.updateVisual = function(t, e, i, n) {}, a.enableClassExtend(o), a.enableClassManagement(o, {
        registerWhenExtend: !0
    }), t.exports = o
}, function(t, e, i) {
    var n = i(509),
        r = i(536),
        a = i(514),
        o = function(t) {
            t = t || {}, r.call(this, t);
            for (var e in t)
                t.hasOwnProperty(e) && (this[e] = t[e]);
            this._children = [], this.__storage = null, this.__dirty = !0
        };
    o.prototype = {
        constructor: o,
        isGroup: !0,
        type: "group",
        silent: !1,
        children: function() {
            return this._children.slice()
        },
        childAt: function(t) {
            return this._children[t]
        },
        childOfName: function(t) {
            for (var e = this._children, i = 0; i < e.length; i++)
                if (e[i].name === t)
                    return e[i]
        },
        childCount: function() {
            return this._children.length
        },
        add: function(t) {
            return t && t !== this && t.parent !== this && (this._children.push(t), this._doAdd(t)), this
        },
        addBefore: function(t, e) {
            if (t && t !== this && t.parent !== this && e && e.parent === this) {
                var i = this._children,
                    n = i.indexOf(e);
                n >= 0 && (i.splice(n, 0, t), this._doAdd(t))
            }
            return this
        },
        _doAdd: function(t) {
            t.parent && t.parent.remove(t), t.parent = this;
            var e = this.__storage,
                i = this.__zr;
            e && e !== t.__storage && (e.addToMap(t), t instanceof o && t.addChildrenToStorage(e)), i && i.refresh()
        },
        remove: function(t) {
            var e = this.__zr,
                i = this.__storage,
                r = this._children,
                a = n.indexOf(r, t);
            return a < 0 ? this : (r.splice(a, 1), t.parent = null, i && (i.delFromMap(t.id), t instanceof o && t.delChildrenFromStorage(i)), e && e.refresh(), this)
        },
        removeAll: function() {
            var t,
                e,
                i = this._children,
                n = this.__storage;
            for (e = 0; e < i.length; e++)
                t = i[e], n && (n.delFromMap(t.id), t instanceof o && t.delChildrenFromStorage(n)), t.parent = null;
            return i.length = 0, this
        },
        eachChild: function(t, e) {
            for (var i = this._children, n = 0; n < i.length; n++) {
                var r = i[n];
                t.call(e, r, n)
            }
            return this
        },
        traverse: function(t, e) {
            for (var i = 0; i < this._children.length; i++) {
                var n = this._children[i];
                t.call(e, n), "group" === n.type && n.traverse(t, e)
            }
            return this
        },
        addChildrenToStorage: function(t) {
            for (var e = 0; e < this._children.length; e++) {
                var i = this._children[e];
                t.addToMap(i), i instanceof o && i.addChildrenToStorage(t)
            }
        },
        delChildrenFromStorage: function(t) {
            for (var e = 0; e < this._children.length; e++) {
                var i = this._children[e];
                t.delFromMap(i.id), i instanceof o && i.delChildrenFromStorage(t)
            }
        },
        dirty: function() {
            return this.__dirty = !0, this.__zr && this.__zr.refresh(), this
        },
        getBoundingRect: function(t) {
            for (var e = null, i = new a(0, 0, 0, 0), n = t || this._children, r = [], o = 0; o < n.length; o++) {
                var s = n[o];
                if (!s.ignore && !s.invisible) {
                    var l = s.getBoundingRect(),
                        c = s.getLocalTransform(r);
                    c ? (i.copy(l), i.applyTransform(c), e = e || i.clone(), e.union(i)) : (e = e || l.clone(), e.union(l))
                }
            }
            return e || i
        }
    }, n.inherits(o, r), t.exports = o
}, function(t, e, i) {
    "use strict";
    var n = i(537),
        r = i(538),
        a = i(539),
        o = i(540),
        s = i(509),
        l = function(t) {
            a.call(this, t), r.call(this, t), o.call(this, t), this.id = t.id || n()
        };
    l.prototype = {
        type: "element",
        name: "",
        __zr: null,
        ignore: !1,
        clipPath: null,
        drift: function(t, e) {
            switch (this.draggable) {
            case "horizontal":
                e = 0;
                break;
            case "vertical":
                t = 0
            }
            var i = this.transform;
            i || (i = this.transform = [1, 0, 0, 1, 0, 0]), i[4] += t, i[5] += e, this.decomposeTransform(), this.dirty(!1)
        },
        beforeUpdate: function() {},
        afterUpdate: function() {},
        update: function() {
            this.updateTransform()
        },
        traverse: function(t, e) {},
        attrKV: function(t, e) {
            if ("position" === t || "scale" === t || "origin" === t) {
                if (e) {
                    var i = this[t];
                    i || (i = this[t] = []), i[0] = e[0], i[1] = e[1]
                }
            } else
                this[t] = e
        },
        hide: function() {
            this.ignore = !0, this.__zr && this.__zr.refresh()
        },
        show: function() {
            this.ignore = !1, this.__zr && this.__zr.refresh()
        },
        attr: function(t, e) {
            if ("string" == typeof t)
                this.attrKV(t, e);
            else if (s.isObject(t))
                for (var i in t)
                    t.hasOwnProperty(i) && this.attrKV(i, t[i]);
            return this.dirty(!1), this
        },
        setClipPath: function(t) {
            var e = this.__zr;
            e && t.addSelfToZr(e), this.clipPath && this.clipPath !== t && this.removeClipPath(), this.clipPath = t, t.__zr = e, t.__clipTarget = this, this.dirty(!1)
        },
        removeClipPath: function() {
            var t = this.clipPath;
            t && (t.__zr && t.removeSelfFromZr(t.__zr), t.__zr = null, t.__clipTarget = null, this.clipPath = null, this.dirty(!1))
        },
        addSelfToZr: function(t) {
            this.__zr = t;
            var e = this.animators;
            if (e)
                for (var i = 0; i < e.length; i++)
                    t.animation.addAnimator(e[i]);
            this.clipPath && this.clipPath.addSelfToZr(t)
        },
        removeSelfFromZr: function(t) {
            this.__zr = null;
            var e = this.animators;
            if (e)
                for (var i = 0; i < e.length; i++)
                    t.animation.removeAnimator(e[i]);
            this.clipPath && this.clipPath.removeSelfFromZr(t)
        }
    }, s.mixin(l, o), s.mixin(l, a), s.mixin(l, r), t.exports = l
}, function(t, e) {
    var i = 2311;
    t.exports = function() {
        return i++
    }
}, function(t, e) {
    var i = Array.prototype.slice,
        n = function() {
            this._$handlers = {}
        };
    n.prototype = {
        constructor: n,
        one: function(t, e, i) {
            var n = this._$handlers;
            if (!e || !t)
                return this;
            n[t] || (n[t] = []);
            for (var r = 0; r < n[t].length; r++)
                if (n[t][r].h === e)
                    return this;
            return n[t].push({
                h: e,
                one: !0,
                ctx: i || this
            }), this
        },
        on: function(t, e, i) {
            var n = this._$handlers;
            if (!e || !t)
                return this;
            n[t] || (n[t] = []);
            for (var r = 0; r < n[t].length; r++)
                if (n[t][r].h === e)
                    return this;
            return n[t].push({
                h: e,
                one: !1,
                ctx: i || this
            }), this
        },
        isSilent: function(t) {
            var e = this._$handlers;
            return e[t] && e[t].length
        },
        off: function(t, e) {
            var i = this._$handlers;
            if (!t)
                return this._$handlers = {}, this;
            if (e) {
                if (i[t]) {
                    for (var n = [], r = 0, a = i[t].length; r < a; r++)
                        i[t][r].h != e && n.push(i[t][r]);
                    i[t] = n
                }
                i[t] && 0 === i[t].length && delete i[t]
            } else
                delete i[t];
            return this
        },
        trigger: function(t) {
            if (this._$handlers[t]) {
                var e = arguments,
                    n = e.length;
                n > 3 && (e = i.call(e, 1));
                for (var r = this._$handlers[t], a = r.length, o = 0; o < a;) {
                    switch (n) {
                    case 1:
                        r[o].h.call(r[o].ctx);
                        break;
                    case 2:
                        r[o].h.call(r[o].ctx, e[1]);
                        break;
                    case 3:
                        r[o].h.call(r[o].ctx, e[1], e[2]);
                        break;
                    default:
                        r[o].h.apply(r[o].ctx, e)
                    }
                    r[o].one ? (r.splice(o, 1), a--) : o++
                }
            }
            return this
        },
        triggerWithContext: function(t) {
            if (this._$handlers[t]) {
                var e = arguments,
                    n = e.length;
                n > 4 && (e = i.call(e, 1, e.length - 1));
                for (var r = e[e.length - 1], a = this._$handlers[t], o = a.length, s = 0; s < o;) {
                    switch (n) {
                    case 1:
                        a[s].h.call(r);
                        break;
                    case 2:
                        a[s].h.call(r, e[1]);
                        break;
                    case 3:
                        a[s].h.call(r, e[1], e[2]);
                        break;
                    default:
                        a[s].h.apply(r, e)
                    }
                    a[s].one ? (a.splice(s, 1), o--) : s++
                }
            }
            return this
        }
    }, t.exports = n
}, function(t, e, i) {
    "use strict";
    function n(t) {
        return t > s || t < -s
    }
    var r = i(516),
        a = i(515),
        o = r.identity,
        s = 5e-5,
        l = function(t) {
            t = t || {}, t.position || (this.position = [0, 0]), null == t.rotation && (this.rotation = 0), t.scale || (this.scale = [1, 1]), this.origin = this.origin || null
        },
        c = l.prototype;
    c.transform = null, c.needLocalTransform = function() {
        return n(this.rotation) || n(this.position[0]) || n(this.position[1]) || n(this.scale[0] - 1) || n(this.scale[1] - 1)
    }, c.updateTransform = function() {
        var t = this.parent,
            e = t && t.transform,
            i = this.needLocalTransform(),
            n = this.transform;
        return i || e ? (n = n || r.create(), i ? this.getLocalTransform(n) : o(n), e && (i ? r.mul(n, t.transform, n) : r.copy(n, t.transform)), this.transform = n, this.invTransform = this.invTransform || r.create(), void r.invert(this.invTransform, n)) : void (n && o(n))
    }, c.getLocalTransform = function(t) {
        t = t || [], o(t);
        var e = this.origin,
            i = this.scale,
            n = this.rotation,
            a = this.position;
        return e && (t[4] -= e[0], t[5] -= e[1]), r.scale(t, t, i), n && r.rotate(t, t, n), e && (t[4] += e[0], t[5] += e[1]), t[4] += a[0], t[5] += a[1], t
    }, c.setTransform = function(t) {
        var e = this.transform,
            i = t.dpr || 1;
        e ? t.setTransform(i * e[0], i * e[1], i * e[2], i * e[3], i * e[4], i * e[5]) : t.setTransform(i, 0, 0, i, 0, 0)
    }, c.restoreTransform = function(t) {
        var e = (this.transform, t.dpr || 1);
        t.setTransform(e, 0, 0, e, 0, 0)
    };
    var u = [];
    c.decomposeTransform = function() {
        if (this.transform) {
            var t = this.parent,
                e = this.transform;
            t && t.transform && (r.mul(u, t.invTransform, e), e = u);
            var i = e[0] * e[0] + e[1] * e[1],
                a = e[2] * e[2] + e[3] * e[3],
                o = this.position,
                s = this.scale;
            n(i - 1) && (i = Math.sqrt(i)), n(a - 1) && (a = Math.sqrt(a)), e[0] < 0 && (i = -i), e[3] < 0 && (a = -a), o[0] = e[4], o[1] = e[5], s[0] = i, s[1] = a, this.rotation = Math.atan2(-e[1] / a, e[0] / i)
        }
    }, c.getGlobalScale = function() {
        var t = this.transform;
        if (!t)
            return [1, 1];
        var e = Math.sqrt(t[0] * t[0] + t[1] * t[1]),
            i = Math.sqrt(t[2] * t[2] + t[3] * t[3]);
        return t[0] < 0 && (e = -e), t[3] < 0 && (i = -i), [e, i]
    }, c.transformCoordToLocal = function(t, e) {
        var i = [t, e],
            n = this.invTransform;
        return n && a.applyTransform(i, i, n), i
    }, c.transformCoordToGlobal = function(t, e) {
        var i = [t, e],
            n = this.transform;
        return n && a.applyTransform(i, i, n), i
    }, t.exports = l
}, function(t, e, i) {
    "use strict";
    var n = i(541),
        r = i(509),
        a = r.isString,
        o = r.isFunction,
        s = r.isObject,
        l = i(545),
        c = function() {
            this.animators = []
        };
    c.prototype = {
        constructor: c,
        animate: function(t, e) {
            var i,
                a = !1,
                o = this,
                s = this.__zr;
            if (t) {
                var c = t.split("."),
                    u = o;
                a = "shape" === c[0];
                for (var h = 0, d = c.length; h < d; h++)
                    u && (u = u[c[h]]);
                u && (i = u)
            } else
                i = o;
            if (!i)
                return void l('Property "' + t + '" is not existed in element ' + o.id);
            var p = o.animators,
                f = new n(i, e);
            return f.during(function(t) {
                o.dirty(a)
            }).done(function() {
                p.splice(r.indexOf(p, f), 1)
            }), p.push(f), s && s.animation.addAnimator(f), f
        },
        stopAnimation: function(t) {
            for (var e = this.animators, i = e.length, n = 0; n < i; n++)
                e[n].stop(t);
            return e.length = 0, this
        },
        animateTo: function(t, e, i, n, r) {
            function s() {
                c--, c || r && r()
            }
            a(i) ? (r = n, n = i, i = 0) : o(n) ? (r = n, n = "linear", i = 0) : o(i) ? (r = i, i = 0) : o(e) ? (r = e, e = 500) : e || (e = 500), this.stopAnimation(), this._animateToShallow("", this, t, e, i, n, r);
            var l = this.animators.slice(),
                c = l.length;
            c || r && r();
            for (var u = 0; u < l.length; u++)
                l[u].done(s).start(n)
        },
        _animateToShallow: function(t, e, i, n, a) {
            var o = {},
                l = 0;
            for (var c in i)
                if (i.hasOwnProperty(c))
                    if (null != e[c])
                        s(i[c]) && !r.isArrayLike(i[c]) ? this._animateToShallow(t ? t + "." + c : c, e[c], i[c], n, a) : (o[c] = i[c], l++);
                    else if (null != i[c])
                        if (t) {
                            var u = {};
                            u[t] = {}, u[t][c] = i[c], this.attr(u)
                        } else
                            this.attr(c, i[c]);
            return l > 0 && this.animate(t, !1).when(null == n ? 500 : n, o).delay(a || 0), this
        }
    }, t.exports = c
}, function(t, e, i) {
    function n(t, e) {
        return t[e]
    }
    function r(t, e, i) {
        t[e] = i
    }
    function a(t, e, i) {
        return (e - t) * i + t
    }
    function o(t, e, i) {
        return i > .5 ? e : t
    }
    function s(t, e, i, n, r) {
        var o = t.length;
        if (1 == r)
            for (var s = 0; s < o; s++)
                n[s] = a(t[s], e[s], i);
        else
            for (var l = t[0].length, s = 0; s < o; s++)
                for (var c = 0; c < l; c++)
                    n[s][c] = a(t[s][c], e[s][c], i)
    }
    function l(t, e, i) {
        var n = t.length,
            r = e.length;
        if (n !== r) {
            var a = n > r;
            if (a)
                t.length = r;
            else
                for (var o = n; o < r; o++)
                    t.push(1 === i ? e[o] : x.call(e[o]))
        }
        for (var s = t[0] && t[0].length, o = 0; o < t.length; o++)
            if (1 === i)
                isNaN(t[o]) && (t[o] = e[o]);
            else
                for (var l = 0; l < s; l++)
                    isNaN(t[o][l]) && (t[o][l] = e[o][l])
    }
    function c(t, e, i) {
        if (t === e)
            return !0;
        var n = t.length;
        if (n !== e.length)
            return !1;
        if (1 === i) {
            for (var r = 0; r < n; r++)
                if (t[r] !== e[r])
                    return !1
        } else
            for (var a = t[0].length, r = 0; r < n; r++)
                for (var o = 0; o < a; o++)
                    if (t[r][o] !== e[r][o])
                        return !1;
        return !0
    }
    function u(t, e, i, n, r, a, o, s, l) {
        var c = t.length;
        if (1 == l)
            for (var u = 0; u < c; u++)
                s[u] = h(t[u], e[u], i[u], n[u], r, a, o);
        else
            for (var d = t[0].length, u = 0; u < c; u++)
                for (var p = 0; p < d; p++)
                    s[u][p] = h(t[u][p], e[u][p], i[u][p], n[u][p], r, a, o)
    }
    function h(t, e, i, n, r, a, o) {
        var s = .5 * (i - t),
            l = .5 * (n - e);
        return (2 * (e - i) + s + l) * o + (-3 * (e - i) - 2 * s - l) * a + s * r + e
    }
    function d(t) {
        if (y(t)) {
            var e = t.length;
            if (y(t[0])) {
                for (var i = [], n = 0; n < e; n++)
                    i.push(x.call(t[n]));
                return i
            }
            return x.call(t)
        }
        return t
    }
    function p(t) {
        return t[0] = Math.floor(t[0]), t[1] = Math.floor(t[1]), t[2] = Math.floor(t[2]), "rgba(" + t.join(",") + ")"
    }
    function f(t, e, i, n, r) {
        var d = t._getter,
            f = t._setter,
            v = "spline" === e,
            x = n.length;
        if (x) {
            var _,
                b = n[0].value,
                w = y(b),
                M = !1,
                S = !1,
                A = w && y(b[0]) ? 2 : 1;
            n.sort(function(t, e) {
                return t.time - e.time
            }), _ = n[x - 1].time;
            for (var I = [], D = [], k = n[0].value, T = !0, C = 0; C < x; C++) {
                I.push(n[C].time / _);
                var L = n[C].value;
                if (w && c(L, k, A) || !w && L === k || (T = !1), k = L, "string" == typeof L) {
                    var P = m.parse(L);
                    P ? (L = P, M = !0) : S = !0
                }
                D.push(L)
            }
            if (!T) {
                for (var E = D[x - 1], C = 0; C < x - 1; C++)
                    w ? l(D[C], E, A) : !isNaN(D[C]) || isNaN(E) || S || M || (D[C] = E);
                w && l(d(t._target, r), E, A);
                var O,
                    R,
                    z,
                    V,
                    N,
                    B,
                    F = 0,
                    H = 0;
                if (M)
                    var G = [0, 0, 0, 0];
                var $ = function(t, e) {
                        var i;
                        if (e < 0)
                            i = 0;
                        else if (e < H) {
                            for (O = Math.min(F + 1, x - 1), i = O; i >= 0 && !(I[i] <= e); i--)
                                ;
                            i = Math.min(i, x - 2)
                        } else {
                            for (i = F; i < x && !(I[i] > e); i++)
                                ;
                            i = Math.min(i - 1, x - 2)
                        }
                        F = i, H = e;
                        var n = I[i + 1] - I[i];
                        if (0 !== n)
                            if (R = (e - I[i]) / n, v)
                                if (V = D[i], z = D[0 === i ? i : i - 1], N = D[i > x - 2 ? x - 1 : i + 1], B = D[i > x - 3 ? x - 1 : i + 2], w)
                                    u(z, V, N, B, R, R * R, R * R * R, d(t, r), A);
                                else {
                                    var l;
                                    if (M)
                                        l = u(z, V, N, B, R, R * R, R * R * R, G, 1), l = p(G);
                                    else {
                                        if (S)
                                            return o(V, N, R);
                                        l = h(z, V, N, B, R, R * R, R * R * R)
                                    }
                                    f(t, r, l)
                                }
                            else if (w)
                                s(D[i], D[i + 1], R, d(t, r), A);
                            else {
                                var l;
                                if (M)
                                    s(D[i], D[i + 1], R, G, 1), l = p(G);
                                else {
                                    if (S)
                                        return o(D[i], D[i + 1], R);
                                    l = a(D[i], D[i + 1], R)
                                }
                                f(t, r, l)
                            }
                    },
                    W = new g({
                        target: t._target,
                        life: _,
                        loop: t._loop,
                        delay: t._delay,
                        onframe: $,
                        ondestroy: i
                    });
                return e && "spline" !== e && (W.easing = e), W
            }
        }
    }
    var g = i(542),
        m = i(544),
        v = i(509),
        y = v.isArrayLike,
        x = Array.prototype.slice,
        _ = function(t, e, i, a) {
            this._tracks = {}, this._target = t, this._loop = e || !1, this._getter = i || n, this._setter = a || r, this._clipCount = 0, this._delay = 0, this._doneList = [], this._onframeList = [], this._clipList = []
        };
    _.prototype = {
        when: function(t, e) {
            var i = this._tracks;
            for (var n in e)
                if (e.hasOwnProperty(n)) {
                    if (!i[n]) {
                        i[n] = [];
                        var r = this._getter(this._target, n);
                        if (null == r)
                            continue;
                        0 !== t && i[n].push({
                            time: 0,
                            value: d(r)
                        })
                    }
                    i[n].push({
                        time: t,
                        value: e[n]
                    })
                }
            return this
        },
        during: function(t) {
            return this._onframeList.push(t), this
        },
        _doneCallback: function() {
            this._tracks = {}, this._clipList.length = 0;
            for (var t = this._doneList, e = t.length, i = 0; i < e; i++)
                t[i].call(this)
        },
        start: function(t) {
            var e,
                i = this,
                n = 0,
                r = function() {
                    n--, n || i._doneCallback();
                };
            for (var a in this._tracks)
                if (this._tracks.hasOwnProperty(a)) {
                    var o = f(this, t, r, this._tracks[a], a);
                    o && (this._clipList.push(o), n++, this.animation && this.animation.addClip(o), e = o)
                }
            if (e) {
                var s = e.onframe;
                e.onframe = function(t, e) {
                    s(t, e);
                    for (var n = 0; n < i._onframeList.length; n++)
                        i._onframeList[n](t, e)
                }
            }
            return n || this._doneCallback(), this
        },
        stop: function(t) {
            for (var e = this._clipList, i = this.animation, n = 0; n < e.length; n++) {
                var r = e[n];
                t && r.onframe(this._target, 1), i && i.removeClip(r)
            }
            e.length = 0
        },
        delay: function(t) {
            return this._delay = t, this
        },
        done: function(t) {
            return t && this._doneList.push(t), this
        },
        getClips: function() {
            return this._clipList
        }
    }, t.exports = _
}, function(t, e, i) {
    function n(t) {
        this._target = t.target, this._life = t.life || 1e3, this._delay = t.delay || 0, this._initialized = !1, this.loop = null != t.loop && t.loop, this.gap = t.gap || 0, this.easing = t.easing || "Linear", this.onframe = t.onframe, this.ondestroy = t.ondestroy, this.onrestart = t.onrestart
    }
    var r = i(543);
    n.prototype = {
        constructor: n,
        step: function(t) {
            this._initialized || (this._startTime = t + this._delay, this._initialized = !0);
            var e = (t - this._startTime) / this._life;
            if (!(e < 0)) {
                e = Math.min(e, 1);
                var i = this.easing,
                    n = "string" == typeof i ? r[i] : i,
                    a = "function" == typeof n ? n(e) : e;
                return this.fire("frame", a), 1 == e ? this.loop ? (this.restart(t), "restart") : (this._needsRemove = !0, "destroy") : null
            }
        },
        restart: function(t) {
            var e = (t - this._startTime) % this._life;
            this._startTime = t - e + this.gap, this._needsRemove = !1
        },
        fire: function(t, e) {
            t = "on" + t, this[t] && this[t](this._target, e)
        }
    }, t.exports = n
}, function(t, e) {
    var i = {
        linear: function(t) {
            return t
        },
        quadraticIn: function(t) {
            return t * t
        },
        quadraticOut: function(t) {
            return t * (2 - t)
        },
        quadraticInOut: function(t) {
            return (t *= 2) < 1 ? .5 * t * t : -.5 * (--t * (t - 2) - 1)
        },
        cubicIn: function(t) {
            return t * t * t
        },
        cubicOut: function(t) {
            return --t * t * t + 1
        },
        cubicInOut: function(t) {
            return (t *= 2) < 1 ? .5 * t * t * t : .5 * ((t -= 2) * t * t + 2)
        },
        quarticIn: function(t) {
            return t * t * t * t
        },
        quarticOut: function(t) {
            return 1 - --t * t * t * t
        },
        quarticInOut: function(t) {
            return (t *= 2) < 1 ? .5 * t * t * t * t : -.5 * ((t -= 2) * t * t * t - 2)
        },
        quinticIn: function(t) {
            return t * t * t * t * t
        },
        quinticOut: function(t) {
            return --t * t * t * t * t + 1
        },
        quinticInOut: function(t) {
            return (t *= 2) < 1 ? .5 * t * t * t * t * t : .5 * ((t -= 2) * t * t * t * t + 2)
        },
        sinusoidalIn: function(t) {
            return 1 - Math.cos(t * Math.PI / 2)
        },
        sinusoidalOut: function(t) {
            return Math.sin(t * Math.PI / 2)
        },
        sinusoidalInOut: function(t) {
            return .5 * (1 - Math.cos(Math.PI * t))
        },
        exponentialIn: function(t) {
            return 0 === t ? 0 : Math.pow(1024, t - 1)
        },
        exponentialOut: function(t) {
            return 1 === t ? 1 : 1 - Math.pow(2, -10 * t)
        },
        exponentialInOut: function(t) {
            return 0 === t ? 0 : 1 === t ? 1 : (t *= 2) < 1 ? .5 * Math.pow(1024, t - 1) : .5 * (-Math.pow(2, -10 * (t - 1)) + 2)
        },
        circularIn: function(t) {
            return 1 - Math.sqrt(1 - t * t)
        },
        circularOut: function(t) {
            return Math.sqrt(1 - --t * t)
        },
        circularInOut: function(t) {
            return (t *= 2) < 1 ? -.5 * (Math.sqrt(1 - t * t) - 1) : .5 * (Math.sqrt(1 - (t -= 2) * t) + 1)
        },
        elasticIn: function(t) {
            var e,
                i = .1,
                n = .4;
            return 0 === t ? 0 : 1 === t ? 1 : (!i || i < 1 ? (i = 1, e = n / 4) : e = n * Math.asin(1 / i) / (2 * Math.PI), -(i * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - e) * (2 * Math.PI) / n)))
        },
        elasticOut: function(t) {
            var e,
                i = .1,
                n = .4;
            return 0 === t ? 0 : 1 === t ? 1 : (!i || i < 1 ? (i = 1, e = n / 4) : e = n * Math.asin(1 / i) / (2 * Math.PI), i * Math.pow(2, -10 * t) * Math.sin((t - e) * (2 * Math.PI) / n) + 1)
        },
        elasticInOut: function(t) {
            var e,
                i = .1,
                n = .4;
            return 0 === t ? 0 : 1 === t ? 1 : (!i || i < 1 ? (i = 1, e = n / 4) : e = n * Math.asin(1 / i) / (2 * Math.PI), (t *= 2) < 1 ? -.5 * (i * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - e) * (2 * Math.PI) / n)) : i * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - e) * (2 * Math.PI) / n) * .5 + 1)
        },
        backIn: function(t) {
            var e = 1.70158;
            return t * t * ((e + 1) * t - e)
        },
        backOut: function(t) {
            var e = 1.70158;
            return --t * t * ((e + 1) * t + e) + 1
        },
        backInOut: function(t) {
            var e = 2.5949095;
            return (t *= 2) < 1 ? .5 * (t * t * ((e + 1) * t - e)) : .5 * ((t -= 2) * t * ((e + 1) * t + e) + 2)
        },
        bounceIn: function(t) {
            return 1 - i.bounceOut(1 - t)
        },
        bounceOut: function(t) {
            return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375
        },
        bounceInOut: function(t) {
            return t < .5 ? .5 * i.bounceIn(2 * t) : .5 * i.bounceOut(2 * t - 1) + .5
        }
    };
    t.exports = i
}, function(t, e) {
    function i(t) {
        return t = Math.round(t), t < 0 ? 0 : t > 255 ? 255 : t
    }
    function n(t) {
        return t = Math.round(t), t < 0 ? 0 : t > 360 ? 360 : t
    }
    function r(t) {
        return t < 0 ? 0 : t > 1 ? 1 : t
    }
    function a(t) {
        return i(t.length && "%" === t.charAt(t.length - 1) ? parseFloat(t) / 100 * 255 : parseInt(t, 10))
    }
    function o(t) {
        return r(t.length && "%" === t.charAt(t.length - 1) ? parseFloat(t) / 100 : parseFloat(t))
    }
    function s(t, e, i) {
        return i < 0 ? i += 1 : i > 1 && (i -= 1), 6 * i < 1 ? t + (e - t) * i * 6 : 2 * i < 1 ? e : 3 * i < 2 ? t + (e - t) * (2 / 3 - i) * 6 : t
    }
    function l(t, e, i) {
        return t + (e - t) * i
    }
    function c(t) {
        if (t) {
            t += "";
            var e = t.replace(/ /g, "").toLowerCase();
            if (e in x)
                return x[e].slice();
            if ("#" !== e.charAt(0)) {
                var i = e.indexOf("("),
                    n = e.indexOf(")");
                if (i !== -1 && n + 1 === e.length) {
                    var r = e.substr(0, i),
                        s = e.substr(i + 1, n - (i + 1)).split(","),
                        l = 1;
                    switch (r) {
                    case "rgba":
                        if (4 !== s.length)
                            return;
                        l = o(s.pop());
                    case "rgb":
                        if (3 !== s.length)
                            return;
                        return [a(s[0]), a(s[1]), a(s[2]), l];
                    case "hsla":
                        if (4 !== s.length)
                            return;
                        return s[3] = o(s[3]), u(s);
                    case "hsl":
                        if (3 !== s.length)
                            return;
                        return u(s);
                    default:
                        return
                    }
                }
            } else {
                if (4 === e.length) {
                    var c = parseInt(e.substr(1), 16);
                    if (!(c >= 0 && c <= 4095))
                        return;
                    return [(3840 & c) >> 4 | (3840 & c) >> 8, 240 & c | (240 & c) >> 4, 15 & c | (15 & c) << 4, 1]
                }
                if (7 === e.length) {
                    var c = parseInt(e.substr(1), 16);
                    if (!(c >= 0 && c <= 16777215))
                        return;
                    return [(16711680 & c) >> 16, (65280 & c) >> 8, 255 & c, 1]
                }
            }
        }
    }
    function u(t) {
        var e = (parseFloat(t[0]) % 360 + 360) % 360 / 360,
            n = o(t[1]),
            r = o(t[2]),
            a = r <= .5 ? r * (n + 1) : r + n - r * n,
            l = 2 * r - a,
            c = [i(255 * s(l, a, e + 1 / 3)), i(255 * s(l, a, e)), i(255 * s(l, a, e - 1 / 3))];
        return 4 === t.length && (c[3] = t[3]), c
    }
    function h(t) {
        if (t) {
            var e,
                i,
                n = t[0] / 255,
                r = t[1] / 255,
                a = t[2] / 255,
                o = Math.min(n, r, a),
                s = Math.max(n, r, a),
                l = s - o,
                c = (s + o) / 2;
            if (0 === l)
                e = 0, i = 0;
            else {
                i = c < .5 ? l / (s + o) : l / (2 - s - o);
                var u = ((s - n) / 6 + l / 2) / l,
                    h = ((s - r) / 6 + l / 2) / l,
                    d = ((s - a) / 6 + l / 2) / l;
                n === s ? e = d - h : r === s ? e = 1 / 3 + u - d : a === s && (e = 2 / 3 + h - u), e < 0 && (e += 1), e > 1 && (e -= 1)
            }
            var p = [360 * e, i, c];
            return null != t[3] && p.push(t[3]), p
        }
    }
    function d(t, e) {
        var i = c(t);
        if (i) {
            for (var n = 0; n < 3; n++)
                e < 0 ? i[n] = i[n] * (1 - e) | 0 : i[n] = (255 - i[n]) * e + i[n] | 0;
            return y(i, 4 === i.length ? "rgba" : "rgb")
        }
    }
    function p(t, e) {
        var i = c(t);
        if (i)
            return ((1 << 24) + (i[0] << 16) + (i[1] << 8) + +i[2]).toString(16).slice(1)
    }
    function f(t, e, n) {
        if (e && e.length && t >= 0 && t <= 1) {
            n = n || [0, 0, 0, 0];
            var r = t * (e.length - 1),
                a = Math.floor(r),
                o = Math.ceil(r),
                s = e[a],
                c = e[o],
                u = r - a;
            return n[0] = i(l(s[0], c[0], u)), n[1] = i(l(s[1], c[1], u)), n[2] = i(l(s[2], c[2], u)), n[3] = i(l(s[3], c[3], u)), n
        }
    }
    function g(t, e, n) {
        if (e && e.length && t >= 0 && t <= 1) {
            var a = t * (e.length - 1),
                o = Math.floor(a),
                s = Math.ceil(a),
                u = c(e[o]),
                h = c(e[s]),
                d = a - o,
                p = y([i(l(u[0], h[0], d)), i(l(u[1], h[1], d)), i(l(u[2], h[2], d)), r(l(u[3], h[3], d))], "rgba");
            return n ? {
                color: p,
                leftIndex: o,
                rightIndex: s,
                value: a
            } : p
        }
    }
    function m(t, e, i, r) {
        if (t = c(t))
            return t = h(t), null != e && (t[0] = n(e)), null != i && (t[1] = o(i)), null != r && (t[2] = o(r)), y(u(t), "rgba")
    }
    function v(t, e) {
        if (t = c(t), t && null != e)
            return t[3] = r(e), y(t, "rgba")
    }
    function y(t, e) {
        var i = t[0] + "," + t[1] + "," + t[2];
        return "rgba" !== e && "hsva" !== e && "hsla" !== e || (i += "," + t[3]), e + "(" + i + ")"
    }
    var x = {
        transparent: [0, 0, 0, 0],
        aliceblue: [240, 248, 255, 1],
        antiquewhite: [250, 235, 215, 1],
        aqua: [0, 255, 255, 1],
        aquamarine: [127, 255, 212, 1],
        azure: [240, 255, 255, 1],
        beige: [245, 245, 220, 1],
        bisque: [255, 228, 196, 1],
        black: [0, 0, 0, 1],
        blanchedalmond: [255, 235, 205, 1],
        blue: [0, 0, 255, 1],
        blueviolet: [138, 43, 226, 1],
        brown: [165, 42, 42, 1],
        burlywood: [222, 184, 135, 1],
        cadetblue: [95, 158, 160, 1],
        chartreuse: [127, 255, 0, 1],
        chocolate: [210, 105, 30, 1],
        coral: [255, 127, 80, 1],
        cornflowerblue: [100, 149, 237, 1],
        cornsilk: [255, 248, 220, 1],
        crimson: [220, 20, 60, 1],
        cyan: [0, 255, 255, 1],
        darkblue: [0, 0, 139, 1],
        darkcyan: [0, 139, 139, 1],
        darkgoldenrod: [184, 134, 11, 1],
        darkgray: [169, 169, 169, 1],
        darkgreen: [0, 100, 0, 1],
        darkgrey: [169, 169, 169, 1],
        darkkhaki: [189, 183, 107, 1],
        darkmagenta: [139, 0, 139, 1],
        darkolivegreen: [85, 107, 47, 1],
        darkorange: [255, 140, 0, 1],
        darkorchid: [153, 50, 204, 1],
        darkred: [139, 0, 0, 1],
        darksalmon: [233, 150, 122, 1],
        darkseagreen: [143, 188, 143, 1],
        darkslateblue: [72, 61, 139, 1],
        darkslategray: [47, 79, 79, 1],
        darkslategrey: [47, 79, 79, 1],
        darkturquoise: [0, 206, 209, 1],
        darkviolet: [148, 0, 211, 1],
        deeppink: [255, 20, 147, 1],
        deepskyblue: [0, 191, 255, 1],
        dimgray: [105, 105, 105, 1],
        dimgrey: [105, 105, 105, 1],
        dodgerblue: [30, 144, 255, 1],
        firebrick: [178, 34, 34, 1],
        floralwhite: [255, 250, 240, 1],
        forestgreen: [34, 139, 34, 1],
        fuchsia: [255, 0, 255, 1],
        gainsboro: [220, 220, 220, 1],
        ghostwhite: [248, 248, 255, 1],
        gold: [255, 215, 0, 1],
        goldenrod: [218, 165, 32, 1],
        gray: [128, 128, 128, 1],
        green: [0, 128, 0, 1],
        greenyellow: [173, 255, 47, 1],
        grey: [128, 128, 128, 1],
        honeydew: [240, 255, 240, 1],
        hotpink: [255, 105, 180, 1],
        indianred: [205, 92, 92, 1],
        indigo: [75, 0, 130, 1],
        ivory: [255, 255, 240, 1],
        khaki: [240, 230, 140, 1],
        lavender: [230, 230, 250, 1],
        lavenderblush: [255, 240, 245, 1],
        lawngreen: [124, 252, 0, 1],
        lemonchiffon: [255, 250, 205, 1],
        lightblue: [173, 216, 230, 1],
        lightcoral: [240, 128, 128, 1],
        lightcyan: [224, 255, 255, 1],
        lightgoldenrodyellow: [250, 250, 210, 1],
        lightgray: [211, 211, 211, 1],
        lightgreen: [144, 238, 144, 1],
        lightgrey: [211, 211, 211, 1],
        lightpink: [255, 182, 193, 1],
        lightsalmon: [255, 160, 122, 1],
        lightseagreen: [32, 178, 170, 1],
        lightskyblue: [135, 206, 250, 1],
        lightslategray: [119, 136, 153, 1],
        lightslategrey: [119, 136, 153, 1],
        lightsteelblue: [176, 196, 222, 1],
        lightyellow: [255, 255, 224, 1],
        lime: [0, 255, 0, 1],
        limegreen: [50, 205, 50, 1],
        linen: [250, 240, 230, 1],
        magenta: [255, 0, 255, 1],
        maroon: [128, 0, 0, 1],
        mediumaquamarine: [102, 205, 170, 1],
        mediumblue: [0, 0, 205, 1],
        mediumorchid: [186, 85, 211, 1],
        mediumpurple: [147, 112, 219, 1],
        mediumseagreen: [60, 179, 113, 1],
        mediumslateblue: [123, 104, 238, 1],
        mediumspringgreen: [0, 250, 154, 1],
        mediumturquoise: [72, 209, 204, 1],
        mediumvioletred: [199, 21, 133, 1],
        midnightblue: [25, 25, 112, 1],
        mintcream: [245, 255, 250, 1],
        mistyrose: [255, 228, 225, 1],
        moccasin: [255, 228, 181, 1],
        navajowhite: [255, 222, 173, 1],
        navy: [0, 0, 128, 1],
        oldlace: [253, 245, 230, 1],
        olive: [128, 128, 0, 1],
        olivedrab: [107, 142, 35, 1],
        orange: [255, 165, 0, 1],
        orangered: [255, 69, 0, 1],
        orchid: [218, 112, 214, 1],
        palegoldenrod: [238, 232, 170, 1],
        palegreen: [152, 251, 152, 1],
        paleturquoise: [175, 238, 238, 1],
        palevioletred: [219, 112, 147, 1],
        papayawhip: [255, 239, 213, 1],
        peachpuff: [255, 218, 185, 1],
        peru: [205, 133, 63, 1],
        pink: [255, 192, 203, 1],
        plum: [221, 160, 221, 1],
        powderblue: [176, 224, 230, 1],
        purple: [128, 0, 128, 1],
        red: [255, 0, 0, 1],
        rosybrown: [188, 143, 143, 1],
        royalblue: [65, 105, 225, 1],
        saddlebrown: [139, 69, 19, 1],
        salmon: [250, 128, 114, 1],
        sandybrown: [244, 164, 96, 1],
        seagreen: [46, 139, 87, 1],
        seashell: [255, 245, 238, 1],
        sienna: [160, 82, 45, 1],
        silver: [192, 192, 192, 1],
        skyblue: [135, 206, 235, 1],
        slateblue: [106, 90, 205, 1],
        slategray: [112, 128, 144, 1],
        slategrey: [112, 128, 144, 1],
        snow: [255, 250, 250, 1],
        springgreen: [0, 255, 127, 1],
        steelblue: [70, 130, 180, 1],
        tan: [210, 180, 140, 1],
        teal: [0, 128, 128, 1],
        thistle: [216, 191, 216, 1],
        tomato: [255, 99, 71, 1],
        turquoise: [64, 224, 208, 1],
        violet: [238, 130, 238, 1],
        wheat: [245, 222, 179, 1],
        white: [255, 255, 255, 1],
        whitesmoke: [245, 245, 245, 1],
        yellow: [255, 255, 0, 1],
        yellowgreen: [154, 205, 50, 1]
    };
    t.exports = {
        parse: c,
        lift: d,
        toHex: p,
        fastMapToColor: f,
        mapToColor: g,
        modifyHSL: m,
        modifyAlpha: v,
        stringify: y
    }
}, function(t, e, i) {
    var n = i(546);
    t.exports = function() {
        if (0 !== n.debugMode)
            if (1 == n.debugMode)
                for (var t in arguments)
                    throw new Error(arguments[t]);
            else if (n.debugMode > 1)
                for (var t in arguments)
                    console.log(arguments[t])
    }
}, function(t, e) {
    var i = 1;
    "undefined" != typeof window && (i = Math.max(window.devicePixelRatio || 1, 1));
    var n = {
        debugMode: 0,
        devicePixelRatio: i
    };
    t.exports = n
}, function(t, e, i) {
    function n() {
        this.group = new o, this.uid = s.getUID("viewChart")
    }
    function r(t, e) {
        if (t && (t.trigger(e), "group" === t.type))
            for (var i = 0; i < t.childCount(); i++)
                r(t.childAt(i), e)
    }
    function a(t, e, i) {
        var n = c.queryDataIndex(t, e);
        null != n ? u.each(c.normalizeToArray(n), function(e) {
            r(t.getItemGraphicEl(e), i)
        }) : t.eachItemGraphicEl(function(t) {
            r(t, i)
        })
    }
    var o = i(535),
        s = i(525),
        l = i(518),
        c = i(510),
        u = i(509);
    n.prototype = {
        type: "chart",
        init: function(t, e) {},
        render: function(t, e, i, n) {},
        highlight: function(t, e, i, n) {
            a(t.getData(), n, "emphasis")
        },
        downplay: function(t, e, i, n) {
            a(t.getData(), n, "normal")
        },
        remove: function(t, e) {
            this.group.removeAll()
        },
        dispose: function() {}
    };
    var h = n.prototype;
    h.updateView = h.updateLayout = h.updateVisual = function(t, e, i, n) {
        this.render(t, e, i, n)
    }, l.enableClassExtend(n, ["dispose"]), l.enableClassManagement(n, {
        registerWhenExtend: !0
    }), t.exports = n
}, function(t, e, i) {
    "use strict";
    function n(t) {
        return null != t && "none" != t
    }
    function r(t) {
        return "string" == typeof t ? _.lift(t, -.1) : t
    }
    function a(t) {
        if (t.__hoverStlDirty) {
            var e = t.style.stroke,
                i = t.style.fill,
                a = t.__hoverStl;
            a.fill = a.fill || (n(i) ? r(i) : null), a.stroke = a.stroke || (n(e) ? r(e) : null);
            var o = {};
            for (var s in a)
                a.hasOwnProperty(s) && (o[s] = t.style[s]);
            t.__normalStl = o, t.__hoverStlDirty = !1
        }
    }
    function o(t) {
        t.__isHover || (a(t), t.useHoverLayer ? t.__zr && t.__zr.addHover(t, t.__hoverStl) : (t.setStyle(t.__hoverStl), t.z2 += 1), t.__isHover = !0)
    }
    function s(t) {
        if (t.__isHover) {
            var e = t.__normalStl;
            t.useHoverLayer ? t.__zr && t.__zr.removeHover(t) : (e && t.setStyle(e), t.z2 -= 1), t.__isHover = !1
        }
    }
    function l(t) {
        "group" === t.type ? t.traverse(function(t) {
            "group" !== t.type && o(t)
        }) : o(t)
    }
    function c(t) {
        "group" === t.type ? t.traverse(function(t) {
            "group" !== t.type && s(t)
        }) : s(t)
    }
    function u(t, e) {
        t.__hoverStl = t.hoverStyle || e || {}, t.__hoverStlDirty = !0, t.__isHover && a(t)
    }
    function h(t) {
        this.__hoverSilentOnTouch && t.zrByTouch || !this.__isEmphasis && l(this)
    }
    function d(t) {
        this.__hoverSilentOnTouch && t.zrByTouch || !this.__isEmphasis && c(this)
    }
    function p() {
        this.__isEmphasis = !0, l(this)
    }
    function f() {
        this.__isEmphasis = !1, c(this)
    }
    function g(t, e, i, n, r, a) {
        "function" == typeof r && (a = r, r = null);
        var o = n && (n.ifEnableAnimation ? n.ifEnableAnimation() : n.getShallow("animation"));
        if (o) {
            var s = t ? "Update" : "",
                l = n && n.getShallow("animationDuration" + s),
                c = n && n.getShallow("animationEasing" + s),
                u = n && n.getShallow("animationDelay" + s);
            "function" == typeof u && (u = u(r)), l > 0 ? e.animateTo(i, l, u || 0, c, a) : (e.attr(i), a && a())
        } else
            e.attr(i), a && a()
    }
    var m = i(509),
        v = i(549),
        y = Math.round,
        x = i(550),
        _ = i(544),
        b = i(516),
        w = i(515),
        M = {};
    M.Group = i(535), M.Image = i(566), M.Text = i(568), M.Circle = i(569), M.Sector = i(570), M.Ring = i(571), M.Polygon = i(572), M.Polyline = i(576), M.Rect = i(577), M.Line = i(579), M.BezierCurve = i(580), M.Arc = i(581), M.CompoundPath = i(582), M.LinearGradient = i(583), M.RadialGradient = i(585), M.BoundingRect = i(514), M.extendShape = function(t) {
        return x.extend(t)
    }, M.extendPath = function(t, e) {
        return v.extendFromString(t, e)
    }, M.makePath = function(t, e, i, n) {
        var r = v.createFromString(t, e),
            a = r.getBoundingRect();
        if (i) {
            var o = a.width / a.height;
            if ("center" === n) {
                var s,
                    l = i.height * o;
                l <= i.width ? s = i.height : (l = i.width, s = l / o);
                var c = i.x + i.width / 2,
                    u = i.y + i.height / 2;
                i.x = c - l / 2, i.y = u - s / 2, i.width = l, i.height = s
            }
            this.resizePath(r, i)
        }
        return r
    }, M.mergePath = v.mergePath, M.resizePath = function(t, e) {
        if (t.applyTransform) {
            var i = t.getBoundingRect(),
                n = i.calculateTransform(e);
            t.applyTransform(n)
        }
    }, M.subPixelOptimizeLine = function(t) {
        var e = M.subPixelOptimize,
            i = t.shape,
            n = t.style.lineWidth;
        return y(2 * i.x1) === y(2 * i.x2) && (i.x1 = i.x2 = e(i.x1, n, !0)), y(2 * i.y1) === y(2 * i.y2) && (i.y1 = i.y2 = e(i.y1, n, !0)), t
    }, M.subPixelOptimizeRect = function(t) {
        var e = M.subPixelOptimize,
            i = t.shape,
            n = t.style.lineWidth,
            r = i.x,
            a = i.y,
            o = i.width,
            s = i.height;
        return i.x = e(i.x, n, !0), i.y = e(i.y, n, !0), i.width = Math.max(e(r + o, n, !1) - i.x, 0 === o ? 0 : 1), i.height = Math.max(e(a + s, n, !1) - i.y, 0 === s ? 0 : 1), t
    }, M.subPixelOptimize = function(t, e, i) {
        var n = y(2 * t);
        return (n + y(e)) % 2 === 0 ? n / 2 : (n + (i ? 1 : -1)) / 2
    }, M.setHoverStyle = function(t, e, i) {
        t.__hoverSilentOnTouch = i && i.hoverSilentOnTouch, "group" === t.type ? t.traverse(function(t) {
            "group" !== t.type && u(t, e)
        }) : u(t, e), t.on("mouseover", h).on("mouseout", d), t.on("emphasis", p).on("normal", f)
    }, M.setText = function(t, e, i) {
        var n = e.getShallow("position") || "inside",
            r = n.indexOf("inside") >= 0 ? "white" : i,
            a = e.getModel("textStyle");
        m.extend(t, {
            textDistance: e.getShallow("distance") || 5,
            textFont: a.getFont(),
            textPosition: n,
            textFill: a.getTextColor() || r
        })
    }, M.updateProps = function(t, e, i, n, r) {
        g(!0, t, e, i, n, r)
    }, M.initProps = function(t, e, i, n, r) {
        g(!1, t, e, i, n, r)
    }, M.getTransform = function(t, e) {
        for (var i = b.identity([]); t && t !== e;)
            b.mul(i, t.getLocalTransform(), i), t = t.parent;
        return i
    }, M.applyTransform = function(t, e, i) {
        return i && (e = b.invert([], e)), w.applyTransform([], t, e)
    }, M.transformDirection = function(t, e, i) {
        var n = 0 === e[4] || 0 === e[5] || 0 === e[0] ? 1 : Math.abs(2 * e[4] / e[0]),
            r = 0 === e[4] || 0 === e[5] || 0 === e[2] ? 1 : Math.abs(2 * e[4] / e[2]),
            a = ["left" === t ? -n : "right" === t ? n : 0, "top" === t ? -r : "bottom" === t ? r : 0];
        return a = M.applyTransform(a, e, i), Math.abs(a[0]) > Math.abs(a[1]) ? a[0] > 0 ? "right" : "left" : a[1] > 0 ? "bottom" : "top"
    }, M.groupTransition = function(t, e, i, n) {
        function r(t) {
            var e = {};
            return t.traverse(function(t) {
                !t.isGroup && t.anid && (e[t.anid] = t)
            }), e
        }
        function a(t) {
            var e = {
                position: w.clone(t.position),
                rotation: t.rotation
            };
            return t.shape && (e.shape = m.extend({}, t.shape)), e
        }
        if (t && e) {
            var o = r(t);
            e.traverse(function(t) {
                if (!t.isGroup && t.anid) {
                    var e = o[t.anid];
                    if (e) {
                        var n = a(t);
                        t.attr(a(e)), M.updateProps(t, n, i, t.dataIndex)
                    }
                }
            })
        }
    }, t.exports = M
}, function(t, e, i) {
    function n(t, e, i, n, r, a, o, s, l, c, u) {
        var g = l * (f / 180),
            y = p(g) * (t - i) / 2 + d(g) * (e - n) / 2,
            x = -1 * d(g) * (t - i) / 2 + p(g) * (e - n) / 2,
            _ = y * y / (o * o) + x * x / (s * s);
        _ > 1 && (o *= h(_), s *= h(_));
        var b = (r === a ? -1 : 1) * h((o * o * (s * s) - o * o * (x * x) - s * s * (y * y)) / (o * o * (x * x) + s * s * (y * y))) || 0,
            w = b * o * x / s,
            M = b * -s * y / o,
            S = (t + i) / 2 + p(g) * w - d(g) * M,
            A = (e + n) / 2 + d(g) * w + p(g) * M,
            I = v([1, 0], [(y - w) / o, (x - M) / s]),
            D = [(y - w) / o, (x - M) / s],
            k = [(-1 * y - w) / o, (-1 * x - M) / s],
            T = v(D, k);
        m(D, k) <= -1 && (T = f), m(D, k) >= 1 && (T = 0), 0 === a && T > 0 && (T -= 2 * f), 1 === a && T < 0 && (T += 2 * f), u.addData(c, S, A, o, s, I, T, g, a)
    }
    function r(t) {
        if (!t)
            return [];
        var e,
            i = t.replace(/-/g, " -").replace(/  /g, " ").replace(/ /g, ",").replace(/,,/g, ",");
        for (e = 0; e < u.length; e++)
            i = i.replace(new RegExp(u[e], "g"), "|" + u[e]);
        var r,
            a = i.split("|"),
            o = 0,
            l = 0,
            c = new s,
            h = s.CMD;
        for (e = 1; e < a.length; e++) {
            var d,
                p = a[e],
                f = p.charAt(0),
                g = 0,
                m = p.slice(1).replace(/e,-/g, "e-").split(",");
            m.length > 0 && "" === m[0] && m.shift();
            for (var v = 0; v < m.length; v++)
                m[v] = parseFloat(m[v]);
            for (; g < m.length && !isNaN(m[g]) && !isNaN(m[0]);) {
                var y,
                    x,
                    _,
                    b,
                    w,
                    M,
                    S,
                    A = o,
                    I = l;
                switch (f) {
                case "l":
                    o += m[g++], l += m[g++], d = h.L, c.addData(d, o, l);
                    break;
                case "L":
                    o = m[g++], l = m[g++], d = h.L, c.addData(d, o, l);
                    break;
                case "m":
                    o += m[g++], l += m[g++], d = h.M, c.addData(d, o, l), f = "l";
                    break;
                case "M":
                    o = m[g++], l = m[g++], d = h.M, c.addData(d, o, l), f = "L";
                    break;
                case "h":
                    o += m[g++], d = h.L, c.addData(d, o, l);
                    break;
                case "H":
                    o = m[g++], d = h.L, c.addData(d, o, l);
                    break;
                case "v":
                    l += m[g++], d = h.L, c.addData(d, o, l);
                    break;
                case "V":
                    l = m[g++], d = h.L, c.addData(d, o, l);
                    break;
                case "C":
                    d = h.C, c.addData(d, m[g++], m[g++], m[g++], m[g++], m[g++], m[g++]), o = m[g - 2], l = m[g - 1];
                    break;
                case "c":
                    d = h.C, c.addData(d, m[g++] + o, m[g++] + l, m[g++] + o, m[g++] + l, m[g++] + o, m[g++] + l), o += m[g - 2], l += m[g - 1];
                    break;
                case "S":
                    y = o, x = l;
                    var D = c.len(),
                        k = c.data;
                    r === h.C && (y += o - k[D - 4], x += l - k[D - 3]), d = h.C, A = m[g++], I = m[g++], o = m[g++], l = m[g++], c.addData(d, y, x, A, I, o, l);
                    break;
                case "s":
                    y = o, x = l;
                    var D = c.len(),
                        k = c.data;
                    r === h.C && (y += o - k[D - 4], x += l - k[D - 3]), d = h.C, A = o + m[g++], I = l + m[g++], o += m[g++], l += m[g++], c.addData(d, y, x, A, I, o, l);
                    break;
                case "Q":
                    A = m[g++], I = m[g++], o = m[g++], l = m[g++], d = h.Q, c.addData(d, A, I, o, l);
                    break;
                case "q":
                    A = m[g++] + o, I = m[g++] + l, o += m[g++], l += m[g++], d = h.Q, c.addData(d, A, I, o, l);
                    break;
                case "T":
                    y = o, x = l;
                    var D = c.len(),
                        k = c.data;
                    r === h.Q && (y += o - k[D - 4], x += l - k[D - 3]), o = m[g++], l = m[g++], d = h.Q, c.addData(d, y, x, o, l);
                    break;
                case "t":
                    y = o, x = l;
                    var D = c.len(),
                        k = c.data;
                    r === h.Q && (y += o - k[D - 4], x += l - k[D - 3]), o += m[g++], l += m[g++], d = h.Q, c.addData(d, y, x, o, l);
                    break;
                case "A":
                    _ = m[g++], b = m[g++], w = m[g++], M = m[g++], S = m[g++], A = o, I = l, o = m[g++], l = m[g++], d = h.A, n(A, I, o, l, M, S, _, b, w, d, c);
                    break;
                case "a":
                    _ = m[g++], b = m[g++], w = m[g++], M = m[g++], S = m[g++], A = o, I = l, o += m[g++], l += m[g++], d = h.A, n(A, I, o, l, M, S, _, b, w, d, c)
                }
            }
            "z" !== f && "Z" !== f || (d = h.Z, c.addData(d)), r = d
        }
        return c.toStatic(), c
    }
    function a(t, e) {
        var i,
            n = r(t);
        return e = e || {}, e.buildPath = function(t) {
            t.setData(n.data), i && l(t, i);
            var e = t.getContext();
            e && t.rebuildPath(e)
        }, e.applyTransform = function(t) {
            i || (i = c.create()), c.mul(i, t, i), this.dirty(!0)
        }, e
    }
    var o = i(550),
        s = i(554),
        l = i(565),
        c = i(516),
        u = ["m", "M", "l", "L", "v", "V", "h", "H", "z", "Z", "c", "C", "q", "Q", "t", "T", "s", "S", "a", "A"],
        h = Math.sqrt,
        d = Math.sin,
        p = Math.cos,
        f = Math.PI,
        g = function(t) {
            return Math.sqrt(t[0] * t[0] + t[1] * t[1])
        },
        m = function(t, e) {
            return (t[0] * e[0] + t[1] * e[1]) / (g(t) * g(e))
        },
        v = function(t, e) {
            return (t[0] * e[1] < t[1] * e[0] ? -1 : 1) * Math.acos(m(t, e))
        };
    t.exports = {
        createFromString: function(t, e) {
            return new o(a(t, e))
        },
        extendFromString: function(t, e) {
            return o.extend(a(t, e))
        },
        mergePath: function(t, e) {
            for (var i = [], n = t.length, r = 0; r < n; r++) {
                var a = t[r];
                a.__dirty && a.buildPath(a.path, a.shape, !0), i.push(a.path)
            }
            var s = new o(e);
            return s.buildPath = function(t) {
                t.appendPath(i);
                var e = t.getContext();
                e && t.rebuildPath(e)
            }, s
        }
    }
}, function(t, e, i) {
    function n(t) {
        r.call(this, t), this.path = new o
    }
    var r = i(551),
        a = i(509),
        o = i(554),
        s = i(557),
        l = i(564),
        c = l.prototype.getCanvasPattern,
        u = Math.abs;
    n.prototype = {
        constructor: n,
        type: "path",
        __dirtyPath: !0,
        strokeContainThreshold: 5,
        brush: function(t, e) {
            var i = this.style,
                n = this.path,
                r = i.hasStroke(),
                a = i.hasFill(),
                o = i.fill,
                s = i.stroke,
                l = a && !!o.colorStops,
                u = r && !!s.colorStops,
                h = a && !!o.image,
                d = r && !!s.image;
            if (i.bind(t, this, e), this.setTransform(t), this.__dirty) {
                var p = this.getBoundingRect();
                l && (this._fillGradient = i.getGradient(t, o, p)), u && (this._strokeGradient = i.getGradient(t, s, p))
            }
            l ? t.fillStyle = this._fillGradient : h && (t.fillStyle = c.call(o, t)), u ? t.strokeStyle = this._strokeGradient : d && (t.strokeStyle = c.call(s, t));
            var f = i.lineDash,
                g = i.lineDashOffset,
                m = !!t.setLineDash,
                v = this.getGlobalScale();
            n.setScale(v[0], v[1]), this.__dirtyPath || f && !m && r ? (n = this.path.beginPath(t), f && !m && (n.setLineDash(f), n.setLineDashOffset(g)), this.buildPath(n, this.shape, !1), this.__dirtyPath = !1) : (t.beginPath(), this.path.rebuildPath(t)), a && n.fill(t), f && m && (t.setLineDash(f), t.lineDashOffset = g), r && n.stroke(t), f && m && t.setLineDash([]), this.restoreTransform(t), null != i.text && this.drawRectText(t, this.getBoundingRect())
        },
        buildPath: function(t, e, i) {},
        getBoundingRect: function() {
            var t = this._rect,
                e = this.style,
                i = !t;
            if (i) {
                var n = this.path;
                this.__dirtyPath && (n.beginPath(), this.buildPath(n, this.shape, !1)), t = n.getBoundingRect()
            }
            if (this._rect = t, e.hasStroke()) {
                var r = this._rectWithStroke || (this._rectWithStroke = t.clone());
                if (this.__dirty || i) {
                    r.copy(t);
                    var a = e.lineWidth,
                        o = e.strokeNoScale ? this.getLineScale() : 1;
                    e.hasFill() || (a = Math.max(a, this.strokeContainThreshold || 4)), o > 1e-10 && (r.width += a / o, r.height += a / o, r.x -= a / o / 2, r.y -= a / o / 2)
                }
                return r
            }
            return t
        },
        contain: function(t, e) {
            var i = this.transformCoordToLocal(t, e),
                n = this.getBoundingRect(),
                r = this.style;
            if (t = i[0], e = i[1], n.contain(t, e)) {
                var a = this.path.data;
                if (r.hasStroke()) {
                    var o = r.lineWidth,
                        l = r.strokeNoScale ? this.getLineScale() : 1;
                    if (l > 1e-10 && (r.hasFill() || (o = Math.max(o, this.strokeContainThreshold)), s.containStroke(a, o / l, t, e)))
                        return !0
                }
                if (r.hasFill())
                    return s.contain(a, t, e)
            }
            return !1
        },
        dirty: function(t) {
            null == t && (t = !0), t && (this.__dirtyPath = t, this._rect = null), this.__dirty = !0, this.__zr && this.__zr.refresh(), this.__clipTarget && this.__clipTarget.dirty()
        },
        animateShape: function(t) {
            return this.animate("shape", t)
        },
        attrKV: function(t, e) {
            "shape" === t ? (this.setShape(e), this.__dirtyPath = !0, this._rect = null) : r.prototype.attrKV.call(this, t, e)
        },
        setShape: function(t, e) {
            var i = this.shape;
            if (i) {
                if (a.isObject(t))
                    for (var n in t)
                        t.hasOwnProperty(n) && (i[n] = t[n]);
                else
                    i[t] = e;
                this.dirty(!0)
            }
            return this
        },
        getLineScale: function() {
            var t = this.transform;
            return t && u(t[0] - 1) > 1e-10 && u(t[3] - 1) > 1e-10 ? Math.sqrt(u(t[0] * t[3] - t[2] * t[1])) : 1
        }
    }, n.extend = function(t) {
        var e = function(e) {
            n.call(this, e), t.style && this.style.extendFrom(t.style, !1);
            var i = t.shape;
            if (i) {
                this.shape = this.shape || {};
                var r = this.shape;
                for (var a in i)
                    !r.hasOwnProperty(a) && i.hasOwnProperty(a) && (r[a] = i[a])
            }
            t.init && t.init.call(this, e)
        };
        a.inherits(e, n);
        for (var i in t)
            "style" !== i && "shape" !== i && (e.prototype[i] = t[i]);
        return e
    }, a.inherits(n, r), t.exports = n
}, function(t, e, i) {
    function n(t) {
        t = t || {}, o.call(this, t);
        for (var e in t)
            t.hasOwnProperty(e) && "style" !== e && (this[e] = t[e]);
        this.style = new a(t.style), this._rect = null, this.__clipPaths = []
    }
    var r = i(509),
        a = i(552),
        o = i(536),
        s = i(553);
    n.prototype = {
        constructor: n,
        type: "displayable",
        __dirty: !0,
        invisible: !1,
        z: 0,
        z2: 0,
        zlevel: 0,
        draggable: !1,
        dragging: !1,
        silent: !1,
        culling: !1,
        cursor: "pointer",
        rectHover: !1,
        progressive: -1,
        beforeBrush: function(t) {},
        afterBrush: function(t) {},
        brush: function(t, e) {},
        getBoundingRect: function() {},
        contain: function(t, e) {
            return this.rectContain(t, e)
        },
        traverse: function(t, e) {
            t.call(e, this)
        },
        rectContain: function(t, e) {
            var i = this.transformCoordToLocal(t, e),
                n = this.getBoundingRect();
            return n.contain(i[0], i[1])
        },
        dirty: function() {
            this.__dirty = !0, this._rect = null, this.__zr && this.__zr.refresh()
        },
        animateStyle: function(t) {
            return this.animate("style", t)
        },
        attrKV: function(t, e) {
            "style" !== t ? o.prototype.attrKV.call(this, t, e) : this.style.set(e)
        },
        setStyle: function(t, e) {
            return this.style.set(t, e), this.dirty(!1), this
        },
        useStyle: function(t) {
            return this.style = new a(t), this.dirty(!1), this
        }
    }, r.inherits(n, o), r.mixin(n, s), t.exports = n
}, function(t, e) {
    function i(t, e, i) {
        var n = e.x,
            r = e.x2,
            a = e.y,
            o = e.y2;
        e.global || (n = n * i.width + i.x, r = r * i.width + i.x, a = a * i.height + i.y, o = o * i.height + i.y);
        var s = t.createLinearGradient(n, a, r, o);
        return s
    }
    function n(t, e, i) {
        var n = i.width,
            r = i.height,
            a = Math.min(n, r),
            o = e.x,
            s = e.y,
            l = e.r;
        e.global || (o = o * n + i.x, s = s * r + i.y, l *= a);
        var c = t.createRadialGradient(o, s, 0, o, s, l);
        return c
    }
    var r = [["shadowBlur", 0], ["shadowOffsetX", 0], ["shadowOffsetY", 0], ["shadowColor", "#000"], ["lineCap", "butt"], ["lineJoin", "miter"], ["miterLimit", 10]],
        a = function(t) {
            this.extendFrom(t)
        };
    a.prototype = {
        constructor: a,
        fill: "#000000",
        stroke: null,
        opacity: 1,
        lineDash: null,
        lineDashOffset: 0,
        shadowBlur: 0,
        shadowOffsetX: 0,
        shadowOffsetY: 0,
        lineWidth: 1,
        strokeNoScale: !1,
        text: null,
        textFill: "#000",
        textStroke: null,
        textPosition: "inside",
        textBaseline: null,
        textAlign: null,
        textVerticalAlign: null,
        textDistance: 5,
        textShadowBlur: 0,
        textShadowOffsetX: 0,
        textShadowOffsetY: 0,
        textTransform: !1,
        textRotation: 0,
        blend: null,
        bind: function(t, e, i) {
            for (var n = this, a = i && i.style, o = !a, s = 0; s < r.length; s++) {
                var l = r[s],
                    c = l[0];
                (o || n[c] !== a[c]) && (t[c] = n[c] || l[1])
            }
            if ((o || n.fill !== a.fill) && (t.fillStyle = n.fill), (o || n.stroke !== a.stroke) && (t.strokeStyle = n.stroke), (o || n.opacity !== a.opacity) && (t.globalAlpha = null == n.opacity ? 1 : n.opacity), (o || n.blend !== a.blend) && (t.globalCompositeOperation = n.blend || "source-over"), this.hasStroke()) {
                var u = n.lineWidth;
                t.lineWidth = u / (this.strokeNoScale && e && e.getLineScale ? e.getLineScale() : 1)
            }
        },
        hasFill: function() {
            var t = this.fill;
            return null != t && "none" !== t
        },
        hasStroke: function() {
            var t = this.stroke;
            return null != t && "none" !== t && this.lineWidth > 0
        },
        extendFrom: function(t, e) {
            if (t) {
                var i = this;
                for (var n in t)
                    !t.hasOwnProperty(n) || !e && i.hasOwnProperty(n) || (i[n] = t[n])
            }
        },
        set: function(t, e) {
            "string" == typeof t ? this[t] = e : this.extendFrom(t, !0)
        },
        clone: function() {
            var t = new this.constructor;
            return t.extendFrom(this, !0), t
        },
        getGradient: function(t, e, r) {
            for (var a = "radial" === e.type ? n : i, o = a(t, e, r), s = e.colorStops, l = 0; l < s.length; l++)
                o.addColorStop(s[l].offset, s[l].color);
            return o
        }
    };
    for (var o = a.prototype, s = 0; s < r.length; s++) {
        var l = r[s];
        l[0] in o || (o[l[0]] = l[1])
    }
    a.getGradient = o.getGradient, t.exports = a
}, function(t, e, i) {
    function n(t, e) {
        return "string" == typeof t ? t.lastIndexOf("%") >= 0 ? parseFloat(t) / 100 * e : parseFloat(t) : t
    }
    var r = i(513),
        a = i(514),
        o = new a,
        s = function() {};
    s.prototype = {
        constructor: s,
        drawRectText: function(t, e, i) {
            var a = this.style,
                s = a.text;
            if (null != s && (s += ""), s) {
                t.save();
                var l,
                    c,
                    u = a.textPosition,
                    h = a.textDistance,
                    d = a.textAlign,
                    p = a.textFont || a.font,
                    f = a.textBaseline,
                    g = a.textVerticalAlign;
                i = i || r.getBoundingRect(s, p, d, f);
                var m = this.transform;
                if (a.textTransform ? this.setTransform(t) : m && (o.copy(e), o.applyTransform(m), e = o), u instanceof Array) {
                    if (l = e.x + n(u[0], e.width), c = e.y + n(u[1], e.height), d = d || "left", f = f || "top", g) {
                        switch (g) {
                        case "middle":
                            c -= i.height / 2 - i.lineHeight / 2;
                            break;
                        case "bottom":
                            c -= i.height - i.lineHeight / 2;
                            break;
                        default:
                            c += i.lineHeight / 2
                        }
                        f = "middle"
                    }
                } else {
                    var v = r.adjustTextPositionOnRect(u, e, i, h);
                    l = v.x, c = v.y, d = d || v.textAlign, f = f || v.textBaseline
                }
                t.textAlign = d || "left", t.textBaseline = f || "alphabetic";
                var y = a.textFill,
                    x = a.textStroke;
                y && (t.fillStyle = y), x && (t.strokeStyle = x), t.font = p || "12px sans-serif", t.shadowBlur = a.textShadowBlur, t.shadowColor = a.textShadowColor || "transparent", t.shadowOffsetX = a.textShadowOffsetX, t.shadowOffsetY = a.textShadowOffsetY;
                var _ = s.split("\n");
                a.textRotation && (m && t.translate(m[4], m[5]), t.rotate(a.textRotation), m && t.translate(-m[4], -m[5]));
                for (var b = 0; b < _.length; b++)
                    y && t.fillText(_[b], l, c), x && t.strokeText(_[b], l, c), c += i.lineHeight;
                t.restore()
            }
        }
    }, t.exports = s
}, function(t, e, i) {
    "use strict";
    var n = i(555),
        r = i(515),
        a = i(556),
        o = i(514),
        s = i(546).devicePixelRatio,
        l = {
            M: 1,
            L: 2,
            C: 3,
            Q: 4,
            A: 5,
            Z: 6,
            R: 7
        },
        c = [],
        u = [],
        h = [],
        d = [],
        p = Math.min,
        f = Math.max,
        g = Math.cos,
        m = Math.sin,
        v = Math.sqrt,
        y = Math.abs,
        x = "undefined" != typeof Float32Array,
        _ = function() {
            this.data = [], this._len = 0, this._ctx = null, this._xi = 0, this._yi = 0, this._x0 = 0, this._y0 = 0, this._ux = 0, this._uy = 0
        };
    _.prototype = {
        constructor: _,
        _lineDash: null,
        _dashOffset: 0,
        _dashIdx: 0,
        _dashSum: 0,
        setScale: function(t, e) {
            this._ux = y(1 / s / t) || 0, this._uy = y(1 / s / e) || 0
        },
        getContext: function() {
            return this._ctx
        },
        beginPath: function(t) {
            return this._ctx = t, t && t.beginPath(), t && (this.dpr = t.dpr), this._len = 0, this._lineDash && (this._lineDash = null, this._dashOffset = 0), this
        },
        moveTo: function(t, e) {
            return this.addData(l.M, t, e), this._ctx && this._ctx.moveTo(t, e), this._x0 = t, this._y0 = e, this._xi = t, this._yi = e, this
        },
        lineTo: function(t, e) {
            var i = y(t - this._xi) > this._ux || y(e - this._yi) > this._uy || this._len < 5;
            return this.addData(l.L, t, e), this._ctx && i && (this._needsDash() ? this._dashedLineTo(t, e) : this._ctx.lineTo(t, e)), i && (this._xi = t, this._yi = e), this
        },
        bezierCurveTo: function(t, e, i, n, r, a) {
            return this.addData(l.C, t, e, i, n, r, a), this._ctx && (this._needsDash() ? this._dashedBezierTo(t, e, i, n, r, a) : this._ctx.bezierCurveTo(t, e, i, n, r, a)), this._xi = r, this._yi = a, this
        },
        quadraticCurveTo: function(t, e, i, n) {
            return this.addData(l.Q, t, e, i, n), this._ctx && (this._needsDash() ? this._dashedQuadraticTo(t, e, i, n) : this._ctx.quadraticCurveTo(t, e, i, n)), this._xi = i, this._yi = n, this
        },
        arc: function(t, e, i, n, r, a) {
            return this.addData(l.A, t, e, i, i, n, r - n, 0, a ? 0 : 1), this._ctx && this._ctx.arc(t, e, i, n, r, a), this._xi = g(r) * i + t, this._xi = m(r) * i + t, this
        },
        arcTo: function(t, e, i, n, r) {
            return this._ctx && this._ctx.arcTo(t, e, i, n, r), this
        },
        rect: function(t, e, i, n) {
            return this._ctx && this._ctx.rect(t, e, i, n), this.addData(l.R, t, e, i, n), this
        },
        closePath: function() {
            this.addData(l.Z);
            var t = this._ctx,
                e = this._x0,
                i = this._y0;
            return t && (this._needsDash() && this._dashedLineTo(e, i), t.closePath()), this._xi = e, this._yi = i, this
        },
        fill: function(t) {
            t && t.fill(), this.toStatic()
        },
        stroke: function(t) {
            t && t.stroke(), this.toStatic()
        },
        setLineDash: function(t) {
            if (t instanceof Array) {
                this._lineDash = t, this._dashIdx = 0;
                for (var e = 0, i = 0; i < t.length; i++)
                    e += t[i];
                this._dashSum = e
            }
            return this
        },
        setLineDashOffset: function(t) {
            return this._dashOffset = t, this
        },
        len: function() {
            return this._len
        },
        setData: function(t) {
            var e = t.length;
            this.data && this.data.length == e || !x || (this.data = new Float32Array(e));
            for (var i = 0; i < e; i++)
                this.data[i] = t[i];
            this._len = e
        },
        appendPath: function(t) {
            t instanceof Array || (t = [t]);
            for (var e = t.length, i = 0, n = this._len, r = 0; r < e; r++)
                i += t[r].len();
            x && this.data instanceof Float32Array && (this.data = new Float32Array(n + i));
            for (var r = 0; r < e; r++)
                for (var a = t[r].data, o = 0; o < a.length; o++)
                    this.data[n++] = a[o];
            this._len = n
        },
        addData: function(t) {
            var e = this.data;
            this._len + arguments.length > e.length && (this._expandData(), e = this.data);
            for (var i = 0; i < arguments.length; i++)
                e[this._len++] = arguments[i];
            this._prevCmd = t
        },
        _expandData: function() {
            if (!(this.data instanceof Array)) {
                for (var t = [], e = 0; e < this._len; e++)
                    t[e] = this.data[e];
                this.data = t
            }
        },
        _needsDash: function() {
            return this._lineDash
        },
        _dashedLineTo: function(t, e) {
            var i,
                n,
                r = this._dashSum,
                a = this._dashOffset,
                o = this._lineDash,
                s = this._ctx,
                l = this._xi,
                c = this._yi,
                u = t - l,
                h = e - c,
                d = v(u * u + h * h),
                g = l,
                m = c,
                y = o.length;
            for (u /= d, h /= d, a < 0 && (a = r + a), a %= r, g -= a * u, m -= a * h; u > 0 && g <= t || u < 0 && g >= t || 0 == u && (h > 0 && m <= e || h < 0 && m >= e);)
                n = this._dashIdx, i = o[n], g += u * i, m += h * i, this._dashIdx = (n + 1) % y, u > 0 && g < l || u < 0 && g > l || h > 0 && m < c || h < 0 && m > c || s[n % 2 ? "moveTo" : "lineTo"](u >= 0 ? p(g, t) : f(g, t), h >= 0 ? p(m, e) : f(m, e));
            u = g - t, h = m - e, this._dashOffset = -v(u * u + h * h)
        },
        _dashedBezierTo: function(t, e, i, r, a, o) {
            var s,
                l,
                c,
                u,
                h,
                d = this._dashSum,
                p = this._dashOffset,
                f = this._lineDash,
                g = this._ctx,
                m = this._xi,
                y = this._yi,
                x = n.cubicAt,
                _ = 0,
                b = this._dashIdx,
                w = f.length,
                M = 0;
            for (p < 0 && (p = d + p), p %= d, s = 0; s < 1; s += .1)
                l = x(m, t, i, a, s + .1) - x(m, t, i, a, s), c = x(y, e, r, o, s + .1) - x(y, e, r, o, s), _ += v(l * l + c * c);
            for (; b < w && (M += f[b], !(M > p)); b++)
                ;
            for (s = (M - p) / _; s <= 1;)
                u = x(m, t, i, a, s), h = x(y, e, r, o, s), b % 2 ? g.moveTo(u, h) : g.lineTo(u, h), s += f[b] / _, b = (b + 1) % w;
            b % 2 !== 0 && g.lineTo(a, o), l = a - u, c = o - h, this._dashOffset = -v(l * l + c * c)
        },
        _dashedQuadraticTo: function(t, e, i, n) {
            var r = i,
                a = n;
            i = (i + 2 * t) / 3, n = (n + 2 * e) / 3, t = (this._xi + 2 * t) / 3, e = (this._yi + 2 * e) / 3, this._dashedBezierTo(t, e, i, n, r, a)
        },
        toStatic: function() {
            var t = this.data;
            t instanceof Array && (t.length = this._len, x && (this.data = new Float32Array(t)))
        },
        getBoundingRect: function() {
            c[0] = c[1] = h[0] = h[1] = Number.MAX_VALUE, u[0] = u[1] = d[0] = d[1] = -Number.MAX_VALUE;
            for (var t = this.data, e = 0, i = 0, n = 0, s = 0, p = 0; p < t.length;) {
                var f = t[p++];
                switch (1 == p && (e = t[p], i = t[p + 1], n = e, s = i), f) {
                case l.M:
                    n = t[p++], s = t[p++], e = n, i = s, h[0] = n, h[1] = s, d[0] = n,
                    d[1] = s;
                    break;
                case l.L:
                    a.fromLine(e, i, t[p], t[p + 1], h, d), e = t[p++], i = t[p++];
                    break;
                case l.C:
                    a.fromCubic(e, i, t[p++], t[p++], t[p++], t[p++], t[p], t[p + 1], h, d), e = t[p++], i = t[p++];
                    break;
                case l.Q:
                    a.fromQuadratic(e, i, t[p++], t[p++], t[p], t[p + 1], h, d), e = t[p++], i = t[p++];
                    break;
                case l.A:
                    var v = t[p++],
                        y = t[p++],
                        x = t[p++],
                        _ = t[p++],
                        b = t[p++],
                        w = t[p++] + b,
                        M = (t[p++], 1 - t[p++]);
                    1 == p && (n = g(b) * x + v, s = m(b) * _ + y), a.fromArc(v, y, x, _, b, w, M, h, d), e = g(w) * x + v, i = m(w) * _ + y;
                    break;
                case l.R:
                    n = e = t[p++], s = i = t[p++];
                    var S = t[p++],
                        A = t[p++];
                    a.fromLine(n, s, n + S, s + A, h, d);
                    break;
                case l.Z:
                    e = n, i = s
                }
                r.min(c, c, h), r.max(u, u, d)
            }
            return 0 === p && (c[0] = c[1] = u[0] = u[1] = 0), new o(c[0], c[1], u[0] - c[0], u[1] - c[1])
        },
        rebuildPath: function(t) {
            for (var e, i, n, r, a, o, s = this.data, c = this._ux, u = this._uy, h = this._len, d = 0; d < h;) {
                var p = s[d++];
                switch (1 == d && (n = s[d], r = s[d + 1], e = n, i = r), p) {
                case l.M:
                    e = n = s[d++], i = r = s[d++], t.moveTo(n, r);
                    break;
                case l.L:
                    a = s[d++], o = s[d++], (y(a - n) > c || y(o - r) > u || d === h - 1) && (t.lineTo(a, o), n = a, r = o);
                    break;
                case l.C:
                    t.bezierCurveTo(s[d++], s[d++], s[d++], s[d++], s[d++], s[d++]), n = s[d - 2], r = s[d - 1];
                    break;
                case l.Q:
                    t.quadraticCurveTo(s[d++], s[d++], s[d++], s[d++]), n = s[d - 2], r = s[d - 1];
                    break;
                case l.A:
                    var f = s[d++],
                        v = s[d++],
                        x = s[d++],
                        _ = s[d++],
                        b = s[d++],
                        w = s[d++],
                        M = s[d++],
                        S = s[d++],
                        A = x > _ ? x : _,
                        I = x > _ ? 1 : x / _,
                        D = x > _ ? _ / x : 1,
                        k = Math.abs(x - _) > .001,
                        T = b + w;
                    k ? (t.translate(f, v), t.rotate(M), t.scale(I, D), t.arc(0, 0, A, b, T, 1 - S), t.scale(1 / I, 1 / D), t.rotate(-M), t.translate(-f, -v)) : t.arc(f, v, A, b, T, 1 - S), 1 == d && (e = g(b) * x + f, i = m(b) * _ + v), n = g(T) * x + f, r = m(T) * _ + v;
                    break;
                case l.R:
                    e = n = s[d], i = r = s[d + 1], t.rect(s[d++], s[d++], s[d++], s[d++]);
                    break;
                case l.Z:
                    t.closePath(), n = e, r = i
                }
            }
        }
    }, _.CMD = l, t.exports = _
}, function(t, e, i) {
    "use strict";
    function n(t) {
        return t > -w && t < w
    }
    function r(t) {
        return t > w || t < -w
    }
    function a(t, e, i, n, r) {
        var a = 1 - r;
        return a * a * (a * t + 3 * r * e) + r * r * (r * n + 3 * a * i)
    }
    function o(t, e, i, n, r) {
        var a = 1 - r;
        return 3 * (((e - t) * a + 2 * (i - e) * r) * a + (n - i) * r * r)
    }
    function s(t, e, i, r, a, o) {
        var s = r + 3 * (e - i) - t,
            l = 3 * (i - 2 * e + t),
            c = 3 * (e - t),
            u = t - a,
            h = l * l - 3 * s * c,
            d = l * c - 9 * s * u,
            p = c * c - 3 * l * u,
            f = 0;
        if (n(h) && n(d))
            if (n(l))
                o[0] = 0;
            else {
                var g = -c / l;
                g >= 0 && g <= 1 && (o[f++] = g)
            }
        else {
            var m = d * d - 4 * h * p;
            if (n(m)) {
                var v = d / h,
                    g = -l / s + v,
                    y = -v / 2;
                g >= 0 && g <= 1 && (o[f++] = g), y >= 0 && y <= 1 && (o[f++] = y)
            } else if (m > 0) {
                var x = b(m),
                    w = h * l + 1.5 * s * (-d + x),
                    M = h * l + 1.5 * s * (-d - x);
                w = w < 0 ? -_(-w, A) : _(w, A), M = M < 0 ? -_(-M, A) : _(M, A);
                var g = (-l - (w + M)) / (3 * s);
                g >= 0 && g <= 1 && (o[f++] = g)
            } else {
                var I = (2 * h * l - 3 * s * d) / (2 * b(h * h * h)),
                    D = Math.acos(I) / 3,
                    k = b(h),
                    T = Math.cos(D),
                    g = (-l - 2 * k * T) / (3 * s),
                    y = (-l + k * (T + S * Math.sin(D))) / (3 * s),
                    C = (-l + k * (T - S * Math.sin(D))) / (3 * s);
                g >= 0 && g <= 1 && (o[f++] = g), y >= 0 && y <= 1 && (o[f++] = y), C >= 0 && C <= 1 && (o[f++] = C)
            }
        }
        return f
    }
    function l(t, e, i, a, o) {
        var s = 6 * i - 12 * e + 6 * t,
            l = 9 * e + 3 * a - 3 * t - 9 * i,
            c = 3 * e - 3 * t,
            u = 0;
        if (n(l)) {
            if (r(s)) {
                var h = -c / s;
                h >= 0 && h <= 1 && (o[u++] = h)
            }
        } else {
            var d = s * s - 4 * l * c;
            if (n(d))
                o[0] = -s / (2 * l);
            else if (d > 0) {
                var p = b(d),
                    h = (-s + p) / (2 * l),
                    f = (-s - p) / (2 * l);
                h >= 0 && h <= 1 && (o[u++] = h), f >= 0 && f <= 1 && (o[u++] = f)
            }
        }
        return u
    }
    function c(t, e, i, n, r, a) {
        var o = (e - t) * r + t,
            s = (i - e) * r + e,
            l = (n - i) * r + i,
            c = (s - o) * r + o,
            u = (l - s) * r + s,
            h = (u - c) * r + c;
        a[0] = t, a[1] = o, a[2] = c, a[3] = h, a[4] = h, a[5] = u, a[6] = l, a[7] = n
    }
    function u(t, e, i, n, r, o, s, l, c, u, h) {
        var d,
            p,
            f,
            g,
            m,
            v = .005,
            y = 1 / 0;
        I[0] = c, I[1] = u;
        for (var _ = 0; _ < 1; _ += .05)
            D[0] = a(t, i, r, s, _), D[1] = a(e, n, o, l, _), g = x(I, D), g < y && (d = _, y = g);
        y = 1 / 0;
        for (var w = 0; w < 32 && !(v < M); w++)
            p = d - v, f = d + v, D[0] = a(t, i, r, s, p), D[1] = a(e, n, o, l, p), g = x(D, I), p >= 0 && g < y ? (d = p, y = g) : (k[0] = a(t, i, r, s, f), k[1] = a(e, n, o, l, f), m = x(k, I), f <= 1 && m < y ? (d = f, y = m) : v *= .5);
        return h && (h[0] = a(t, i, r, s, d), h[1] = a(e, n, o, l, d)), b(y)
    }
    function h(t, e, i, n) {
        var r = 1 - n;
        return r * (r * t + 2 * n * e) + n * n * i
    }
    function d(t, e, i, n) {
        return 2 * ((1 - n) * (e - t) + n * (i - e))
    }
    function p(t, e, i, a, o) {
        var s = t - 2 * e + i,
            l = 2 * (e - t),
            c = t - a,
            u = 0;
        if (n(s)) {
            if (r(l)) {
                var h = -c / l;
                h >= 0 && h <= 1 && (o[u++] = h)
            }
        } else {
            var d = l * l - 4 * s * c;
            if (n(d)) {
                var h = -l / (2 * s);
                h >= 0 && h <= 1 && (o[u++] = h)
            } else if (d > 0) {
                var p = b(d),
                    h = (-l + p) / (2 * s),
                    f = (-l - p) / (2 * s);
                h >= 0 && h <= 1 && (o[u++] = h), f >= 0 && f <= 1 && (o[u++] = f)
            }
        }
        return u
    }
    function f(t, e, i) {
        var n = t + i - 2 * e;
        return 0 === n ? .5 : (t - e) / n
    }
    function g(t, e, i, n, r) {
        var a = (e - t) * n + t,
            o = (i - e) * n + e,
            s = (o - a) * n + a;
        r[0] = t, r[1] = a, r[2] = s, r[3] = s, r[4] = o, r[5] = i
    }
    function m(t, e, i, n, r, a, o, s, l) {
        var c,
            u = .005,
            d = 1 / 0;
        I[0] = o, I[1] = s;
        for (var p = 0; p < 1; p += .05) {
            D[0] = h(t, i, r, p), D[1] = h(e, n, a, p);
            var f = x(I, D);
            f < d && (c = p, d = f)
        }
        d = 1 / 0;
        for (var g = 0; g < 32 && !(u < M); g++) {
            var m = c - u,
                v = c + u;
            D[0] = h(t, i, r, m), D[1] = h(e, n, a, m);
            var f = x(D, I);
            if (m >= 0 && f < d)
                c = m, d = f;
            else {
                k[0] = h(t, i, r, v), k[1] = h(e, n, a, v);
                var y = x(k, I);
                v <= 1 && y < d ? (c = v, d = y) : u *= .5
            }
        }
        return l && (l[0] = h(t, i, r, c), l[1] = h(e, n, a, c)), b(d)
    }
    var v = i(515),
        y = v.create,
        x = v.distSquare,
        _ = Math.pow,
        b = Math.sqrt,
        w = 1e-8,
        M = 1e-4,
        S = b(3),
        A = 1 / 3,
        I = y(),
        D = y(),
        k = y();
    t.exports = {
        cubicAt: a,
        cubicDerivativeAt: o,
        cubicRootAt: s,
        cubicExtrema: l,
        cubicSubdivide: c,
        cubicProjectPoint: u,
        quadraticAt: h,
        quadraticDerivativeAt: d,
        quadraticRootAt: p,
        quadraticExtremum: f,
        quadraticSubdivide: g,
        quadraticProjectPoint: m
    }
}, function(t, e, i) {
    var n = i(515),
        r = i(555),
        a = {},
        o = Math.min,
        s = Math.max,
        l = Math.sin,
        c = Math.cos,
        u = n.create(),
        h = n.create(),
        d = n.create(),
        p = 2 * Math.PI;
    a.fromPoints = function(t, e, i) {
        if (0 !== t.length) {
            var n,
                r = t[0],
                a = r[0],
                l = r[0],
                c = r[1],
                u = r[1];
            for (n = 1; n < t.length; n++)
                r = t[n], a = o(a, r[0]), l = s(l, r[0]), c = o(c, r[1]), u = s(u, r[1]);
            e[0] = a, e[1] = c, i[0] = l, i[1] = u
        }
    }, a.fromLine = function(t, e, i, n, r, a) {
        r[0] = o(t, i), r[1] = o(e, n), a[0] = s(t, i), a[1] = s(e, n)
    };
    var f = [],
        g = [];
    a.fromCubic = function(t, e, i, n, a, l, c, u, h, d) {
        var p,
            m = r.cubicExtrema,
            v = r.cubicAt,
            y = m(t, i, a, c, f);
        for (h[0] = 1 / 0, h[1] = 1 / 0, d[0] = -(1 / 0), d[1] = -(1 / 0), p = 0; p < y; p++) {
            var x = v(t, i, a, c, f[p]);
            h[0] = o(x, h[0]), d[0] = s(x, d[0])
        }
        for (y = m(e, n, l, u, g), p = 0; p < y; p++) {
            var _ = v(e, n, l, u, g[p]);
            h[1] = o(_, h[1]), d[1] = s(_, d[1])
        }
        h[0] = o(t, h[0]), d[0] = s(t, d[0]), h[0] = o(c, h[0]), d[0] = s(c, d[0]), h[1] = o(e, h[1]), d[1] = s(e, d[1]), h[1] = o(u, h[1]), d[1] = s(u, d[1])
    }, a.fromQuadratic = function(t, e, i, n, a, l, c, u) {
        var h = r.quadraticExtremum,
            d = r.quadraticAt,
            p = s(o(h(t, i, a), 1), 0),
            f = s(o(h(e, n, l), 1), 0),
            g = d(t, i, a, p),
            m = d(e, n, l, f);
        c[0] = o(t, a, g), c[1] = o(e, l, m), u[0] = s(t, a, g), u[1] = s(e, l, m)
    }, a.fromArc = function(t, e, i, r, a, o, s, f, g) {
        var m = n.min,
            v = n.max,
            y = Math.abs(a - o);
        if (y % p < 1e-4 && y > 1e-4)
            return f[0] = t - i, f[1] = e - r, g[0] = t + i, void (g[1] = e + r);
        if (u[0] = c(a) * i + t, u[1] = l(a) * r + e, h[0] = c(o) * i + t, h[1] = l(o) * r + e, m(f, u, h), v(g, u, h), a %= p, a < 0 && (a += p), o %= p, o < 0 && (o += p), a > o && !s ? o += p : a < o && s && (a += p), s) {
            var x = o;
            o = a, a = x
        }
        for (var _ = 0; _ < o; _ += Math.PI / 2)
            _ > a && (d[0] = c(_) * i + t, d[1] = l(_) * r + e, m(f, d, f), v(g, d, g))
    }, t.exports = a
}, function(t, e, i) {
    "use strict";
    function n(t, e) {
        return Math.abs(t - e) < x
    }
    function r() {
        var t = b[0];
        b[0] = b[1], b[1] = t
    }
    function a(t, e, i, n, a, o, s, l, c, u) {
        if (u > e && u > n && u > o && u > l || u < e && u < n && u < o && u < l)
            return 0;
        var h = g.cubicRootAt(e, n, o, l, u, _);
        if (0 === h)
            return 0;
        for (var d, p, f = 0, m = -1, v = 0; v < h; v++) {
            var y = _[v],
                x = 0 === y || 1 === y ? .5 : 1,
                w = g.cubicAt(t, i, a, s, y);
            w < c || (m < 0 && (m = g.cubicExtrema(e, n, o, l, b), b[1] < b[0] && m > 1 && r(), d = g.cubicAt(e, n, o, l, b[0]), m > 1 && (p = g.cubicAt(e, n, o, l, b[1]))), f += 2 == m ? y < b[0] ? d < e ? x : -x : y < b[1] ? p < d ? x : -x : l < p ? x : -x : y < b[0] ? d < e ? x : -x : l < d ? x : -x)
        }
        return f
    }
    function o(t, e, i, n, r, a, o, s) {
        if (s > e && s > n && s > a || s < e && s < n && s < a)
            return 0;
        var l = g.quadraticRootAt(e, n, a, s, _);
        if (0 === l)
            return 0;
        var c = g.quadraticExtremum(e, n, a);
        if (c >= 0 && c <= 1) {
            for (var u = 0, h = g.quadraticAt(e, n, a, c), d = 0; d < l; d++) {
                var p = 0 === _[d] || 1 === _[d] ? .5 : 1,
                    f = g.quadraticAt(t, i, r, _[d]);
                f < o || (u += _[d] < c ? h < e ? p : -p : a < h ? p : -p)
            }
            return u
        }
        var p = 0 === _[0] || 1 === _[0] ? .5 : 1,
            f = g.quadraticAt(t, i, r, _[0]);
        return f < o ? 0 : a < e ? p : -p
    }
    function s(t, e, i, n, r, a, o, s) {
        if (s -= e, s > i || s < -i)
            return 0;
        var l = Math.sqrt(i * i - s * s);
        _[0] = -l, _[1] = l;
        var c = Math.abs(n - r);
        if (c < 1e-4)
            return 0;
        if (c % y < 1e-4) {
            n = 0, r = y;
            var u = a ? 1 : -1;
            return o >= _[0] + t && o <= _[1] + t ? u : 0
        }
        if (a) {
            var l = n;
            n = f(r), r = f(l)
        } else
            n = f(n), r = f(r);
        n > r && (r += y);
        for (var h = 0, d = 0; d < 2; d++) {
            var p = _[d];
            if (p + t > o) {
                var g = Math.atan2(s, p),
                    u = a ? 1 : -1;
                g < 0 && (g = y + g), (g >= n && g <= r || g + y >= n && g + y <= r) && (g > Math.PI / 2 && g < 1.5 * Math.PI && (u = -u), h += u)
            }
        }
        return h
    }
    function l(t, e, i, r, l) {
        for (var u = 0, f = 0, g = 0, y = 0, x = 0, _ = 0; _ < t.length;) {
            var b = t[_++];
            switch (b === c.M && _ > 1 && (i || (u += m(f, g, y, x, r, l))), 1 == _ && (f = t[_], g = t[_ + 1], y = f, x = g), b) {
            case c.M:
                y = t[_++], x = t[_++], f = y, g = x;
                break;
            case c.L:
                if (i) {
                    if (v(f, g, t[_], t[_ + 1], e, r, l))
                        return !0
                } else
                    u += m(f, g, t[_], t[_ + 1], r, l) || 0;
                f = t[_++], g = t[_++];
                break;
            case c.C:
                if (i) {
                    if (h.containStroke(f, g, t[_++], t[_++], t[_++], t[_++], t[_], t[_ + 1], e, r, l))
                        return !0
                } else
                    u += a(f, g, t[_++], t[_++], t[_++], t[_++], t[_], t[_ + 1], r, l) || 0;
                f = t[_++], g = t[_++];
                break;
            case c.Q:
                if (i) {
                    if (d.containStroke(f, g, t[_++], t[_++], t[_], t[_ + 1], e, r, l))
                        return !0
                } else
                    u += o(f, g, t[_++], t[_++], t[_], t[_ + 1], r, l) || 0;
                f = t[_++], g = t[_++];
                break;
            case c.A:
                var w = t[_++],
                    M = t[_++],
                    S = t[_++],
                    A = t[_++],
                    I = t[_++],
                    D = t[_++],
                    k = (t[_++], 1 - t[_++]),
                    T = Math.cos(I) * S + w,
                    C = Math.sin(I) * A + M;
                _ > 1 ? u += m(f, g, T, C, r, l) : (y = T, x = C);
                var L = (r - w) * A / S + w;
                if (i) {
                    if (p.containStroke(w, M, A, I, I + D, k, e, L, l))
                        return !0
                } else
                    u += s(w, M, A, I, I + D, k, L, l);
                f = Math.cos(I + D) * S + w, g = Math.sin(I + D) * A + M;
                break;
            case c.R:
                y = f = t[_++], x = g = t[_++];
                var P = t[_++],
                    E = t[_++],
                    T = y + P,
                    C = x + E;
                if (i) {
                    if (v(y, x, T, x, e, r, l) || v(T, x, T, C, e, r, l) || v(T, C, y, C, e, r, l) || v(y, C, y, x, e, r, l))
                        return !0
                } else
                    u += m(T, x, T, C, r, l), u += m(y, C, y, x, r, l);
                break;
            case c.Z:
                if (i) {
                    if (v(f, g, y, x, e, r, l))
                        return !0
                } else
                    u += m(f, g, y, x, r, l);
                f = y, g = x
            }
        }
        return i || n(g, x) || (u += m(f, g, y, x, r, l) || 0), 0 !== u
    }
    var c = i(554).CMD,
        u = i(558),
        h = i(559),
        d = i(560),
        p = i(561),
        f = i(562).normalizeRadian,
        g = i(555),
        m = i(563),
        v = u.containStroke,
        y = 2 * Math.PI,
        x = 1e-4,
        _ = [-1, -1, -1],
        b = [-1, -1];
    t.exports = {
        contain: function(t, e, i) {
            return l(t, 0, !1, e, i)
        },
        containStroke: function(t, e, i, n) {
            return l(t, e, !0, i, n)
        }
    }
}, function(t, e) {
    t.exports = {
        containStroke: function(t, e, i, n, r, a, o) {
            if (0 === r)
                return !1;
            var s = r,
                l = 0,
                c = t;
            if (o > e + s && o > n + s || o < e - s && o < n - s || a > t + s && a > i + s || a < t - s && a < i - s)
                return !1;
            if (t === i)
                return Math.abs(a - t) <= s / 2;
            l = (e - n) / (t - i), c = (t * n - i * e) / (t - i);
            var u = l * a - o + c,
                h = u * u / (l * l + 1);
            return h <= s / 2 * s / 2
        }
    }
}, function(t, e, i) {
    var n = i(555);
    t.exports = {
        containStroke: function(t, e, i, r, a, o, s, l, c, u, h) {
            if (0 === c)
                return !1;
            var d = c;
            if (h > e + d && h > r + d && h > o + d && h > l + d || h < e - d && h < r - d && h < o - d && h < l - d || u > t + d && u > i + d && u > a + d && u > s + d || u < t - d && u < i - d && u < a - d && u < s - d)
                return !1;
            var p = n.cubicProjectPoint(t, e, i, r, a, o, s, l, u, h, null);
            return p <= d / 2
        }
    }
}, function(t, e, i) {
    var n = i(555);
    t.exports = {
        containStroke: function(t, e, i, r, a, o, s, l, c) {
            if (0 === s)
                return !1;
            var u = s;
            if (c > e + u && c > r + u && c > o + u || c < e - u && c < r - u && c < o - u || l > t + u && l > i + u && l > a + u || l < t - u && l < i - u && l < a - u)
                return !1;
            var h = n.quadraticProjectPoint(t, e, i, r, a, o, l, c, null);
            return h <= u / 2
        }
    }
}, function(t, e, i) {
    var n = i(562).normalizeRadian,
        r = 2 * Math.PI;
    t.exports = {
        containStroke: function(t, e, i, a, o, s, l, c, u) {
            if (0 === l)
                return !1;
            var h = l;
            c -= t, u -= e;
            var d = Math.sqrt(c * c + u * u);
            if (d - h > i || d + h < i)
                return !1;
            if (Math.abs(a - o) % r < 1e-4)
                return !0;
            if (s) {
                var p = a;
                a = n(o), o = n(p)
            } else
                a = n(a), o = n(o);
            a > o && (o += r);
            var f = Math.atan2(u, c);
            return f < 0 && (f += r), f >= a && f <= o || f + r >= a && f + r <= o
        }
    }
}, function(t, e) {
    var i = 2 * Math.PI;
    t.exports = {
        normalizeRadian: function(t) {
            return t %= i, t < 0 && (t += i), t
        }
    }
}, function(t, e) {
    t.exports = function(t, e, i, n, r, a) {
        if (a > e && a > n || a < e && a < n)
            return 0;
        if (n === e)
            return 0;
        var o = n < e ? 1 : -1,
            s = (a - e) / (n - e);
        1 !== s && 0 !== s || (o = n < e ? .5 : -.5);
        var l = s * (i - t) + t;
        return l > r ? o : 0
    }
}, function(t, e) {
    var i = function(t, e) {
        this.image = t, this.repeat = e, this.type = "pattern"
    };
    i.prototype.getCanvasPattern = function(t) {
        return this._canvasPattern || (this._canvasPattern = t.createPattern(this.image, this.repeat))
    }, t.exports = i
}, function(t, e, i) {
    function n(t, e) {
        var i,
            n,
            a,
            u,
            h,
            d,
            p = t.data,
            f = r.M,
            g = r.C,
            m = r.L,
            v = r.R,
            y = r.A,
            x = r.Q;
        for (a = 0, u = 0; a < p.length;) {
            switch (i = p[a++], u = a, n = 0, i) {
            case f:
                n = 1;
                break;
            case m:
                n = 1;
                break;
            case g:
                n = 3;
                break;
            case x:
                n = 2;
                break;
            case y:
                var _ = e[4],
                    b = e[5],
                    w = l(e[0] * e[0] + e[1] * e[1]),
                    M = l(e[2] * e[2] + e[3] * e[3]),
                    S = c(-e[1] / M, e[0] / w);
                p[a++] += _, p[a++] += b, p[a++] *= w, p[a++] *= M, p[a++] += S, p[a++] += S, a += 2, u = a;
                break;
            case v:
                d[0] = p[a++], d[1] = p[a++], o(d, d, e), p[u++] = d[0], p[u++] = d[1], d[0] += p[a++], d[1] += p[a++], o(d, d, e), p[u++] = d[0], p[u++] = d[1]
            }
            for (h = 0; h < n; h++) {
                var d = s[h];
                d[0] = p[a++], d[1] = p[a++], o(d, d, e), p[u++] = d[0], p[u++] = d[1]
            }
        }
    }
    var r = i(554).CMD,
        a = i(515),
        o = a.applyTransform,
        s = [[], [], []],
        l = Math.sqrt,
        c = Math.atan2;
    t.exports = n
}, function(t, e, i) {
    function n(t) {
        r.call(this, t)
    }
    var r = i(551),
        a = i(514),
        o = i(509),
        s = i(567),
        l = new s(50);
    n.prototype = {
        constructor: n,
        type: "image",
        brush: function(t, e) {
            var i,
                n = this.style,
                r = n.image;
            if (n.bind(t, this, e), i = "string" == typeof r ? this._image : r, !i && r) {
                var a = l.get(r);
                if (!a)
                    return i = new Image, i.onload = function() {
                        i.onload = null;
                        for (var t = 0; t < a.pending.length; t++)
                            a.pending[t].dirty()
                    }, a = {
                        image: i,
                        pending: [this]
                    }, i.src = r, l.put(r, a), void (this._image = i);
                if (i = a.image, this._image = i, !i.width || !i.height)
                    return void a.pending.push(this)
            }
            if (i) {
                var o = n.width || i.width,
                    s = n.height || i.height,
                    c = n.x || 0,
                    u = n.y || 0;
                if (!i.width || !i.height)
                    return;
                if (this.setTransform(t), n.sWidth && n.sHeight) {
                    var h = n.sx || 0,
                        d = n.sy || 0;
                    t.drawImage(i, h, d, n.sWidth, n.sHeight, c, u, o, s)
                } else if (n.sx && n.sy) {
                    var h = n.sx,
                        d = n.sy,
                        p = o - h,
                        f = s - d;
                    t.drawImage(i, h, d, p, f, c, u, o, s)
                } else
                    t.drawImage(i, c, u, o, s);
                null == n.width && (n.width = o), null == n.height && (n.height = s), this.restoreTransform(t), null != n.text && this.drawRectText(t, this.getBoundingRect())
            }
        },
        getBoundingRect: function() {
            var t = this.style;
            return this._rect || (this._rect = new a(t.x || 0, t.y || 0, t.width || 0, t.height || 0)), this._rect
        }
    }, o.inherits(n, r), t.exports = n
}, function(t, e) {
    var i = function() {
            this.head = null, this.tail = null, this._len = 0
        },
        n = i.prototype;
    n.insert = function(t) {
        var e = new r(t);
        return this.insertEntry(e), e
    }, n.insertEntry = function(t) {
        this.head ? (this.tail.next = t, t.prev = this.tail, this.tail = t) : this.head = this.tail = t, this._len++
    }, n.remove = function(t) {
        var e = t.prev,
            i = t.next;
        e ? e.next = i : this.head = i, i ? i.prev = e : this.tail = e, t.next = t.prev = null, this._len--
    }, n.len = function() {
        return this._len
    };
    var r = function(t) {
            this.value = t, this.next, this.prev
        },
        a = function(t) {
            this._list = new i, this._map = {}, this._maxSize = t || 10
        },
        o = a.prototype;
    o.put = function(t, e) {
        var i = this._list,
            n = this._map;
        if (null == n[t]) {
            var r = i.len();
            if (r >= this._maxSize && r > 0) {
                var a = i.head;
                i.remove(a), delete n[a.key]
            }
            var o = i.insert(e);
            o.key = t, n[t] = o
        }
    }, o.get = function(t) {
        var e = this._map[t],
            i = this._list;
        if (null != e)
            return e !== i.tail && (i.remove(e), i.insertEntry(e)), e.value
    }, o.clear = function() {
        this._list.clear(), this._map = {}
    }, t.exports = a
}, function(t, e, i) {
    var n = i(551),
        r = i(509),
        a = i(513),
        o = function(t) {
            n.call(this, t)
        };
    o.prototype = {
        constructor: o,
        type: "text",
        brush: function(t, e) {
            var i = this.style,
                n = i.x || 0,
                r = i.y || 0,
                o = i.text;
            if (null != o && (o += ""), i.bind(t, this, e), o) {
                this.setTransform(t);
                var s,
                    l = i.textAlign,
                    c = i.textFont || i.font;
                if (i.textVerticalAlign) {
                    var u = a.getBoundingRect(o, c, i.textAlign, "top");
                    switch (s = "middle", i.textVerticalAlign) {
                    case "middle":
                        r -= u.height / 2 - u.lineHeight / 2;
                        break;
                    case "bottom":
                        r -= u.height - u.lineHeight / 2;
                        break;
                    default:
                        r += u.lineHeight / 2
                    }
                } else
                    s = i.textBaseline;
                t.font = c || "12px sans-serif", t.textAlign = l || "left", t.textAlign !== l && (t.textAlign = "left"), t.textBaseline = s || "alphabetic", t.textBaseline !== s && (t.textBaseline = "alphabetic");
                for (var h = a.measureText("国", t.font).width, d = o.split("\n"), p = 0; p < d.length; p++)
                    i.hasFill() && t.fillText(d[p], n, r), i.hasStroke() && t.strokeText(d[p], n, r), r += h;
                this.restoreTransform(t)
            }
        },
        getBoundingRect: function() {
            if (!this._rect) {
                var t = this.style,
                    e = t.textVerticalAlign,
                    i = a.getBoundingRect(t.text + "", t.textFont || t.font, t.textAlign, e ? "top" : t.textBaseline);
                switch (e) {
                case "middle":
                    i.y -= i.height / 2;
                    break;
                case "bottom":
                    i.y -= i.height
                }
                i.x += t.x || 0, i.y += t.y || 0, this._rect = i
            }
            return this._rect
        }
    }, r.inherits(o, n), t.exports = o
}, function(t, e, i) {
    "use strict";
    t.exports = i(550).extend({
        type: "circle",
        shape: {
            cx: 0,
            cy: 0,
            r: 0
        },
        buildPath: function(t, e, i) {
            i && t.moveTo(e.cx + e.r, e.cy), t.arc(e.cx, e.cy, e.r, 0, 2 * Math.PI, !0)
        }
    })
}, function(t, e, i) {
    t.exports = i(550).extend({
        type: "sector",
        shape: {
            cx: 0,
            cy: 0,
            r0: 0,
            r: 0,
            startAngle: 0,
            endAngle: 2 * Math.PI,
            clockwise: !0
        },
        buildPath: function(t, e) {
            var i = e.cx,
                n = e.cy,
                r = Math.max(e.r0 || 0, 0),
                a = Math.max(e.r, 0),
                o = e.startAngle,
                s = e.endAngle,
                l = e.clockwise,
                c = Math.cos(o),
                u = Math.sin(o);
            t.moveTo(c * r + i, u * r + n), t.lineTo(c * a + i, u * a + n), t.arc(i, n, a, o, s, !l), t.lineTo(Math.cos(s) * r + i, Math.sin(s) * r + n), 0 !== r && t.arc(i, n, r, s, o, l), t.closePath()
        }
    })
}, function(t, e, i) {
    t.exports = i(550).extend({
        type: "ring",
        shape: {
            cx: 0,
            cy: 0,
            r: 0,
            r0: 0
        },
        buildPath: function(t, e) {
            var i = e.cx,
                n = e.cy,
                r = 2 * Math.PI;
            t.moveTo(i + e.r, n), t.arc(i, n, e.r, 0, r, !1), t.moveTo(i + e.r0, n), t.arc(i, n, e.r0, 0, r, !0)
        }
    })
}, function(t, e, i) {
    var n = i(573);
    t.exports = i(550).extend({
        type: "polygon",
        shape: {
            points: null,
            smooth: !1,
            smoothConstraint: null
        },
        buildPath: function(t, e) {
            n.buildPath(t, e, !0)
        }
    })
}, function(t, e, i) {
    var n = i(574),
        r = i(575);
    t.exports = {
        buildPath: function(t, e, i) {
            var a = e.points,
                o = e.smooth;
            if (a && a.length >= 2) {
                if (o && "spline" !== o) {
                    var s = r(a, o, i, e.smoothConstraint);
                    t.moveTo(a[0][0], a[0][1]);
                    for (var l = a.length, c = 0; c < (i ? l : l - 1); c++) {
                        var u = s[2 * c],
                            h = s[2 * c + 1],
                            d = a[(c + 1) % l];
                        t.bezierCurveTo(u[0], u[1], h[0], h[1], d[0], d[1])
                    }
                } else {
                    "spline" === o && (a = n(a, i)), t.moveTo(a[0][0], a[0][1]);
                    for (var c = 1, p = a.length; c < p; c++)
                        t.lineTo(a[c][0], a[c][1])
                }
                i && t.closePath()
            }
        }
    }
}, function(t, e, i) {
    function n(t, e, i, n, r, a, o) {
        var s = .5 * (i - t),
            l = .5 * (n - e);
        return (2 * (e - i) + s + l) * o + (-3 * (e - i) - 2 * s - l) * a + s * r + e
    }
    var r = i(515);
    t.exports = function(t, e) {
        for (var i = t.length, a = [], o = 0, s = 1; s < i; s++)
            o += r.distance(t[s - 1], t[s]);
        var l = o / 2;
        l = l < i ? i : l;
        for (var s = 0; s < l; s++) {
            var c,
                u,
                h,
                d = s / (l - 1) * (e ? i : i - 1),
                p = Math.floor(d),
                f = d - p,
                g = t[p % i];
            e ? (c = t[(p - 1 + i) % i], u = t[(p + 1) % i], h = t[(p + 2) % i]) : (c = t[0 === p ? p : p - 1], u = t[p > i - 2 ? i - 1 : p + 1], h = t[p > i - 3 ? i - 1 : p + 2]);
            var m = f * f,
                v = f * m;
            a.push([n(c[0], g[0], u[0], h[0], f, m, v), n(c[1], g[1], u[1], h[1], f, m, v)])
        }
        return a
    }
}, function(t, e, i) {
    var n = i(515),
        r = n.min,
        a = n.max,
        o = n.scale,
        s = n.distance,
        l = n.add;
    t.exports = function(t, e, i, c) {
        var u,
            h,
            d,
            p,
            f = [],
            g = [],
            m = [],
            v = [];
        if (c) {
            d = [1 / 0, 1 / 0], p = [-(1 / 0), -(1 / 0)];
            for (var y = 0, x = t.length; y < x; y++)
                r(d, d, t[y]), a(p, p, t[y]);
            r(d, d, c[0]), a(p, p, c[1])
        }
        for (var y = 0, x = t.length; y < x; y++) {
            var _ = t[y];
            if (i)
                u = t[y ? y - 1 : x - 1], h = t[(y + 1) % x];
            else {
                if (0 === y || y === x - 1) {
                    f.push(n.clone(t[y]));
                    continue
                }
                u = t[y - 1], h = t[y + 1]
            }
            n.sub(g, h, u), o(g, g, e);
            var b = s(_, u),
                w = s(_, h),
                M = b + w;
            0 !== M && (b /= M, w /= M), o(m, g, -b), o(v, g, w);
            var S = l([], _, m),
                A = l([], _, v);
            c && (a(S, S, d), r(S, S, p), a(A, A, d), r(A, A, p)), f.push(S), f.push(A)
        }
        return i && f.push(f.shift()), f
    }
}, function(t, e, i) {
    var n = i(573);
    t.exports = i(550).extend({
        type: "polyline",
        shape: {
            points: null,
            smooth: !1,
            smoothConstraint: null
        },
        style: {
            stroke: "#000",
            fill: null
        },
        buildPath: function(t, e) {
            n.buildPath(t, e, !1)
        }
    })
}, function(t, e, i) {
    var n = i(578);
    t.exports = i(550).extend({
        type: "rect",
        shape: {
            r: 0,
            x: 0,
            y: 0,
            width: 0,
            height: 0
        },
        buildPath: function(t, e) {
            var i = e.x,
                r = e.y,
                a = e.width,
                o = e.height;
            e.r ? n.buildPath(t, e) : t.rect(i, r, a, o), t.closePath()
        }
    })
}, function(t, e) {
    t.exports = {
        buildPath: function(t, e) {
            var i,
                n,
                r,
                a,
                o = e.x,
                s = e.y,
                l = e.width,
                c = e.height,
                u = e.r;
            l < 0 && (o += l, l = -l), c < 0 && (s += c, c = -c), "number" == typeof u ? i = n = r = a = u : u instanceof Array ? 1 === u.length ? i = n = r = a = u[0] : 2 === u.length ? (i = r = u[0], n = a = u[1]) : 3 === u.length ? (i = u[0], n = a = u[1], r = u[2]) : (i = u[0], n = u[1], r = u[2], a = u[3]) : i = n = r = a = 0;
            var h;
            i + n > l && (h = i + n, i *= l / h, n *= l / h), r + a > l && (h = r + a, r *= l / h, a *= l / h), n + r > c && (h = n + r, n *= c / h, r *= c / h), i + a > c && (h = i + a, i *= c / h, a *= c / h), t.moveTo(o + i, s), t.lineTo(o + l - n, s), 0 !== n && t.quadraticCurveTo(o + l, s, o + l, s + n), t.lineTo(o + l, s + c - r), 0 !== r && t.quadraticCurveTo(o + l, s + c, o + l - r, s + c), t.lineTo(o + a, s + c), 0 !== a && t.quadraticCurveTo(o, s + c, o, s + c - a), t.lineTo(o, s + i), 0 !== i && t.quadraticCurveTo(o, s, o + i, s)
        }
    }
}, function(t, e, i) {
    t.exports = i(550).extend({
        type: "line",
        shape: {
            x1: 0,
            y1: 0,
            x2: 0,
            y2: 0,
            percent: 1
        },
        style: {
            stroke: "#000",
            fill: null
        },
        buildPath: function(t, e) {
            var i = e.x1,
                n = e.y1,
                r = e.x2,
                a = e.y2,
                o = e.percent;
            0 !== o && (t.moveTo(i, n), o < 1 && (r = i * (1 - o) + r * o, a = n * (1 - o) + a * o), t.lineTo(r, a))
        },
        pointAt: function(t) {
            var e = this.shape;
            return [e.x1 * (1 - t) + e.x2 * t, e.y1 * (1 - t) + e.y2 * t]
        }
    })
}, function(t, e, i) {
    "use strict";
    function n(t, e, i) {
        var n = t.cpx2,
            r = t.cpy2;
        return null === n || null === r ? [(i ? h : c)(t.x1, t.cpx1, t.cpx2, t.x2, e), (i ? h : c)(t.y1, t.cpy1, t.cpy2, t.y2, e)] : [(i ? u : l)(t.x1, t.cpx1, t.x2, e), (i ? u : l)(t.y1, t.cpy1, t.y2, e)]
    }
    var r = i(555),
        a = i(515),
        o = r.quadraticSubdivide,
        s = r.cubicSubdivide,
        l = r.quadraticAt,
        c = r.cubicAt,
        u = r.quadraticDerivativeAt,
        h = r.cubicDerivativeAt,
        d = [];
    t.exports = i(550).extend({
        type: "bezier-curve",
        shape: {
            x1: 0,
            y1: 0,
            x2: 0,
            y2: 0,
            cpx1: 0,
            cpy1: 0,
            percent: 1
        },
        style: {
            stroke: "#000",
            fill: null
        },
        buildPath: function(t, e) {
            var i = e.x1,
                n = e.y1,
                r = e.x2,
                a = e.y2,
                l = e.cpx1,
                c = e.cpy1,
                u = e.cpx2,
                h = e.cpy2,
                p = e.percent;
            0 !== p && (t.moveTo(i, n), null == u || null == h ? (p < 1 && (o(i, l, r, p, d), l = d[1], r = d[2], o(n, c, a, p, d), c = d[1], a = d[2]), t.quadraticCurveTo(l, c, r, a)) : (p < 1 && (s(i, l, u, r, p, d), l = d[1], u = d[2], r = d[3], s(n, c, h, a, p, d), c = d[1], h = d[2], a = d[3]), t.bezierCurveTo(l, c, u, h, r, a)))
        },
        pointAt: function(t) {
            return n(this.shape, t, !1)
        },
        tangentAt: function(t) {
            var e = n(this.shape, t, !0);
            return a.normalize(e, e)
        }
    })
}, function(t, e, i) {
    t.exports = i(550).extend({
        type: "arc",
        shape: {
            cx: 0,
            cy: 0,
            r: 0,
            startAngle: 0,
            endAngle: 2 * Math.PI,
            clockwise: !0
        },
        style: {
            stroke: "#000",
            fill: null
        },
        buildPath: function(t, e) {
            var i = e.cx,
                n = e.cy,
                r = Math.max(e.r, 0),
                a = e.startAngle,
                o = e.endAngle,
                s = e.clockwise,
                l = Math.cos(a),
                c = Math.sin(a);
            t.moveTo(l * r + i, c * r + n), t.arc(i, n, r, a, o, !s)
        }
    })
}, function(t, e, i) {
    var n = i(550);
    t.exports = n.extend({
        type: "compound",
        shape: {
            paths: null
        },
        _updatePathDirty: function() {
            for (var t = this.__dirtyPath, e = this.shape.paths, i = 0; i < e.length; i++)
                t = t || e[i].__dirtyPath;
            this.__dirtyPath = t, this.__dirty = this.__dirty || t
        },
        beforeBrush: function() {
            this._updatePathDirty();
            for (var t = this.shape.paths || [], e = this.getGlobalScale(), i = 0; i < t.length; i++)
                t[i].path.setScale(e[0], e[1])
        },
        buildPath: function(t, e) {
            for (var i = e.paths || [], n = 0; n < i.length; n++)
                i[n].buildPath(t, i[n].shape, !0)
        },
        afterBrush: function() {
            for (var t = this.shape.paths, e = 0; e < t.length; e++)
                t[e].__dirtyPath = !1
        },
        getBoundingRect: function() {
            return this._updatePathDirty(), n.prototype.getBoundingRect.call(this)
        }
    })
}, function(t, e, i) {
    "use strict";
    var n = i(509),
        r = i(584),
        a = function(t, e, i, n, a, o) {
            this.x = null == t ? 0 : t, this.y = null == e ? 0 : e, this.x2 = null == i ? 1 : i, this.y2 = null == n ? 0 : n, this.type = "linear", this.global = o || !1, r.call(this, a)
        };
    a.prototype = {
        constructor: a
    }, n.inherits(a, r), t.exports = a
}, function(t, e) {
    var i = function(t) {
        this.colorStops = t || []
    };
    i.prototype = {
        constructor: i,
        addColorStop: function(t, e) {
            this.colorStops.push({
                offset: t,
                color: e
            })
        }
    }, t.exports = i
}, function(t, e, i) {
    "use strict";
    var n = i(509),
        r = i(584),
        a = function(t, e, i, n, a) {
            this.x = null == t ? .5 : t, this.y = null == e ? .5 : e, this.r = null == i ? .5 : i, this.type = "radial", this.global = a || !1, r.call(this, n)
        };
    a.prototype = {
        constructor: a
    }, n.inherits(a, r), t.exports = a
}, function(t, e) {
    var i = {},
        n = "\0__throttleOriginMethod",
        r = "\0__throttleRate",
        a = "\0__throttleType";
    i.throttle = function(t, e, i) {
        function n() {
            c = (new Date).getTime(), u = null, t.apply(o, s || [])
        }
        var r,
            a,
            o,
            s,
            l = 0,
            c = 0,
            u = null;
        e = e || 0;
        var h = function() {
            r = (new Date).getTime(), o = this, s = arguments, a = r - (i ? l : c) - e, clearTimeout(u), i ? u = setTimeout(n, e) : a >= 0 ? n() : u = setTimeout(n, -a), l = r
        };
        return h.clear = function() {
            u && (clearTimeout(u), u = null)
        }, h
    }, i.createOrUpdate = function(t, e, o, s) {
        var l = t[e];
        if (l) {
            var c = l[n] || l,
                u = l[a],
                h = l[r];
            if (h !== o || u !== s) {
                if (null == o || !s)
                    return t[e] = c;
                l = t[e] = i.throttle(c, o, "debounce" === s), l[n] = c, l[a] = s, l[r] = o
            }
            return l
        }
    }, i.clear = function(t, e) {
        var i = t[e];
        i && i[n] && (t[e] = i[n])
    }, t.exports = i
}, function(t, e, i) {
    function n(t) {
        delete p[t]
    } /*!
	 * ZRender, a high performance 2d drawing library.
	 *
	 * Copyright (c) 2013, Baidu Inc.
	 * All rights reserved.
	 *
	 * LICENSE
	 * https://github.com/ecomfe/zrender/blob/master/LICENSE.txt
	 */








    var r = i(537),
        a = i(507),
        o = i(509),
        s = i(588),
        l = i(590),
        c = i(592),
        u = i(595),
        h = !a.canvasSupported,
        d = {
            canvas: i(597)
        },
        p = {},
        f = {};
    f.version = "3.2.2", f.init = function(t, e) {
        var i = new g(r(), t, e);
        return p[i.id] = i, i
    }, f.dispose = function(t) {
        if (t)
            t.dispose();
        else {
            for (var e in p)
                p.hasOwnProperty(e) && p[e].dispose();
            p = {}
        }
        return f
    }, f.getInstance = function(t) {
        return p[t]
    }, f.registerPainter = function(t, e) {
        d[t] = e
    };
    var g = function(t, e, i) {
        i = i || {}, this.dom = e, this.id = t;
        var n = this,
            r = new l,
            p = i.renderer;
        if (h) {
            if (!d.vml)
                throw new Error("You need to require 'zrender/vml/vml' to support IE8");
            p = "vml"
        } else
            p && d[p] || (p = "canvas");
        var f = new d[p](e, r, i);
        this.storage = r, this.painter = f;
        var g = a.node ? null : new u(f.getViewportRoot());
        this.handler = new s(r, f, g, f.root), this.animation = new c({
            stage: {
                update: o.bind(this.flush, this)
            }
        }), this.animation.start(), this._needsRefresh;
        var m = r.delFromMap,
            v = r.addToMap;
        r.delFromMap = function(t) {
            var e = r.get(t);
            m.call(r, t), e && e.removeSelfFromZr(n)
        }, r.addToMap = function(t) {
            v.call(r, t), t.addSelfToZr(n)
        }
    };
    g.prototype = {
        constructor: g,
        getId: function() {
            return this.id
        },
        add: function(t) {
            this.storage.addRoot(t), this._needsRefresh = !0
        },
        remove: function(t) {
            this.storage.delRoot(t), this._needsRefresh = !0
        },
        configLayer: function(t, e) {
            this.painter.configLayer(t, e), this._needsRefresh = !0
        },
        refreshImmediately: function() {
            this._needsRefresh = !1, this.painter.refresh(), this._needsRefresh = !1
        },
        refresh: function() {
            this._needsRefresh = !0
        },
        flush: function() {
            this._needsRefresh && this.refreshImmediately(), this._needsRefreshHover && this.refreshHoverImmediately()
        },
        addHover: function(t, e) {
            this.painter.addHover && (this.painter.addHover(t, e), this.refreshHover())
        },
        removeHover: function(t) {
            this.painter.removeHover && (this.painter.removeHover(t), this.refreshHover())
        },
        clearHover: function() {
            this.painter.clearHover && (this.painter.clearHover(), this.refreshHover())
        },
        refreshHover: function() {
            this._needsRefreshHover = !0
        },
        refreshHoverImmediately: function() {
            this._needsRefreshHover = !1, this.painter.refreshHover && this.painter.refreshHover()
        },
        resize: function(t) {
            t = t || {}, this.painter.resize(t.width, t.height), this.handler.resize()
        },
        clearAnimation: function() {
            this.animation.clear()
        },
        getWidth: function() {
            return this.painter.getWidth()
        },
        getHeight: function() {
            return this.painter.getHeight()
        },
        pathToImage: function(t, e, i) {
            var n = r();
            return this.painter.pathToImage(n, t, e, i)
        },
        setCursorStyle: function(t) {
            this.handler.setCursorStyle(t)
        },
        on: function(t, e, i) {
            this.handler.on(t, e, i)
        },
        off: function(t, e) {
            this.handler.off(t, e)
        },
        trigger: function(t, e) {
            this.handler.trigger(t, e)
        },
        clear: function() {
            this.storage.delRoot(), this.painter.clear()
        },
        dispose: function() {
            this.animation.stop(), this.clear(), this.storage.dispose(), this.painter.dispose(), this.handler.dispose(), this.animation = this.storage = this.painter = this.handler = null, n(this.id)
        }
    }, t.exports = f
}, function(t, e, i) {
    "use strict";
    function n(t, e, i) {
        return {
            type: t,
            event: i,
            target: e,
            cancelBubble: !1,
            offsetX: i.zrX,
            offsetY: i.zrY,
            gestureEvent: i.gestureEvent,
            pinchX: i.pinchX,
            pinchY: i.pinchY,
            pinchScale: i.pinchScale,
            wheelDelta: i.zrDelta,
            zrByTouch: i.zrByTouch
        }
    }
    function r() {}
    function a(t, e, i) {
        if (t[t.rectHover ? "rectContain" : "contain"](e, i)) {
            for (var n = t; n;) {
                if (n.silent || n.clipPath && !n.clipPath.contain(e, i))
                    return !1;
                n = n.parent
            }
            return !0
        }
        return !1
    }
    var o = i(509),
        s = i(589),
        l = i(538);
    r.prototype.dispose = function() {};
    var c = ["click", "dblclick", "mousewheel", "mouseout", "mouseup", "mousedown", "mousemove", "contextmenu"],
        u = function(t, e, i, n) {
            l.call(this), this.storage = t, this.painter = e, this.painterRoot = n, i = i || new r, this.proxy = i, i.handler = this, this._hovered, this._lastTouchMoment, this._lastX, this._lastY, s.call(this), o.each(c, function(t) {
                i.on && i.on(t, this[t], this)
            }, this)
        };
    u.prototype = {
        constructor: u,
        mousemove: function(t) {
            var e = t.zrX,
                i = t.zrY,
                n = this.findHover(e, i, null),
                r = this._hovered,
                a = this.proxy;
            this._hovered = n, a.setCursor && a.setCursor(n ? n.cursor : "default"), r && n !== r && r.__zr && this.dispatchToElement(r, "mouseout", t), this.dispatchToElement(n, "mousemove", t), n && n !== r && this.dispatchToElement(n, "mouseover", t)
        },
        mouseout: function(t) {
            this.dispatchToElement(this._hovered, "mouseout", t);
            var e,
                i = t.toElement || t.relatedTarget;
            do i = i && i.parentNode;
            while (i && 9 != i.nodeType && !(e = i === this.painterRoot));
            !e && this.trigger("globalout", {
                event: t
            })
        },
        resize: function(t) {
            this._hovered = null
        },
        dispatch: function(t, e) {
            var i = this[t];
            i && i.call(this, e)
        },
        dispose: function() {
            this.proxy.dispose(), this.storage = this.proxy = this.painter = null
        },
        setCursorStyle: function(t) {
            var e = this.proxy;
            e.setCursor && e.setCursor(t)
        },
        dispatchToElement: function(t, e, i) {
            for (var r = "on" + e, a = n(e, t, i), o = t; o && (o[r] && (a.cancelBubble = o[r].call(o, a)), o.trigger(e, a), o = o.parent, !a.cancelBubble);)
                ;
            a.cancelBubble || (this.trigger(e, a), this.painter && this.painter.eachOtherLayer(function(t) {
                "function" == typeof t[r] && t[r].call(t, a), t.trigger && t.trigger(e, a)
            }))
        },
        findHover: function(t, e, i) {
            for (var n = this.storage.getDisplayList(), r = n.length - 1; r >= 0; r--)
                if (!n[r].silent && n[r] !== i && !n[r].ignore && a(n[r], t, e))
                    return n[r]
        }
    }, o.each(["click", "mousedown", "mouseup", "mousewheel", "dblclick", "contextmenu"], function(t) {
        u.prototype[t] = function(e) {
            var i = this.findHover(e.zrX, e.zrY, null);
            if ("mousedown" === t)
                this._downel = i, this._upel = i;
            else if ("mosueup" === t)
                this._upel = i;
            else if ("click" === t && this._downel !== this._upel)
                return;
            this.dispatchToElement(i, t, e)
        }
    }), o.mixin(u, l), o.mixin(u, s), t.exports = u
}, function(t, e) {
    function i() {
        this.on("mousedown", this._dragStart, this), this.on("mousemove", this._drag, this), this.on("mouseup", this._dragEnd, this), this.on("globalout", this._dragEnd, this)
    }
    i.prototype = {
        constructor: i,
        _dragStart: function(t) {
            var e = t.target;
            e && e.draggable && (this._draggingTarget = e, e.dragging = !0, this._x = t.offsetX, this._y = t.offsetY, this.dispatchToElement(e, "dragstart", t.event))
        },
        _drag: function(t) {
            var e = this._draggingTarget;
            if (e) {
                var i = t.offsetX,
                    n = t.offsetY,
                    r = i - this._x,
                    a = n - this._y;
                this._x = i, this._y = n, e.drift(r, a, t), this.dispatchToElement(e, "drag", t.event);
                var o = this.findHover(i, n, e),
                    s = this._dropTarget;
                this._dropTarget = o, e !== o && (s && o !== s && this.dispatchToElement(s, "dragleave", t.event), o && o !== s && this.dispatchToElement(o, "dragenter", t.event))
            }
        },
        _dragEnd: function(t) {
            var e = this._draggingTarget;
            e && (e.dragging = !1), this.dispatchToElement(e, "dragend", t.event), this._dropTarget && this.dispatchToElement(this._dropTarget, "drop", t.event), this._draggingTarget = null, this._dropTarget = null
        }
    }, t.exports = i
}, function(t, e, i) {
    "use strict";
    function n(t, e) {
        return t.zlevel === e.zlevel ? t.z === e.z ? t.z2 - e.z2 : t.z - e.z : t.zlevel - e.zlevel
    }
    var r = i(509),
        a = i(507),
        o = i(535),
        s = i(591),
        l = function() {
            this._elements = {}, this._roots = [], this._displayList = [], this._displayListLen = 0
        };
    l.prototype = {
        constructor: l,
        traverse: function(t, e) {
            for (var i = 0; i < this._roots.length; i++)
                this._roots[i].traverse(t, e)
        },
        getDisplayList: function(t, e) {
            return e = e || !1, t && this.updateDisplayList(e), this._displayList
        },
        updateDisplayList: function(t) {
            this._displayListLen = 0;
            for (var e = this._roots, i = this._displayList, r = 0, o = e.length; r < o; r++)
                this._updateAndAddDisplayable(e[r], null, t);
            i.length = this._displayListLen, a.canvasSupported && s(i, n)
        },
        _updateAndAddDisplayable: function(t, e, i) {
            if (!t.ignore || i) {
                t.beforeUpdate(), t.__dirty && t.update(), t.afterUpdate();
                var n = t.clipPath;
                if (n && (n.parent = t, n.updateTransform(), e ? (e = e.slice(), e.push(n)) : e = [n]), t.isGroup) {
                    for (var r = t._children, a = 0; a < r.length; a++) {
                        var o = r[a];
                        t.__dirty && (o.__dirty = !0), this._updateAndAddDisplayable(o, e, i)
                    }
                    t.__dirty = !1
                } else
                    t.__clipPaths = e, this._displayList[this._displayListLen++] = t
            }
        },
        addRoot: function(t) {
            this._elements[t.id] || (t instanceof o && t.addChildrenToStorage(this), this.addToMap(t), this._roots.push(t))
        },
        delRoot: function(t) {
            if (null == t) {
                for (var e = 0; e < this._roots.length; e++) {
                    var i = this._roots[e];
                    i instanceof o && i.delChildrenFromStorage(this)
                }
                return this._elements = {}, this._roots = [], this._displayList = [], void (this._displayListLen = 0)
            }
            if (t instanceof Array)
                for (var e = 0, n = t.length; e < n; e++)
                    this.delRoot(t[e]);
            else {
                var a;
                a = "string" == typeof t ? this._elements[t] : t;
                var s = r.indexOf(this._roots, a);
                s >= 0 && (this.delFromMap(a.id), this._roots.splice(s, 1), a instanceof o && a.delChildrenFromStorage(this))
            }
        },
        addToMap: function(t) {
            return t instanceof o && (t.__storage = this), t.dirty(!1), this._elements[t.id] = t, this
        },
        get: function(t) {
            return this._elements[t]
        },
        delFromMap: function(t) {
            var e = this._elements,
                i = e[t];
            return i && (delete e[t], i instanceof o && (i.__storage = null)), this
        },
        dispose: function() {
            this._elements = this._renderList = this._roots = null
        },
        displayableSortFunc: n
    }, t.exports = l
}, function(t, e) {
    function i(t) {
        for (var e = 0; t >= u;)
            e |= 1 & t, t >>= 1;
        return t + e
    }
    function n(t, e, i, n) {
        var a = e + 1;
        if (a === i)
            return 1;
        if (n(t[a++], t[e]) < 0) {
            for (; a < i && n(t[a], t[a - 1]) < 0;)
                a++;
            r(t, e, a)
        } else
            for (; a < i && n(t[a], t[a - 1]) >= 0;)
                a++;
        return a - e
    }
    function r(t, e, i) {
        for (i--; e < i;) {
            var n = t[e];
            t[e++] = t[i], t[i--] = n
        }
    }
    function a(t, e, i, n, r) {
        for (n === e && n++; n < i; n++) {
            for (var a, o = t[n], s = e, l = n; s < l;)
                a = s + l >>> 1, r(o, t[a]) < 0 ? l = a : s = a + 1;
            var c = n - s;
            switch (c) {
            case 3:
                t[s + 3] = t[s + 2];
            case 2:
                t[s + 2] = t[s + 1];
            case 1:
                t[s + 1] = t[s];
                break;
            default:
                for (; c > 0;)
                    t[s + c] = t[s + c - 1], c--
            }
            t[s] = o
        }
    }
    function o(t, e, i, n, r, a) {
        var o = 0,
            s = 0,
            l = 1;
        if (a(t, e[i + r]) > 0) {
            for (s = n - r; l < s && a(t, e[i + r + l]) > 0;)
                o = l, l = (l << 1) + 1, l <= 0 && (l = s);
            l > s && (l = s), o += r, l += r
        } else {
            for (s = r + 1; l < s && a(t, e[i + r - l]) <= 0;)
                o = l, l = (l << 1) + 1, l <= 0 && (l = s);
            l > s && (l = s);
            var c = o;
            o = r - l, l = r - c
        }
        for (o++; o < l;) {
            var u = o + (l - o >>> 1);
            a(t, e[i + u]) > 0 ? o = u + 1 : l = u
        }
        return l
    }
    function s(t, e, i, n, r, a) {
        var o = 0,
            s = 0,
            l = 1;
        if (a(t, e[i + r]) < 0) {
            for (s = r + 1; l < s && a(t, e[i + r - l]) < 0;)
                o = l, l = (l << 1) + 1, l <= 0 && (l = s);
            l > s && (l = s);
            var c = o;
            o = r - l, l = r - c
        } else {
            for (s = n - r; l < s && a(t, e[i + r + l]) >= 0;)
                o = l, l = (l << 1) + 1, l <= 0 && (l = s);
            l > s && (l = s), o += r, l += r
        }
        for (o++; o < l;) {
            var u = o + (l - o >>> 1);
            a(t, e[i + u]) < 0 ? l = u : o = u + 1
        }
        return l
    }
    function l(t, e) {
        function i(t, e) {
            u[y] = t, p[y] = e, y += 1
        }
        function n() {
            for (; y > 1;) {
                var t = y - 2;
                if (t >= 1 && p[t - 1] <= p[t] + p[t + 1] || t >= 2 && p[t - 2] <= p[t] + p[t - 1])
                    p[t - 1] < p[t + 1] && t--;
                else if (p[t] > p[t + 1])
                    break;
                a(t)
            }
        }
        function r() {
            for (; y > 1;) {
                var t = y - 2;
                t > 0 && p[t - 1] < p[t + 1] && t--, a(t)
            }
        }
        function a(i) {
            var n = u[i],
                r = p[i],
                a = u[i + 1],
                h = p[i + 1];
            p[i] = r + h, i === y - 3 && (u[i + 1] = u[i + 2], p[i + 1] = p[i + 2]), y--;
            var d = s(t[a], t, n, r, 0, e);
            n += d, r -= d, 0 !== r && (h = o(t[n + r - 1], t, a, h, h - 1, e), 0 !== h && (r <= h ? l(n, r, a, h) : c(n, r, a, h)))
        }
        function l(i, n, r, a) {
            var l = 0;
            for (l = 0; l < n; l++)
                x[l] = t[i + l];
            var c = 0,
                u = r,
                d = i;
            if (t[d++] = t[u++], 0 !== --a) {
                if (1 === n) {
                    for (l = 0; l < a; l++)
                        t[d + l] = t[u + l];
                    return void (t[d + a] = x[c])
                }
                for (var p, g, m, v = f;;) {
                    p = 0, g = 0, m = !1;
                    do if (e(t[u], x[c]) < 0) {
                        if (t[d++] = t[u++], g++, p = 0, 0 === --a) {
                            m = !0;
                            break
                        }
                    } else if (t[d++] = x[c++], p++, g = 0, 1 === --n) {
                        m = !0;
                        break
                    }
                    while ((p | g) < v);
                    if (m)
                        break;
                    do {
                        if (p = s(t[u], x, c, n, 0, e), 0 !== p) {
                            for (l = 0; l < p; l++)
                                t[d + l] = x[c + l];
                            if (d += p, c += p, n -= p, n <= 1) {
                                m = !0;
                                break
                            }
                        }
                        if (t[d++] = t[u++], 0 === --a) {
                            m = !0;
                            break
                        }
                        if (g = o(x[c], t, u, a, 0, e), 0 !== g) {
                            for (l = 0; l < g; l++)
                                t[d + l] = t[u + l];
                            if (d += g, u += g, a -= g, 0 === a) {
                                m = !0;
                                break
                            }
                        }
                        if (t[d++] = x[c++], 1 === --n) {
                            m = !0;
                            break
                        }
                        v--
                    } while (p >= h || g >= h);
                    if (m)
                        break;
                    v < 0 && (v = 0), v += 2
                }
                if (f = v, f < 1 && (f = 1), 1 === n) {
                    for (l = 0; l < a; l++)
                        t[d + l] = t[u + l];
                    t[d + a] = x[c]
                } else {
                    if (0 === n)
                        throw new Error;
                    for (l = 0; l < n; l++)
                        t[d + l] = x[c + l]
                }
            } else
                for (l = 0; l < n; l++)
                    t[d + l] = x[c + l]
        }
        function c(i, n, r, a) {
            var l = 0;
            for (l = 0; l < a; l++)
                x[l] = t[r + l];
            var c = i + n - 1,
                u = a - 1,
                d = r + a - 1,
                p = 0,
                g = 0;
            if (t[d--] = t[c--], 0 !== --n) {
                if (1 === a) {
                    for (d -= n, c -= n, g = d + 1, p = c + 1, l = n - 1; l >= 0; l--)
                        t[g + l] = t[p + l];
                    return void (t[d] = x[u])
                }
                for (var m = f;;) {
                    var v = 0,
                        y = 0,
                        _ = !1;
                    do if (e(x[u], t[c]) < 0) {
                        if (t[d--] = t[c--], v++, y = 0, 0 === --n) {
                            _ = !0;
                            break
                        }
                    } else if (t[d--] = x[u--], y++, v = 0, 1 === --a) {
                        _ = !0;
                        break
                    }
                    while ((v | y) < m);
                    if (_)
                        break;
                    do {
                        if (v = n - s(x[u], t, i, n, n - 1, e), 0 !== v) {
                            for (d -= v, c -= v, n -= v, g = d + 1, p = c + 1, l = v - 1; l >= 0; l--)
                                t[g + l] = t[p + l];
                            if (0 === n) {
                                _ = !0;
                                break
                            }
                        }
                        if (t[d--] = x[u--], 1 === --a) {
                            _ = !0;
                            break
                        }
                        if (y = a - o(t[c], x, 0, a, a - 1, e), 0 !== y) {
                            for (d -= y, u -= y, a -= y, g = d + 1, p = u + 1, l = 0; l < y; l++)
                                t[g + l] = x[p + l];
                            if (a <= 1) {
                                _ = !0;
                                break
                            }
                        }
                        if (t[d--] = t[c--], 0 === --n) {
                            _ = !0;
                            break
                        }
                        m--
                    } while (v >= h || y >= h);
                    if (_)
                        break;
                    m < 0 && (m = 0), m += 2
                }
                if (f = m, f < 1 && (f = 1), 1 === a) {
                    for (d -= n, c -= n, g = d + 1, p = c + 1, l = n - 1; l >= 0; l--)
                        t[g + l] = t[p + l];
                    t[d] = x[u]
                } else {
                    if (0 === a)
                        throw new Error;
                    for (p = d - (a - 1), l = 0; l < a; l++)
                        t[p + l] = x[l]
                }
            } else
                for (p = d - (a - 1), l = 0; l < a; l++)
                    t[p + l] = x[l]
        }
        var u,
            p,
            f = h,
            g = 0,
            m = d,
            v = 0,
            y = 0;
        g = t.length, g < 2 * d && (m = g >>> 1);
        var x = [];
        v = g < 120 ? 5 : g < 1542 ? 10 : g < 119151 ? 19 : 40, u = [], p = [], this.mergeRuns = n, this.forceMergeRuns = r, this.pushRun = i
    }
    function c(t, e, r, o) {
        r || (r = 0), o || (o = t.length);
        var s = o - r;
        if (!(s < 2)) {
            var c = 0;
            if (s < u)
                return c = n(t, r, o, e), void a(t, r, o, r + c, e);
            var h = new l(t, e),
                d = i(s);
            do {
                if (c = n(t, r, o, e), c < d) {
                    var p = s;
                    p > d && (p = d), a(t, r, r + p, r + c, e), c = p
                }
                h.pushRun(r, c), h.mergeRuns(), s -= c, r += c
            } while (0 !== s);
            h.forceMergeRuns()
        }
    }
    var u = 32,
        h = 7,
        d = 256;
    t.exports = c
}, function(t, e, i) {
    "use strict";
    var n = i(509),
        r = i(593).Dispatcher,
        a = i(594),
        o = i(541),
        s = function(t) {
            t = t || {}, this.stage = t.stage || {}, this.onframe = t.onframe || function() {}, this._clips = [], this._running = !1, this._time, this._pausedTime, this._pauseStart, this._paused = !1, r.call(this)
        };
    s.prototype = {
        constructor: s,
        addClip: function(t) {
            this._clips.push(t)
        },
        addAnimator: function(t) {
            t.animation = this;
            for (var e = t.getClips(), i = 0; i < e.length; i++)
                this.addClip(e[i])
        },
        removeClip: function(t) {
            var e = n.indexOf(this._clips, t);
            e >= 0 && this._clips.splice(e, 1)
        },
        removeAnimator: function(t) {
            for (var e = t.getClips(), i = 0; i < e.length; i++)
                this.removeClip(e[i]);
            t.animation = null
        },
        _update: function() {
            for (var t = (new Date).getTime() - this._pausedTime, e = t - this._time, i = this._clips, n = i.length, r = [], a = [], o = 0; o < n; o++) {
                var s = i[o],
                    l = s.step(t);
                l && (r.push(l), a.push(s))
            }
            for (var o = 0; o < n;)
                i[o]._needsRemove ? (i[o] = i[n - 1], i.pop(), n--) : o++;
            n = r.length;
            for (var o = 0; o < n; o++)
                a[o].fire(r[o]);
            this._time = t, this.onframe(e), this.trigger("frame", e), this.stage.update && this.stage.update()
        },
        _startLoop: function() {
            function t() {
                e._running && (a(t), !e._paused && e._update())
            }
            var e = this;
            this._running = !0, a(t)
        },
        start: function() {
            this._time = (new Date).getTime(), this._pausedTime = 0, this._startLoop()
        },
        stop: function() {
            this._running = !1
        },
        pause: function() {
            this._paused || (this._pauseStart = (new Date).getTime(), this._paused = !0)
        },
        resume: function() {
            this._paused && (this._pausedTime += (new Date).getTime() - this._pauseStart, this._paused = !1)
        },
        clear: function() {
            this._clips = []
        },
        animate: function(t, e) {
            e = e || {};
            var i = new o(t, e.loop, e.getter, e.setter);
            return i
        }
    }, n.mixin(s, r), t.exports = s
}, function(t, e, i) {
    "use strict";
    function n(t) {
        return t.getBoundingClientRect ? t.getBoundingClientRect() : {
            left: 0,
            top: 0
        }
    }
    function r(t, e, i, n) {
        return i = i || {}, n || !u.canvasSupported ? a(t, e, i) : u.browser.firefox && null != e.layerX && e.layerX !== e.offsetX ? (i.zrX = e.layerX, i.zrY = e.layerY) : null != e.offsetX ? (i.zrX = e.offsetX, i.zrY = e.offsetY) : a(t, e, i), i
    }
    function a(t, e, i) {
        var r = n(t);
        i.zrX = e.clientX - r.left, i.zrY = e.clientY - r.top
    }
    function o(t, e, i) {
        if (e = e || window.event, null != e.zrX)
            return e;
        var n = e.type,
            a = n && n.indexOf("touch") >= 0;
        if (a) {
            var o = "touchend" != n ? e.targetTouches[0] : e.changedTouches[0];
            o && r(t, o, e, i)
        } else
            r(t, e, e, i), e.zrDelta = e.wheelDelta ? e.wheelDelta / 120 : -(e.detail || 0) / 3;
        return e
    }
    function s(t, e, i) {
        h ? t.addEventListener(e, i) : t.attachEvent("on" + e, i)
    }
    function l(t, e, i) {
        h ? t.removeEventListener(e, i) : t.detachEvent("on" + e, i)
    }
    var c = i(538),
        u = i(507),
        h = "undefined" != typeof window && !!window.addEventListener,
        d = h ? function(t) {
            t.preventDefault(), t.stopPropagation(), t.cancelBubble = !0
        } : function(t) {
            t.returnValue = !1, t.cancelBubble = !0
        };
    t.exports = {
        clientToLocal: r,
        normalizeEvent: o,
        addEventListener: s,
        removeEventListener: l,
        stop: d,
        Dispatcher: c
    }
}, function(t, e) {
    t.exports = "undefined" != typeof window && (window.requestAnimationFrame || window.msRequestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame) || function(t) {
        setTimeout(t, 16)
    }
}, function(t, e, i) {
    function n(t) {
        return "mousewheel" === t && d.browser.firefox ? "DOMMouseScroll" : t
    }
    function r(t, e, i) {
        var n = t._gestureMgr;
        "start" === i && n.clear();
        var r = n.recognize(e, t.handler.findHover(e.zrX, e.zrY, null), t.dom);
        if ("end" === i && n.clear(), r) {
            var a = r.type;
            e.gestureEvent = a, t.handler.dispatchToElement(r.target, a, r.event)
        }
    }
    function a(t) {
        t._touching = !0, clearTimeout(t._touchTimer), t._touchTimer = setTimeout(function() {
            t._touching = !1
        }, 700)
    }
    function o() {
        return d.touchEventsSupported
    }
    function s(t) {
        function e(t, e) {
            return function() {
                if (!e._touching)
                    return t.apply(e, arguments)
            }
        }
        for (var i = 0; i < x.length; i++) {
            var n = x[i];
            t._handlers[n] = u.bind(_[n], t)
        }
        for (var i = 0; i < y.length; i++) {
            var n = y[i];
            t._handlers[n] = e(_[n], t)
        }
    }
    function l(t) {
        function e(e, i) {
            u.each(e, function(e) {
                f(t, n(e), i._handlers[e])
            }, i)
        }
        h.call(this), this.dom = t, this._touching = !1, this._touchTimer, this._gestureMgr = new p, this._handlers = {}, s(this), o() && e(x, this), e(y, this)
    }
    var c = i(593),
        u = i(509),
        h = i(538),
        d = i(507),
        p = i(596),
        f = c.addEventListener,
        g = c.removeEventListener,
        m = c.normalizeEvent,
        v = 300,
        y = ["click", "dblclick", "mousewheel", "mouseout", "mouseup", "mousedown", "mousemove", "contextmenu"],
        x = ["touchstart", "touchend", "touchmove"],
        _ = {
            mousemove: function(t) {
                t = m(this.dom, t), this.trigger("mousemove", t)
            },
            mouseout: function(t) {
                t = m(this.dom, t);
                var e = t.toElement || t.relatedTarget;
                if (e != this.dom)
                    for (; e && 9 != e.nodeType;) {
                        if (e === this.dom)
                            return;
                        e = e.parentNode
                    }
                this.trigger("mouseout", t)
            },
            touchstart: function(t) {
                t = m(this.dom, t), t.zrByTouch = !0, this._lastTouchMoment = new Date, r(this, t, "start"), _.mousemove.call(this, t), _.mousedown.call(this, t), a(this)
            },
            touchmove: function(t) {
                t = m(this.dom, t), t.zrByTouch = !0, r(this, t, "change"), _.mousemove.call(this, t), a(this)
            },
            touchend: function(t) {
                t = m(this.dom, t), t.zrByTouch = !0, r(this, t, "end"), _.mouseup.call(this, t), +new Date - this._lastTouchMoment < v && _.click.call(this, t), a(this)
            }
        };
    u.each(["click", "mousedown", "mouseup", "mousewheel", "dblclick", "contextmenu"], function(t) {
        _[t] = function(e) {
            e = m(this.dom, e), this.trigger(t, e)
        }
    });
    var b = l.prototype;
    b.dispose = function() {
        for (var t = y.concat(x), e = 0; e < t.length; e++) {
            var i = t[e];
            g(this.dom, n(i), this._handlers[i])
        }
    }, b.setCursor = function(t) {
        this.dom.style.cursor = t || "default"
    }, u.mixin(l, h), t.exports = l
}, function(t, e, i) {
    "use strict";
    function n(t) {
        var e = t[1][0] - t[0][0],
            i = t[1][1] - t[0][1];
        return Math.sqrt(e * e + i * i)
    }
    function r(t) {
        return [(t[0][0] + t[1][0]) / 2, (t[0][1] + t[1][1]) / 2]
    }
    var a = i(593),
        o = function() {
            this._track = []
        };
    o.prototype = {
        constructor: o,
        recognize: function(t, e, i) {
            return this._doTrack(t, e, i), this._recognize(t)
        },
        clear: function() {
            return this._track.length = 0, this
        },
        _doTrack: function(t, e, i) {
            var n = t.touches;
            if (n) {
                for (var r = {
                        points: [],
                        touches: [],
                        target: e,
                        event: t
                    }, o = 0, s = n.length; o < s; o++) {
                    var l = n[o],
                        c = a.clientToLocal(i, l, {});
                    r.points.push([c.zrX, c.zrY]), r.touches.push(l)
                }
                this._track.push(r)
            }
        },
        _recognize: function(t) {
            for (var e in s)
                if (s.hasOwnProperty(e)) {
                    var i = s[e](this._track, t);
                    if (i)
                        return i
                }
        }
    };
    var s = {
        pinch: function(t, e) {
            var i = t.length;
            if (i) {
                var a = (t[i - 1] || {}).points,
                    o = (t[i - 2] || {}).points || a;
                if (o && o.length > 1 && a && a.length > 1) {
                    var s = n(a) / n(o);
                    !isFinite(s) && (s = 1), e.pinchScale = s;
                    var l = r(a);
                    return e.pinchX = l[0], e.pinchY = l[1], {
                        type: "pinch",
                        target: t[0].target,
                        event: e
                    }
                }
            }
        }
    };
    t.exports = o
}, function(t, e, i) {
    "use strict";
    function n(t) {
        return parseInt(t, 10)
    }
    function r(t) {
        return !!t && (!!t.isBuildin || "function" == typeof t.resize && "function" == typeof t.refresh)
    }
    function a(t) {
        t.__unusedCount++
    }
    function o(t) {
        1 == t.__unusedCount && t.clear()
    }
    function s(t, e, i) {
        return x.copy(t.getBoundingRect()), t.transform && x.applyTransform(t.transform), _.width = e, _.height = i, !x.intersect(_)
    }
    function l(t, e) {
        if (t == e)
            return !1;
        if (!t || !e || t.length !== e.length)
            return !0;
        for (var i = 0; i < t.length; i++)
            if (t[i] !== e[i])
                return !0
    }
    function c(t, e) {
        for (var i = 0; i < t.length; i++) {
            var n = t[i],
                r = n.path;
            n.setTransform(e), r.beginPath(e), n.buildPath(r, n.shape), e.clip(), n.restoreTransform(e)
        }
    }
    function u(t, e) {
        var i = document.createElement("div");
        return i.style.cssText = ["position:relative", "overflow:hidden", "width:" + t + "px", "height:" + e + "px", "padding:0", "margin:0", "border-width:0"].join(";") + ";", i
    }
    var h = i(546),
        d = i(509),
        p = i(545),
        f = i(514),
        g = i(591),
        m = i(598),
        v = i(594),
        y = 5,
        x = new f(0, 0, 0, 0),
        _ = new f(0, 0, 0, 0),
        b = function(t, e, i) {
            var n = !t.nodeName || "CANVAS" === t.nodeName.toUpperCase();
            this._opts = i = d.extend({}, i || {}), this.dpr = i.devicePixelRatio || h.devicePixelRatio, this._singleCanvas = n, this.root = t;
            var r = t.style;
            r && (r["-webkit-tap-highlight-color"] = "transparent", r["-webkit-user-select"] = r["user-select"] = r["-webkit-touch-callout"] = "none", t.innerHTML = ""), this.storage = e;
            var a = this._zlevelList = [],
                o = this._layers = {};
            if (this._layerConfig = {}, n) {
                var s = t.width,
                    l = t.height;
                this._width = s, this._height = l;
                var c = new m(t, this, 1);
                c.initContext(), o[0] = c, a.push(0)
            } else {
                this._width = this._getSize(0), this._height = this._getSize(1);
                var p = this._domRoot = u(this._width, this._height);
                t.appendChild(p)
            }
            this.pathToImage = this._createPathToImage(), this._progressiveLayers = [], this._hoverlayer, this._hoverElements = []
        };
    b.prototype = {
        constructor: b,
        isSingleCanvas: function() {
            return this._singleCanvas
        },
        getViewportRoot: function() {
            return this._singleCanvas ? this._layers[0].dom : this._domRoot
        },
        refresh: function(t) {
            var e = this.storage.getDisplayList(!0),
                i = this._zlevelList;
            this._paintList(e, t);
            for (var n = 0; n < i.length; n++) {
                var r = i[n],
                    a = this._layers[r];
                !a.isBuildin && a.refresh && a.refresh()
            }
            return this.refreshHover(), this._progressiveLayers.length && this._startProgessive(), this
        },
        addHover: function(t, e) {
            if (!t.__hoverMir) {
                var i = new t.constructor({
                    style: t.style,
                    shape: t.shape
                });
                i.__from = t, t.__hoverMir = i, i.setStyle(e), this._hoverElements.push(i)
            }
        },
        removeHover: function(t) {
            var e = t.__hoverMir,
                i = this._hoverElements,
                n = d.indexOf(i, e);
            n >= 0 && i.splice(n, 1), t.__hoverMir = null
        },
        clearHover: function(t) {
            for (var e = this._hoverElements, i = 0; i < e.length; i++) {
                var n = e[i].__from;
                n && (n.__hoverMir = null)
            }
            e.length = 0
        },
        refreshHover: function() {
            var t = this._hoverElements,
                e = t.length,
                i = this._hoverlayer;
            if (i && i.clear(), e) {
                g(t, this.storage.displayableSortFunc), i || (i = this._hoverlayer = this.getLayer(1e5));
                var n = {};
                i.ctx.save();
                for (var r = 0; r < e;) {
                    var a = t[r],
                        o = a.__from;
                    o && o.__zr ? (r++, o.invisible || (a.transform = o.transform, a.invTransform = o.invTransform, a.__clipPaths = o.__clipPaths, this._doPaintEl(a, i, !0, n))) : (t.splice(r, 1), o.__hoverMir = null, e--)
                }
                i.ctx.restore()
            }
        },
        _startProgessive: function() {
            function t() {
                i === e._progressiveToken && e.storage && (e._doPaintList(e.storage.getDisplayList()), e._furtherProgressive ? (e._progress++, v(t)) : e._progressiveToken = -1)
            }
            var e = this;
            if (e._furtherProgressive) {
                var i = e._progressiveToken = +new Date;
                e._progress++, v(t)
            }
        },
        _clearProgressive: function() {
            this._progressiveToken = -1, this._progress = 0, d.each(this._progressiveLayers, function(t) {
                t.__dirty && t.clear()
            })
        },
        _paintList: function(t, e) {
            null == e && (e = !1), this._updateLayerStatus(t), this._clearProgressive(), this.eachBuildinLayer(a), this._doPaintList(t, e), this.eachBuildinLayer(o)
        },
        _doPaintList: function(t, e) {
            function i(t) {
                var e = a.dpr || 1;
                a.save(), a.globalAlpha = 1, a.shadowBlur = 0, n.__dirty = !0, a.setTransform(1, 0, 0, 1, 0, 0), a.drawImage(t.dom, 0, 0, u * e, h * e), a.restore()
            }
            for (var n, r, a, o, s, l, c = 0, u = this._width, h = this._height, f = this._progress, g = 0, m = t.length; g < m; g++) {
                var v = t[g],
                    x = this._singleCanvas ? 0 : v.zlevel,
                    _ = v.__frame;
                if (_ < 0 && s && (i(s), s = null), r !== x && (a && a.restore(), o = {}, r = x, n = this.getLayer(r), n.isBuildin || p("ZLevel " + r + " has been used by unkown layer " + n.id), a = n.ctx, a.save(), n.__unusedCount = 0, (n.__dirty || e) && n.clear()), n.__dirty || e) {
                    if (_ >= 0) {
                        if (!s) {
                            if (s = this._progressiveLayers[Math.min(c++, y - 1)], s.ctx.save(), s.renderScope = {}, s && s.__progress > s.__maxProgress) {
                                g = s.__nextIdxNotProg - 1;
                                continue
                            }
                            l = s.__progress, s.__dirty || (f = l), s.__progress = f + 1
                        }
                        _ === f && this._doPaintEl(v, s, !0, s.renderScope)
                    } else
                        this._doPaintEl(v, n, e, o);
                    v.__dirty = !1
                }
            }
            s && i(s), a && a.restore(), this._furtherProgressive = !1, d.each(this._progressiveLayers, function(t) {
                t.__maxProgress >= t.__progress && (this._furtherProgressive = !0)
            }, this)
        },
        _doPaintEl: function(t, e, i, n) {
            var r = e.ctx,
                a = t.transform;
            if ((e.__dirty || i) && !t.invisible && 0 !== t.style.opacity && (!a || a[0] || a[3]) && (!t.culling || !s(t, this._width, this._height))) {
                var o = t.__clipPaths;
                (n.prevClipLayer !== e || l(o, n.prevElClipPaths)) && (n.prevElClipPaths && (n.prevClipLayer.ctx.restore(), n.prevClipLayer = n.prevElClipPaths = null, n.prevEl = null), o && (r.save(), c(o, r), n.prevClipLayer = e, n.prevElClipPaths = o)), t.beforeBrush && t.beforeBrush(r), t.brush(r, n.prevEl || null), n.prevEl = t, t.afterBrush && t.afterBrush(r)
            }
        },
        getLayer: function(t) {
            if (this._singleCanvas)
                return this._layers[0];
            var e = this._layers[t];
            return e || (e = new m("zr_" + t, this, this.dpr), e.isBuildin = !0, this._layerConfig[t] && d.merge(e, this._layerConfig[t], !0), this.insertLayer(t, e), e.initContext()), e
        },
        insertLayer: function(t, e) {
            var i = this._layers,
                n = this._zlevelList,
                a = n.length,
                o = null,
                s = -1,
                l = this._domRoot;
            if (i[t])
                return void p("ZLevel " + t + " has been used already");
            if (!r(e))
                return void p("Layer of zlevel " + t + " is not valid");
            if (a > 0 && t > n[0]) {
                for (s = 0; s < a - 1 && !(n[s] < t && n[s + 1] > t); s++)
                    ;
                o = i[n[s]]
            }
            if (n.splice(s + 1, 0, t), o) {
                var c = o.dom;
                c.nextSibling ? l.insertBefore(e.dom, c.nextSibling) : l.appendChild(e.dom)
            } else
                l.firstChild ? l.insertBefore(e.dom, l.firstChild) : l.appendChild(e.dom);
            i[t] = e
        },
        eachLayer: function(t, e) {
            var i,
                n,
                r = this._zlevelList;
            for (n = 0; n < r.length; n++)
                i = r[n], t.call(e, this._layers[i], i)
        },
        eachBuildinLayer: function(t, e) {
            var i,
                n,
                r,
                a = this._zlevelList;
            for (r = 0; r < a.length; r++)
                n = a[r], i = this._layers[n], i.isBuildin && t.call(e, i, n)
        },
        eachOtherLayer: function(t, e) {
            var i,
                n,
                r,
                a = this._zlevelList;
            for (r = 0; r < a.length; r++)
                n = a[r], i = this._layers[n], i.isBuildin || t.call(e, i, n)
        },
        getLayers: function() {
            return this._layers
        },
        _updateLayerStatus: function(t) {
            var e = this._layers,
                i = this._progressiveLayers,
                n = {},
                r = {};
            this.eachBuildinLayer(function(t, e) {
                n[e] = t.elCount, t.elCount = 0, t.__dirty = !1
            }), d.each(i, function(t, e) {
                r[e] = t.elCount, t.elCount = 0, t.__dirty = !1
            });
            for (var a, o, s = 0, l = 0, c = 0, u = t.length; c < u; c++) {
                var h = t[c],
                    p = this._singleCanvas ? 0 : h.zlevel,
                    f = e[p],
                    g = h.progressive;
                if (f && (f.elCount++, f.__dirty = f.__dirty || h.__dirty), g >= 0) {
                    o !== g && (o = g, l++);
                    var v = h.__frame = l - 1;
                    if (!a) {
                        var x = Math.min(s, y - 1);
                        a = i[x], a || (a = i[x] = new m("progressive", this, this.dpr), a.initContext()), a.__maxProgress = 0
                    }
                    a.__dirty = a.__dirty || h.__dirty, a.elCount++, a.__maxProgress = Math.max(a.__maxProgress, v), a.__maxProgress >= a.__progress && (f.__dirty = !0)
                } else
                    h.__frame = -1, a && (a.__nextIdxNotProg = c, s++, a = null)
            }
            a && (s++, a.__nextIdxNotProg = c), this.eachBuildinLayer(function(t, e) {
                n[e] !== t.elCount && (t.__dirty = !0)
            }), i.length = Math.min(s, y), d.each(i, function(t, e) {
                r[e] !== t.elCount && (h.__dirty = !0), t.__dirty && (t.__progress = 0)
            })
        },
        clear: function() {
            return this.eachBuildinLayer(this._clearLayer), this
        },
        _clearLayer: function(t) {
            t.clear()
        },
        configLayer: function(t, e) {
            if (e) {
                var i = this._layerConfig;
                i[t] ? d.merge(i[t], e, !0) : i[t] = e;
                var n = this._layers[t];
                n && d.merge(n, i[t], !0)
            }
        },
        delLayer: function(t) {
            var e = this._layers,
                i = this._zlevelList,
                n = e[t];
            n && (n.dom.parentNode.removeChild(n.dom), delete e[t], i.splice(d.indexOf(i, t), 1))
        },
        resize: function(t, e) {
            var i = this._domRoot;
            i.style.display = "none";
            var n = this._opts;
            if (null != t && (n.width = t), null != e && (n.height = e), t = this._getSize(0), e = this._getSize(1), i.style.display = "", this._width != t || e != this._height) {
                i.style.width = t + "px", i.style.height = e + "px";
                for (var r in this._layers)
                    this._layers.hasOwnProperty(r) && this._layers[r].resize(t, e);
                d.each(this._progressiveLayers, function(i) {
                    i.resize(t, e)
                }), this.refresh(!0)
            }
            return this._width = t, this._height = e, this
        },
        clearLayer: function(t) {
            var e = this._layers[t];
            e && e.clear()
        },
        dispose: function() {
            this.root.innerHTML = "", this.root = this.storage = this._domRoot = this._layers = null
        },
        getRenderedCanvas: function(t) {
            if (t = t || {}, this._singleCanvas)
                return this._layers[0].dom;
            var e = new m("image", this, t.pixelRatio || this.dpr);
            e.initContext(), e.clearColor = t.backgroundColor, e.clear();
            for (var i = this.storage.getDisplayList(!0), n = {}, r = 0; r < i.length; r++) {
                var a = i[r];
                this._doPaintEl(a, e, !0, n)
            }
            return e.dom
        },
        getWidth: function() {
            return this._width
        },
        getHeight: function() {
            return this._height
        },
        _getSize: function(t) {
            var e = this._opts,
                i = ["width", "height"][t],
                r = ["clientWidth", "clientHeight"][t],
                a = ["paddingLeft", "paddingTop"][t],
                o = ["paddingRight", "paddingBottom"][t];
            if (null != e[i] && "auto" !== e[i])
                return parseFloat(e[i]);
            var s = this.root,
                l = document.defaultView.getComputedStyle(s);
            return (s[r] || n(l[i]) || n(s.style[i])) - (n(l[a]) || 0) - (n(l[o]) || 0) | 0
        },
        _pathToImage: function(t, e, n, r, a) {
            var o = document.createElement("canvas"),
                s = o.getContext("2d");
            o.width = n * a, o.height = r * a, s.clearRect(0, 0, n * a, r * a);
            var l = {
                position: e.position,
                rotation: e.rotation,
                scale: e.scale
            };
            e.position = [0, 0, 0], e.rotation = 0, e.scale = [1, 1], e && e.brush(s);
            var c = i(566),
                u = new c({
                    id: t,
                    style: {
                        x: 0,
                        y: 0,
                        image: o
                    }
                });
            return null != l.position && (u.position = e.position = l.position), null != l.rotation && (u.rotation = e.rotation = l.rotation), null != l.scale && (u.scale = e.scale = l.scale), u
        },
        _createPathToImage: function() {
            var t = this;
            return function(e, i, n, r) {
                return t._pathToImage(e, i, n, r, t.dpr)
            }
        }
    }, t.exports = b
}, function(t, e, i) {
    function n() {
        return !1
    }
    function r(t, e, i, n) {
        var r = document.createElement(e),
            a = i.getWidth(),
            o = i.getHeight(),
            s = r.style;
        return s.position = "absolute", s.left = 0, s.top = 0, s.width = a + "px", s.height = o + "px", r.width = a * n, r.height = o * n, r.setAttribute("data-zr-dom-id", t), r
    }
    var a = i(509),
        o = i(546),
        s = i(552),
        l = i(564),
        c = function(t, e, i) {
            var s;
            i = i || o.devicePixelRatio, "string" == typeof t ? s = r(t, "canvas", e, i) : a.isObject(t) && (s = t, t = s.id), this.id = t, this.dom = s;
            var l = s.style;
            l && (s.onselectstart = n, l["-webkit-user-select"] = "none", l["user-select"] = "none", l["-webkit-touch-callout"] = "none", l["-webkit-tap-highlight-color"] = "rgba(0,0,0,0)", l.padding = 0, l.margin = 0, l["border-width"] = 0), this.domBack = null, this.ctxBack = null, this.painter = e, this.config = null, this.clearColor = 0, this.motionBlur = !1, this.lastFrameAlpha = .7, this.dpr = i
        };
    c.prototype = {
        constructor: c,
        elCount: 0,
        __dirty: !0,
        initContext: function() {
            this.ctx = this.dom.getContext("2d"), this.ctx.dpr = this.dpr
        },
        createBackBuffer: function() {
            var t = this.dpr;
            this.domBack = r("back-" + this.id, "canvas", this.painter, t), this.ctxBack = this.domBack.getContext("2d"), 1 != t && this.ctxBack.scale(t, t)
        },
        resize: function(t, e) {
            var i = this.dpr,
                n = this.dom,
                r = n.style,
                a = this.domBack;
            r.width = t + "px", r.height = e + "px", n.width = t * i, n.height = e * i, a && (a.width = t * i, a.height = e * i, 1 != i && this.ctxBack.scale(i, i))
        },
        clear: function(t) {
            var e = this.dom,
                i = this.ctx,
                n = e.width,
                r = e.height,
                a = this.clearColor,
                o = this.motionBlur && !t,
                c = this.lastFrameAlpha,
                u = this.dpr;
            if (o && (this.domBack || this.createBackBuffer(), this.ctxBack.globalCompositeOperation = "copy", this.ctxBack.drawImage(e, 0, 0, n / u, r / u)), i.clearRect(0, 0, n, r), a) {
                var h;
                a.colorStops ? (h = a.__canvasGradient || s.getGradient(i, a, {
                    x: 0,
                    y: 0,
                    width: n,
                    height: r
                }), a.__canvasGradient = h) : a.image && (h = l.prototype.getCanvasPattern.call(a, i)), i.save(), i.fillStyle = h || a, i.fillRect(0, 0, n, r), i.restore()
            }
            if (o) {
                var d = this.domBack;
                i.save(), i.globalAlpha = c, i.drawImage(d, 0, 0, n, r), i.restore()
            }
        }
    }, t.exports = c
}, function(t, e, i) {
    var n = i(584);
    t.exports = function(t) {
        function e(e) {
            var i = (e.visualColorAccessPath || "itemStyle.normal.color").split("."),
                r = e.getData(),
                a = e.get(i) || e.getColorFromPalette(e.get("name"));
            r.setVisual("color", a), t.isSeriesFiltered(e) || ("function" != typeof a || a instanceof n || r.each(function(t) {
                r.setItemVisual(t, "color", a(e.getDataParams(t)))
            }), r.each(function(t) {
                var e = r.getItemModel(t),
                    n = e.get(i, !0);
                null != n && r.setItemVisual(t, "color", n)
            }))
        }
        t.eachRawSeries(e)
    }
}, function(t, e, i) {
    function n(t, e) {
        e = e.split(",");
        for (var i = t, n = 0; n < e.length && (i = i && i[e[n]], null != i); n++)
            ;
        return i
    }
    function r(t, e, i, n) {
        e = e.split(",");
        for (var r, a = t, o = 0; o < e.length - 1; o++)
            r = e[o], null == a[r] && (a[r] = {}), a = a[r];
        (n || null == a[e[o]]) && (a[e[o]] = i)
    }
    function a(t) {
        h(l, function(e) {
            e[0] in t && !(e[1] in t) && (t[e[1]] = t[e[0]])
        })
    }
    var o = i(509),
        s = i(601),
        l = [["x", "left"], ["y", "top"], ["x2", "right"], ["y2", "bottom"]],
        c = ["grid", "geo", "parallel", "legend", "toolbox", "title", "visualMap", "dataZoom", "timeline"],
        u = ["bar", "boxplot", "candlestick", "chord", "effectScatter", "funnel", "gauge", "lines", "graph", "heatmap", "line", "map", "parallel", "pie", "radar", "sankey", "scatter", "treemap"],
        h = o.each;
    t.exports = function(t) {
        h(t.series, function(t) {
            if (o.isObject(t)) {
                var e = t.type;
                if (s(t), "pie" !== e && "gauge" !== e || null != t.clockWise && (t.clockwise = t.clockWise), "gauge" === e) {
                    var i = n(t, "pointer.color");
                    null != i && r(t, "itemStyle.normal.color", i)
                }
                for (var l = 0; l < u.length; l++)
                    if (u[l] === t.type) {
                        a(t);
                        break
                    }
            }
        }), t.dataRange && (t.visualMap = t.dataRange), h(c, function(e) {
            var i = t[e];
            i && (o.isArray(i) || (i = [i]), h(i, function(t) {
                a(t)
            }))
        })
    }
}, function(t, e, i) {
    function n(t) {
        var e = t && t.itemStyle;
        e && r.each(a, function(i) {
            var n = e.normal,
                a = e.emphasis;
            n && n[i] && (t[i] = t[i] || {}, t[i].normal ? r.merge(t[i].normal, n[i]) : t[i].normal = n[i], n[i] = null), a && a[i] && (t[i] = t[i] || {}, t[i].emphasis ? r.merge(t[i].emphasis, a[i]) : t[i].emphasis = a[i], a[i] = null)
        })
    }
    var r = i(509),
        a = ["areaStyle", "lineStyle", "nodeStyle", "linkStyle", "chordStyle", "label", "labelLine"];
    t.exports = function(t) {
        if (t) {
            n(t), n(t.markPoint), n(t.markLine);
            var e = t.data;
            if (e) {
                for (var i = 0; i < e.length; i++)
                    n(e[i]);
                var a = t.markPoint;
                if (a && a.data)
                    for (var o = a.data, i = 0; i < o.length; i++)
                        n(o[i]);
                var s = t.markLine;
                if (s && s.data)
                    for (var l = s.data, i = 0; i < l.length; i++)
                        r.isArray(l[i]) ? (n(l[i][0]), n(l[i][1])) : n(l[i])
            }
        }
    }
}, function(t, e, i) {
    var n = i(548),
        r = i(509),
        a = Math.PI;
    t.exports = function(t, e) {
        e = e || {}, r.defaults(e, {
            text: "loading",
            color: "#c23531",
            textColor: "#000",
            maskColor: "rgba(255, 255, 255, 0.8)",
            zlevel: 0
        });
        var i = new n.Rect({
                style: {
                    fill: e.maskColor
                },
                zlevel: e.zlevel,
                z: 1e4
            }),
            o = new n.Arc({
                shape: {
                    startAngle: -a / 2,
                    endAngle: -a / 2 + .1,
                    r: 10
                },
                style: {
                    stroke: e.color,
                    lineCap: "round",
                    lineWidth: 5
                },
                zlevel: e.zlevel,
                z: 10001
            }),
            s = new n.Rect({
                style: {
                    fill: "none",
                    text: e.text,
                    textPosition: "right",
                    textDistance: 10,
                    textFill: e.textColor
                },
                zlevel: e.zlevel,
                z: 10001
            });
        o.animateShape(!0).when(1e3, {
            endAngle: 3 * a / 2
        }).start("circularInOut"), o.animateShape(!0).when(1e3, {
            startAngle: 3 * a / 2
        }).delay(300).start("circularInOut");
        var l = new n.Group;
        return l.add(o), l.add(s), l.add(i), l.resize = function() {
            var e = t.getWidth() / 2,
                n = t.getHeight() / 2;
            o.setShape({
                cx: e,
                cy: n
            });
            var r = o.shape.r;
            s.setShape({
                x: e - r,
                y: n - r,
                width: 2 * r,
                height: 2 * r
            }), i.setShape({
                x: 0,
                y: 0,
                width: t.getWidth(),
                height: t.getHeight()
            })
        }, l.resize(), l
    }
}, function(t, e, i) {
    (function(e) {
        function n(t) {
            return d.isArray(t) || (t = [t]), t
        }
        function r(t, e) {
            var i = t.dimensions,
                n = new v(d.map(i, t.getDimensionInfo, t), t.hostModel);
            m(n, t);
            for (var r = n._storage = {}, a = t._storage, o = 0; o < i.length; o++) {
                var s = i[o],
                    l = a[s];
                d.indexOf(e, s) >= 0 ? r[s] = new l.constructor(a[s].length) : r[s] = a[s]
            }
            return n
        }
        var a = "undefined",
            o = "undefined" == typeof window ? e : window,
            s = typeof o.Float64Array === a ? Array : o.Float64Array,
            l = typeof o.Int32Array === a ? Array : o.Int32Array,
            c = {
                float: s,
                int: l,
                ordinal: Array,
                number: Array,
                time: Array
            },
            u = i(517),
            h = i(604),
            d = i(509),
            p = i(510),
            f = d.isObject,
            g = ["stackedOn", "hasItemOption", "_nameList", "_idList", "_rawData"],
            m = function(t, e) {
                d.each(g.concat(e.__wrappedMethods || []), function(i) {
                    e.hasOwnProperty(i) && (t[i] = e[i])
                }), t.__wrappedMethods = e.__wrappedMethods
            },
            v = function(t, e) {
                t = t || ["x", "y"];
                for (var i = {}, n = [], r = 0; r < t.length; r++) {
                    var a,
                        o = {};
                    "string" == typeof t[r] ? (a = t[r], o = {
                        name: a,
                        stackable: !1,
                        type: "number"
                    }) : (o = t[r], a = o.name, o.type = o.type || "number"), n.push(a), i[a] = o
                }
                this.dimensions = n, this._dimensionInfos = i, this.hostModel = e, this.dataType, this.indices = [], this._storage = {}, this._nameList = [], this._idList = [], this._optionModels = [], this.stackedOn = null, this._visual = {}, this._layout = {}, this._itemVisuals = [], this._itemLayouts = [], this._graphicEls = [], this._rawData, this._extent
            },
            y = v.prototype;
        y.type = "list", y.hasItemOption = !0, y.getDimension = function(t) {
            return isNaN(t) || (t = this.dimensions[t] || t), t
        }, y.getDimensionInfo = function(t) {
            return d.clone(this._dimensionInfos[this.getDimension(t)])
        }, y.initData = function(t, e, i) {
            if (t = t || [], __DEV__ && !d.isArray(t))
                throw new Error("Invalid data.");
            this._rawData = t;
            var n = this._storage = {},
                r = this.indices = [],
                a = this.dimensions,
                o = t.length,
                s = this._dimensionInfos,
                l = [],
                u = {};
            e = e || [];
            for (var h = 0; h < a.length; h++) {
                var f = s[a[h]],
                    g = c[f.type];
                n[a[h]] = new g(o)
            }
            var m = this;
            i || (m.hasItemOption = !1), i = i || function(t, e, i, n) {
                var r = p.getDataItemValue(t);
                return p.isDataItemOption(t) && (m.hasItemOption = !0), p.converDataValue(r instanceof Array ? r[n] : r, s[e])
            };
            for (var v = 0; v < t.length; v++) {
                for (var y = t[v], x = 0; x < a.length; x++) {
                    var _ = a[x],
                        b = n[_];
                    b[v] = i(y, _, v, x)
                }
                r.push(v)
            }
            for (var h = 0; h < t.length; h++) {
                e[h] || t[h] && null != t[h].name && (e[h] = t[h].name);
                var w = e[h] || "",
                    M = t[h] && t[h].id;
                !M && w && (u[w] = u[w] || 0, M = w, u[w] > 0 && (M += "__ec__" + u[w]), u[w]++), M && (l[h] = M)
            }
            this._nameList = e, this._idList = l
        }, y.count = function() {
            return this.indices.length
        }, y.get = function(t, e, i) {
            var n = this._storage,
                r = this.indices[e];
            if (null == r)
                return NaN;
            var a = n[t] && n[t][r];
            if (i) {
                var o = this._dimensionInfos[t];
                if (o && o.stackable)
                    for (var s = this.stackedOn; s;) {
                        var l = s.get(t, e);
                        (a >= 0 && l > 0 || a <= 0 && l < 0) && (a += l), s = s.stackedOn
                    }
            }
            return a
        }, y.getValues = function(t, e, i) {
            var n = [];
            d.isArray(t) || (i = e, e = t, t = this.dimensions);
            for (var r = 0, a = t.length; r < a; r++)
                n.push(this.get(t[r], e, i));
            return n
        }, y.hasValue = function(t) {
            for (var e = this.dimensions, i = this._dimensionInfos, n = 0, r = e.length; n < r; n++)
                if ("ordinal" !== i[e[n]].type && isNaN(this.get(e[n], t)))
                    return !1;
            return !0
        }, y.getDataExtent = function(t, e) {
            t = this.getDimension(t);
            var i = this._storage[t],
                n = this.getDimensionInfo(t);
            e = n && n.stackable && e;
            var r,
                a = (this._extent || (this._extent = {}))[t + !!e];
            if (a)
                return a;
            if (i) {
                for (var o = 1 / 0, s = -(1 / 0), l = 0, c = this.count(); l < c; l++)
                    r = this.get(t, l, e), r < o && (o = r), r > s && (s = r);
                return this._extent[t + !!e] = [o, s]
            }
            return [1 / 0, -(1 / 0)]
        }, y.getSum = function(t, e) {
            var i = this._storage[t],
                n = 0;
            if (i)
                for (var r = 0, a = this.count(); r < a; r++) {
                    var o = this.get(t, r, e);
                    isNaN(o) || (n += o)
                }
            return n
        }, y.indexOf = function(t, e) {
            var i = this._storage,
                n = i[t],
                r = this.indices;
            if (n)
                for (var a = 0, o = r.length; a < o; a++) {
                    var s = r[a];
                    if (n[s] === e)
                        return a
                }
            return -1
        }, y.indexOfName = function(t) {
            for (var e = this.indices, i = this._nameList, n = 0, r = e.length; n < r; n++) {
                var a = e[n];
                if (i[a] === t)
                    return n
            }
            return -1
        }, y.indexOfRawIndex = function(t) {
            var e = this.indices,
                i = e[t];
            if (null != i && i === t)
                return t;
            for (var n = 0, r = e.length - 1; n <= r;) {
                var a = (n + r) / 2 | 0;
                if (e[a] < t)
                    n = a + 1;
                else {
                    if (!(e[a] > t))
                        return a;
                    r = a - 1
                }
            }
            return -1
        }, y.indexOfNearest = function(t, e, i, n) {
            var r = this._storage,
                a = r[t];
            null == n && (n = 1 / 0);
            var o = -1;
            if (a)
                for (var s = Number.MAX_VALUE, l = 0, c = this.count(); l < c; l++) {
                    var u = e - this.get(t, l, i),
                        h = Math.abs(u);
                    u <= n && (h < s || h === s && u > 0) && (s = h, o = l)
                }
            return o
        }, y.getRawIndex = function(t) {
            var e = this.indices[t];
            return null == e ? -1 : e
        }, y.getRawDataItem = function(t) {
            return this._rawData[this.getRawIndex(t)]
        }, y.getName = function(t) {
            return this._nameList[this.indices[t]] || ""
        }, y.getId = function(t) {
            return this._idList[this.indices[t]] || this.getRawIndex(t) + ""
        }, y.each = function(t, e, i, r) {
            "function" == typeof t && (r = i, i = e, e = t, t = []), t = d.map(n(t), this.getDimension, this);
            var a = [],
                o = t.length,
                s = this.indices;
            r = r || this;
            for (var l = 0; l < s.length; l++)
                switch (o) {
                case 0:
                    e.call(r, l);
                    break;
                case 1:
                    e.call(r, this.get(t[0], l, i), l);
                    break;
                case 2:
                    e.call(r, this.get(t[0], l, i), this.get(t[1], l, i), l);
                    break;
                default:
                    for (var c = 0; c < o; c++)
                        a[c] = this.get(t[c], l, i);
                    a[c] = l, e.apply(r, a)
                }
        }, y.filterSelf = function(t, e, i, r) {
            "function" == typeof t && (r = i, i = e, e = t, t = []), t = d.map(n(t), this.getDimension, this);
            var a = [],
                o = [],
                s = t.length,
                l = this.indices;
            r = r || this;
            for (var c = 0; c < l.length; c++) {
                var u;
                if (1 === s)
                    u = e.call(r, this.get(t[0], c, i), c);
                else {
                    for (var h = 0; h < s; h++)
                        o[h] = this.get(t[h], c, i);
                    o[h] = c, u = e.apply(r, o)
                }
                u && a.push(l[c])
            }
            return this.indices = a, this._extent = {}, this
        }, y.mapArray = function(t, e, i, n) {
            "function" == typeof t && (n = i, i = e, e = t, t = []);
            var r = [];
            return this.each(t, function() {
                r.push(e && e.apply(this, arguments))
            }, i, n), r
        }, y.map = function(t, e, i, a) {
            t = d.map(n(t), this.getDimension, this);
            var o = r(this, t),
                s = o.indices = this.indices,
                l = o._storage,
                c = [];
            return this.each(t, function() {
                var i = arguments[arguments.length - 1],
                    n = e && e.apply(this, arguments);
                if (null != n) {
                    "number" == typeof n && (c[0] = n, n = c);
                    for (var r = 0; r < n.length; r++) {
                        var a = t[r],
                            o = l[a],
                            u = s[i];
                        o && (o[u] = n[r])
                    }
                }
            }, i, a), o
        }, y.downSample = function(t, e, i, n) {
            for (var a = r(this, [t]), o = this._storage, s = a._storage, l = this.indices, c = a.indices = [], u = [], h = [], d = Math.floor(1 / e), p = s[t], f = this.count(), g = 0; g < o[t].length; g++)
                s[t][g] = o[t][g];
            for (var g = 0; g < f; g += d) {
                d > f - g && (d = f - g, u.length = d);
                for (var m = 0; m < d; m++) {
                    var v = l[g + m];
                    u[m] = p[v], h[m] = v
                }
                var y = i(u),
                    v = h[n(u, y) || 0];
                p[v] = y, c.push(v)
            }
            return a
        }, y.getItemModel = function(t) {
            var e = this.hostModel;
            return t = this.indices[t], new u(this._rawData[t], e, e && e.ecModel)
        }, y.diff = function(t) {
            var e,
                i = this._idList,
                n = t && t._idList,
                r = "e\0\0";
            return new h(t ? t.indices : [], this.indices, function(t) {
                return null != (e = n[t]) ? e : r + t
            }, function(t) {
                return null != (e = i[t]) ? e : r + t
            })
        }, y.getVisual = function(t) {
            var e = this._visual;
            return e && e[t]
        }, y.setVisual = function(t, e) {
            if (f(t))
                for (var i in t)
                    t.hasOwnProperty(i) && this.setVisual(i, t[i]);
            else
                this._visual = this._visual || {}, this._visual[t] = e
        }, y.setLayout = function(t, e) {
            if (f(t))
                for (var i in t)
                    t.hasOwnProperty(i) && this.setLayout(i, t[i]);
            else
                this._layout[t] = e
        }, y.getLayout = function(t) {
            return this._layout[t]
        }, y.getItemLayout = function(t) {
            return this._itemLayouts[t]
        }, y.setItemLayout = function(t, e, i) {
            this._itemLayouts[t] = i ? d.extend(this._itemLayouts[t] || {}, e) : e
        }, y.clearItemLayouts = function() {
            this._itemLayouts.length = 0
        }, y.getItemVisual = function(t, e, i) {
            var n = this._itemVisuals[t],
                r = n && n[e];
            return null != r || i ? r : this.getVisual(e)
        }, y.setItemVisual = function(t, e, i) {
            var n = this._itemVisuals[t] || {};
            if (this._itemVisuals[t] = n, f(e))
                for (var r in e)
                    e.hasOwnProperty(r) && (n[r] = e[r]);
            else
                n[e] = i
        }, y.clearAllVisual = function() {
            this._visual = {}, this._itemVisuals = []
        };
        var x = function(t) {
            t.seriesIndex = this.seriesIndex, t.dataIndex = this.dataIndex, t.dataType = this.dataType
        };
        y.setItemGraphicEl = function(t, e) {
            var i = this.hostModel;
            e && (e.dataIndex = t, e.dataType = this.dataType, e.seriesIndex = i && i.seriesIndex, "group" === e.type && e.traverse(x, e)), this._graphicEls[t] = e
        }, y.getItemGraphicEl = function(t) {
            return this._graphicEls[t]
        }, y.eachItemGraphicEl = function(t, e) {
            d.each(this._graphicEls, function(i, n) {
                i && t && t.call(e, i, n)
            })
        }, y.cloneShallow = function() {
            var t = d.map(this.dimensions, this.getDimensionInfo, this),
                e = new v(t, this.hostModel);
            return e._storage = this._storage, m(e, this), e.indices = this.indices.slice(), this._extent && (e._extent = d.extend({}, this._extent)), e
        }, y.wrapMethod = function(t, e) {
            var i = this[t];
            "function" == typeof i && (this.__wrappedMethods = this.__wrappedMethods || [], this.__wrappedMethods.push(t), this[t] = function() {
                var t = i.apply(this, arguments);
                return e.apply(this, [t].concat(d.slice(arguments)))
            })
        }, y.TRANSFERABLE_METHODS = ["cloneShallow", "downSample", "map"], y.CHANGABLE_METHODS = ["filterSelf"], t.exports = v
    }).call(e, function() {
        return this
    }())
}, function(t, e) {
    "use strict";
    function i(t) {
        return t
    }
    function n(t, e, n, r) {
        this._old = t, this._new = e, this._oldKeyGetter = n || i, this._newKeyGetter = r || i
    }
    function r(t, e, i, n) {
        for (var r = 0; r < t.length; r++) {
            var a = n(t[r], r),
                o = e[a];
            null == o ? (i.push(a), e[a] = r) : (o.length || (e[a] = o = [o]), o.push(r))
        }
    }
    n.prototype = {
        constructor: n,
        add: function(t) {
            return this._add = t, this
        },
        update: function(t) {
            return this._update = t, this
        },
        remove: function(t) {
            return this._remove = t, this
        },
        execute: function() {
            var t,
                e = this._old,
                i = this._new,
                n = this._oldKeyGetter,
                a = this._newKeyGetter,
                o = {},
                s = {},
                l = [],
                c = [];
            for (r(e, o, l, n), r(i, s, c, a), t = 0; t < e.length; t++) {
                var u = l[t],
                    h = s[u];
                if (null != h) {
                    var d = h.length;
                    d ? (1 === d && (s[u] = null), h = h.unshift()) : s[u] = null, this._update && this._update(h, t)
                } else
                    this._remove && this._remove(t)
            }
            for (var t = 0; t < c.length; t++) {
                var u = c[t];
                if (s.hasOwnProperty(u)) {
                    var h = s[u];
                    if (null == h)
                        continue;
                    if (h.length)
                        for (var p = 0, d = h.length; p < d; p++)
                            this._add && this._add(h[p]);
                    else
                        this._add && this._add(h)
                }
            }
        }
    }, t.exports = n
}, function(t, e, i) {
    var n = i(509),
        r = i(506),
        a = r.PRIORITY;
    i(606), i(609), r.registerVisual(n.curry(i(615), "line", "circle", "line")), r.registerLayout(n.curry(i(616), "line")), r.registerProcessor(a.PROCESSOR.STATISTIC, n.curry(i(617), "line")), i(618)
}, function(t, e, i) {
    "use strict";
    var n = i(607),
        r = i(533);
    t.exports = r.extend({
        type: "series.line",
        dependencies: ["grid", "polar"],
        getInitialData: function(t, e) {
            if (__DEV__) {
                var i = t.coordinateSystem;
                if ("polar" !== i && "cartesian2d" !== i)
                    throw new Error("Line not support coordinateSystem besides cartesian and polar")
            }
            return n(t.data, this, e)
        },
        defaultOption: {
            zlevel: 0,
            z: 2,
            coordinateSystem: "cartesian2d",
            legendHoverLink: !0,
            hoverAnimation: !0,
            clipOverflow: !0,
            label: {
                normal: {
                    position: "top"
                }
            },
            lineStyle: {
                normal: {
                    width: 2,
                    type: "solid"
                }
            },
            step: !1,
            smooth: !1,
            smoothMonotone: null,
            symbol: "emptyCircle",
            symbolSize: 4,
            symbolRotate: null,
            showSymbol: !0,
            showAllSymbol: !1,
            connectNulls: !1,
            sampling: "none",
            animationEasing: "linear",
            progressive: 0,
            hoverLayerThreshold: 1 / 0
        }
    })
}, function(t, e, i) {
    "use strict";
    function n(t) {
        for (var e = 0; e < t.length && null == t[e];)
            e++;
        return t[e]
    }
    function r(t) {
        var e = n(t);
        return null != e && !h.isArray(f(e))
    }
    function a(t, e, i) {
        if (t = t || [], __DEV__ && !h.isArray(t))
            throw new Error("Invalid data.");
        var n = e.get("coordinateSystem"),
            a = m[n],
            o = p.get(n),
            s = a && a(t, e, i),
            v = s && s.dimensions;
        v || (v = o && o.dimensions || ["x", "y"], v = u(v, t, v.concat(["value"])));
        var y = s ? s.categoryIndex : -1,
            x = new c(v, e),
            _ = l(s, t),
            b = {},
            w = y >= 0 && r(t) ? function(t, e, i, n) {
                return d.isDataItemOption(t) && (x.hasItemOption = !0), n === y ? i : g(f(t), v[n])
            } : function(t, e, i, n) {
                var r = f(t),
                    a = g(r && r[n], v[n]);
                d.isDataItemOption(t) && (x.hasItemOption = !0);
                var o = s && s.categoryAxesModels;
                return o && o[e] && "string" == typeof a && (b[e] = b[e] || o[e].getCategories(), a = h.indexOf(b[e], a), a < 0 && !isNaN(a) && (a = +a)), a
            };
        return x.hasItemOption = !1, x.initData(t, _, w), x
    }
    function o(t) {
        return "category" !== t && "time" !== t
    }
    function s(t) {
        return "category" === t ? "ordinal" : "time" === t ? "time" : "float"
    }
    function l(t, e) {
        var i,
            n = [],
            r = t && t.dimensions[t.categoryIndex];
        if (r && (i = t.categoryAxesModels[r.name]), i) {
            var a = i.getCategories();
            if (a) {
                var o = e.length;
                if (h.isArray(e[0]) && e[0].length > 1) {
                    n = [];
                    for (var s = 0; s < o; s++)
                        n[s] = a[e[s][t.categoryIndex || 0]]
                } else
                    n = a.slice(0)
            }
        }
        return n
    }
    var c = i(603),
        u = i(608),
        h = i(509),
        d = i(510),
        p = i(531),
        f = d.getDataItemValue,
        g = d.converDataValue,
        m = {
            cartesian2d: function(t, e, i) {
                var n = h.map(["xAxis", "yAxis"], function(t) {
                        return i.queryComponents({
                            mainType: t,
                            index: e.get(t + "Index"),
                            id: e.get(t + "Id")
                        })[0]
                    }),
                    r = n[0],
                    a = n[1];
                if (__DEV__) {
                    if (!r)
                        throw new Error('xAxis "' + h.retrieve(e.get("xAxisIndex"), e.get("xAxisId"), 0) + '" not found');
                    if (!a)
                        throw new Error('yAxis "' + h.retrieve(e.get("xAxisIndex"), e.get("yAxisId"), 0) + '" not found')
                }
                var l = r.get("type"),
                    c = a.get("type"),
                    d = [{
                        name: "x",
                        type: s(l),
                        stackable: o(l)
                    }, {
                        name: "y",
                        type: s(c),
                        stackable: o(c)
                    }],
                    p = "category" === l,
                    f = "category" === c;
                u(d, t, ["x", "y", "z"]);
                var g = {};
                return p && (g.x = r), f && (g.y = a), {
                    dimensions: d,
                    categoryIndex: p ? 0 : f ? 1 : -1,
                    categoryAxesModels: g
                }
            },
            polar: function(t, e, i) {
                var n = i.queryComponents({
                        mainType: "polar",
                        index: e.get("polarIndex"),
                        id: e.get("polarId")
                    })[0],
                    r = n.findAxisModel("angleAxis"),
                    a = n.findAxisModel("radiusAxis");
                if (__DEV__) {
                    if (!r)
                        throw new Error("angleAxis option not found");
                    if (!a)
                        throw new Error("radiusAxis option not found")
                }
                var l = a.get("type"),
                    c = r.get("type"),
                    h = [{
                        name: "radius",
                        type: s(l),
                        stackable: o(l)
                    }, {
                        name: "angle",
                        type: s(c),
                        stackable: o(c)
                    }],
                    d = "category" === c,
                    p = "category" === l;
                u(h, t, ["radius", "angle", "value"]);
                var f = {};
                return p && (f.radius = a), d && (f.angle = r), {
                    dimensions: h,
                    categoryIndex: d ? 1 : p ? 0 : -1,
                    categoryAxesModels: f
                }
            },
            geo: function(t, e, i) {
                return {
                    dimensions: u([{
                        name: "lng"
                    }, {
                        name: "lat"
                    }], t, ["lng", "lat", "value"])
                }
            }
        };
    t.exports = a
}, function(t, e, i) {
    function n(t, e, i, n) {
        if (!e)
            return t;
        var s = r(e[0]),
            l = a.isArray(s) && s.length || 1;
        i = i || [], n = n || "extra";
        for (var c = 0; c < l; c++)
            if (!t[c]) {
                var u = i[c] || n + (c - i.length);
                t[c] = o(e, c) ? {
                    type: "ordinal",
                    name: u
                } : u
            }
        return t
    }
    function r(t) {
        return a.isArray(t) ? t : a.isObject(t) ? t.value : t
    }
    var a = i(509),
        o = n.guessOrdinal = function(t, e) {
            for (var i = 0, n = t.length; i < n; i++) {
                var o = r(t[i]);
                if (!a.isArray(o))
                    return !1;
                var o = o[e];
                if (null != o && isFinite(o))
                    return !1;
                if (a.isString(o) && "-" !== o)
                    return !0
            }
            return !1
        };
    t.exports = n
}, function(t, e, i) {
    "use strict";
    function n(t, e) {
        if (t.length === e.length) {
            for (var i = 0; i < t.length; i++) {
                var n = t[i],
                    r = e[i];
                if (n[0] !== r[0] || n[1] !== r[1])
                    return
            }
            return !0
        }
    }
    function r(t) {
        return "number" == typeof t ? t : t ? .3 : 0
    }
    function a(t) {
        var e = t.getGlobalExtent();
        if (t.onBand) {
            var i = t.getBandWidth() / 2 - 1,
                n = e[1] > e[0] ? 1 : -1;
            e[0] += n * i, e[1] -= n * i
        }
        return e
    }
    function o(t) {
        return t >= 0 ? 1 : -1
    }
    function s(t, e) {
        var i = t.getBaseAxis(),
            n = t.getOtherAxis(i),
            r = i.onZero ? 0 : n.scale.getExtent()[0],
            a = n.dim,
            s = "x" === a || "radius" === a ? 1 : 0;
        return e.mapArray([a], function(n, l) {
            for (var c, u = e.stackedOn; u && o(u.get(a, l)) === o(n);) {
                c = u;
                break
            }
            var h = [];
            return h[s] = e.get(i.dim, l), h[1 - s] = c ? c.get(a, l, !0) : r, t.dataToPoint(h)
        }, !0)
    }
    function l(t, e, i) {
        var n = a(t.getAxis("x")),
            r = a(t.getAxis("y")),
            o = t.getBaseAxis().isHorizontal(),
            s = Math.min(n[0], n[1]),
            l = Math.min(r[0], r[1]),
            c = Math.max(n[0], n[1]) - s,
            u = Math.max(r[0], r[1]) - l,
            h = i.get("lineStyle.normal.width") || 2,
            d = i.get("clipOverflow") ? h / 2 : Math.max(c, u);
        o ? (l -= d, u += 2 * d) : (s -= d, c += 2 * d);
        var p = new v.Rect({
            shape: {
                x: s,
                y: l,
                width: c,
                height: u
            }
        });
        return e && (p.shape[o ? "width" : "height"] = 0, v.initProps(p, {
            shape: {
                width: c,
                height: u
            }
        }, i)), p
    }
    function c(t, e, i) {
        var n = t.getAngleAxis(),
            r = t.getRadiusAxis(),
            a = r.getExtent(),
            o = n.getExtent(),
            s = Math.PI / 180,
            l = new v.Sector({
                shape: {
                    cx: t.cx,
                    cy: t.cy,
                    r0: a[0],
                    r: a[1],
                    startAngle: -o[0] * s,
                    endAngle: -o[1] * s,
                    clockwise: n.inverse
                }
            });
        return e && (l.shape.endAngle = -o[0] * s, v.initProps(l, {
            shape: {
                endAngle: -o[1] * s
            }
        }, i)), l
    }
    function u(t, e, i) {
        return "polar" === t.type ? c(t, e, i) : l(t, e, i)
    }
    function h(t, e, i) {
        for (var n = e.getBaseAxis(), r = "x" === n.dim || "radius" === n.dim ? 0 : 1, a = [], o = 0; o < t.length - 1; o++) {
            var s = t[o + 1],
                l = t[o];
            a.push(l);
            var c = [];
            switch (i) {
            case "end":
                c[r] = s[r], c[1 - r] = l[1 - r], a.push(c);
                break;
            case "middle":
                var u = (l[r] + s[r]) / 2,
                    h = [];
                c[r] = h[r] = u, c[1 - r] = l[1 - r], h[1 - r] = s[1 - r], a.push(c), a.push(h);
                break;
            default:
                c[r] = l[r], c[1 - r] = s[1 - r], a.push(c)
            }
        }
        return t[o] && a.push(t[o]), a
    }
    function d(t, e) {
        var i = t.getVisual("visualMeta");
        if (i && i.length && t.count()) {
            for (var n, r = i.length - 1; r >= 0; r--)
                if (i[r].dimension < 2) {
                    n = i[r];
                    break
                }
            if (!n || "cartesian2d" !== e.type)
                return void (__DEV__ && console.warn("Visual map on line style only support x or y dimension."));
            var a = n.dimension,
                o = t.dimensions[a],
                s = e.getAxis(o),
                l = p.map(n.stops, function(t) {
                    return {
                        coord: s.toGlobalCoord(s.dataToCoord(t.value)),
                        color: t.color
                    }
                }),
                c = l.length,
                u = n.outerColors.slice();
            c && l[0].coord > l[c - 1].coord && (l.reverse(), u.reverse());
            var h = 10,
                d = l[0].coord - h,
                f = l[c - 1].coord + h,
                g = f - d;
            if (g < .001)
                return "transparent";
            p.each(l, function(t) {
                t.offset = (t.coord - d) / g
            }), l.push({
                offset: c ? l[c - 1].offset : .5,
                color: u[1] || "transparent"
            }), l.unshift({
                offset: c ? l[0].offset : .5,
                color: u[0] || "transparent"
            });
            var m = new v.LinearGradient(0, 0, 0, 0, l, !0);
            return m[o] = d, m[o + "2"] = f, m
        }
    }
    var p = i(509),
        f = i(610),
        g = i(611),
        m = i(613),
        v = i(548),
        y = i(510),
        x = i(614),
        _ = i(547);
    t.exports = _.extend({
        type: "line",
        init: function() {
            var t = new v.Group,
                e = new f;
            this.group.add(e.group), this._symbolDraw = e, this._lineGroup = t
        },
        render: function(t, e, i) {
            var a = t.coordinateSystem,
                o = this.group,
                l = t.getData(),
                c = t.getModel("lineStyle.normal"),
                f = t.getModel("areaStyle.normal"),
                g = l.mapArray(l.getItemLayout, !0),
                m = "polar" === a.type,
                v = this._coordSys,
                y = this._symbolDraw,
                x = this._polyline,
                _ = this._polygon,
                b = this._lineGroup,
                w = t.get("animation"),
                M = !f.isEmpty(),
                S = s(a, l),
                A = t.get("showSymbol"),
                I = A && !m && !t.get("showAllSymbol") && this._getSymbolIgnoreFunc(l, a),
                D = this._data;
            D && D.eachItemGraphicEl(function(t, e) {
                t.__temp && (o.remove(t), D.setItemGraphicEl(e, null))
            }), A || y.remove(), o.add(b);
            var k = !m && t.get("step");
            x && v.type === a.type && k === this._step ? (M && !_ ? _ = this._newPolygon(g, S, a, w) : _ && !M && (b.remove(_), _ = this._polygon = null), b.setClipPath(u(a, !1, t)), A && y.updateData(l, I), l.eachItemGraphicEl(function(t) {
                t.stopAnimation(!0)
            }), n(this._stackedOnPoints, S) && n(this._points, g) || (w ? this._updateAnimation(l, S, a, i, k) : (k && (g = h(g, a, k), S = h(S, a, k)), x.setShape({
                points: g
            }), _ && _.setShape({
                points: g,
                stackedOnPoints: S
            })))) : (A && y.updateData(l, I), k && (g = h(g, a, k), S = h(S, a, k)), x = this._newPolyline(g, a, w), M && (_ = this._newPolygon(g, S, a, w)), b.setClipPath(u(a, !0, t)));
            var T = d(l, a) || l.getVisual("color");
            x.useStyle(p.defaults(c.getLineStyle(), {
                fill: "none",
                stroke: T,
                lineJoin: "bevel"
            }));
            var C = t.get("smooth");
            if (C = r(t.get("smooth")), x.setShape({
                smooth: C,
                smoothMonotone: t.get("smoothMonotone"),
                connectNulls: t.get("connectNulls")
            }), _) {
                var L = l.stackedOn,
                    P = 0;
                if (_.useStyle(p.defaults(f.getAreaStyle(), {
                    fill: T,
                    opacity: .7,
                    lineJoin: "bevel"
                })), L) {
                    var E = L.hostModel;
                    P = r(E.get("smooth"))
                }
                _.setShape({
                    smooth: C,
                    stackedOnSmooth: P,
                    smoothMonotone: t.get("smoothMonotone"),
                    connectNulls: t.get("connectNulls")
                })
            }
            this._data = l, this._coordSys = a, this._stackedOnPoints = S, this._points = g, this._step = k
        },
        dispose: function() {},
        highlight: function(t, e, i, n) {
            var r = t.getData(),
                a = y.queryDataIndex(r, n);
            if (!(a instanceof Array) && null != a && a >= 0) {
                var o = r.getItemGraphicEl(a);
                if (!o) {
                    var s = r.getItemLayout(a);
                    if (!s)
                        return;
                    o = new g(r, a), o.position = s, o.setZ(t.get("zlevel"), t.get("z")), o.ignore = isNaN(s[0]) || isNaN(s[1]), o.__temp = !0, r.setItemGraphicEl(a, o), o.stopSymbolAnimation(!0), this.group.add(o)
                }
                o.highlight()
            } else
                _.prototype.highlight.call(this, t, e, i, n)
        },
        downplay: function(t, e, i, n) {
            var r = t.getData(),
                a = y.queryDataIndex(r, n);
            if (null != a && a >= 0) {
                var o = r.getItemGraphicEl(a);
                o && (o.__temp ? (r.setItemGraphicEl(a, null), this.group.remove(o)) : o.downplay())
            } else
                _.prototype.downplay.call(this, t, e, i, n)
        },
        _newPolyline: function(t) {
            var e = this._polyline;
            return e && this._lineGroup.remove(e), e = new x.Polyline({
                shape: {
                    points: t
                },
                silent: !0,
                z2: 10
            }), this._lineGroup.add(e), this._polyline = e, e
        },
        _newPolygon: function(t, e) {
            var i = this._polygon;
            return i && this._lineGroup.remove(i), i = new x.Polygon({
                shape: {
                    points: t,
                    stackedOnPoints: e
                },
                silent: !0
            }), this._lineGroup.add(i), this._polygon = i, i
        },
        _getSymbolIgnoreFunc: function(t, e) {
            var i = e.getAxesByScale("ordinal")[0];
            if (i && i.isLabelIgnored)
                return p.bind(i.isLabelIgnored, i)
        },
        _updateAnimation: function(t, e, i, n, r) {
            var a = this._polyline,
                o = this._polygon,
                s = t.hostModel,
                l = m(this._data, t, this._stackedOnPoints, e, this._coordSys, i),
                c = l.current,
                u = l.stackedOnCurrent,
                d = l.next,
                p = l.stackedOnNext;
            r && (c = h(l.current, i, r), u = h(l.stackedOnCurrent, i, r), d = h(l.next, i, r), p = h(l.stackedOnNext, i, r)), a.shape.__points = l.current, a.shape.points = c, v.updateProps(a, {
                shape: {
                    points: d
                }
            }, s), o && (o.setShape({
                points: c,
                stackedOnPoints: u
            }), v.updateProps(o, {
                shape: {
                    points: d,
                    stackedOnPoints: p
                }
            }, s));
            for (var f = [], g = l.status, y = 0; y < g.length; y++) {
                var x = g[y].cmd;
                if ("=" === x) {
                    var _ = t.getItemGraphicEl(g[y].idx1);
                    _ && f.push({
                        el: _,
                        ptIdx: y
                    })
                }
            }
            a.animators && a.animators.length && a.animators[0].during(function() {
                for (var t = 0; t < f.length; t++) {
                    var e = f[t].el;
                    e.attr("position", a.shape.__points[f[t].ptIdx])
                }
            })
        },
        remove: function(t) {
            var e = this.group,
                i = this._data;
            this._lineGroup.removeAll(), this._symbolDraw.remove(!0), i && i.eachItemGraphicEl(function(t, n) {
                t.__temp && (e.remove(t), i.setItemGraphicEl(n, null))
            }), this._polyline = this._polygon = this._coordSys = this._points = this._stackedOnPoints = this._data = null
        }
    })
}, function(t, e, i) {
    function n(t) {
        this.group = new a.Group, this._symbolCtor = t || o
    }
    function r(t, e, i) {
        var n = t.getItemLayout(e);
        return n && !isNaN(n[0]) && !isNaN(n[1]) && !(i && i(e)) && "none" !== t.getItemVisual(e, "symbol")
    }
    var a = i(548),
        o = i(611),
        s = n.prototype;
    s.updateData = function(t, e) {
        var i = this.group,
            n = t.hostModel,
            o = this._data,
            s = this._symbolCtor,
            l = {
                itemStyle: n.getModel("itemStyle.normal").getItemStyle(["color"]),
                hoverItemStyle: n.getModel("itemStyle.emphasis").getItemStyle(),
                symbolRotate: n.get("symbolRotate"),
                symbolOffset: n.get("symbolOffset"),
                hoverAnimation: n.get("hoverAnimation"),
                labelModel: n.getModel("label.normal"),
                hoverLabelModel: n.getModel("label.emphasis")
            };
        t.diff(o).add(function(n) {
            var a = t.getItemLayout(n);
            if (r(t, n, e)) {
                var o = new s(t, n, l);
                o.attr("position", a), t.setItemGraphicEl(n, o), i.add(o)
            }
        }).update(function(c, u) {
            var h = o.getItemGraphicEl(u),
                d = t.getItemLayout(c);
            return r(t, c, e) ? (h ? (h.updateData(t, c, l), a.updateProps(h, {
                position: d
            }, n)) : (h = new s(t, c), h.attr("position", d)), i.add(h), void t.setItemGraphicEl(c, h)) : void i.remove(h)
        }).remove(function(t) {
            var e = o.getItemGraphicEl(t);
            e && e.fadeOut(function() {
                i.remove(e)
            })
        }).execute(), this._data = t
    }, s.updateLayout = function() {
        var t = this._data;
        t && t.eachItemGraphicEl(function(e, i) {
            var n = t.getItemLayout(i);
            e.attr("position", n)
        })
    }, s.remove = function(t) {
        var e = this.group,
            i = this._data;
        i && (t ? i.eachItemGraphicEl(function(t) {
            t.fadeOut(function() {
                e.remove(t)
            })
        }) : e.removeAll())
    }, t.exports = n
}, function(t, e, i) {
    function n(t) {
        return t = t instanceof Array ? t.slice() : [+t, +t], t[0] /= 2, t[1] /= 2, t
    }
    function r(t, e, i) {
        l.Group.call(this), this.updateData(t, e, i)
    }
    function a(t, e) {
        this.parent.drift(t, e)
    }
    var o = i(509),
        s = i(612),
        l = i(548),
        c = i(512),
        u = r.prototype;
    u._createSymbol = function(t, e, i) {
        this.removeAll();
        var r = e.hostModel,
            o = e.getItemVisual(i, "color"),
            c = s.createSymbol(t, -1, -1, 2, 2, o);
        c.attr({
            z2: 100,
            culling: !0,
            scale: [0, 0]
        }), c.drift = a;
        var u = n(e.getItemVisual(i, "symbolSize"));
        l.initProps(c, {
            scale: u
        }, r, i), this._symbolType = t, this.add(c)
    }, u.stopSymbolAnimation = function(t) {
        this.childAt(0).stopAnimation(t)
    }, u.getSymbolPath = function() {
        return this.childAt(0)
    }, u.getScale = function() {
        return this.childAt(0).scale
    }, u.highlight = function() {
        this.childAt(0).trigger("emphasis")
    }, u.downplay = function() {
        this.childAt(0).trigger("normal")
    }, u.setZ = function(t, e) {
        var i = this.childAt(0);
        i.zlevel = t, i.z = e
    }, u.setDraggable = function(t) {
        var e = this.childAt(0);
        e.draggable = t, e.cursor = t ? "move" : "pointer"
    }, u.updateData = function(t, e, i) {
        this.silent = !1;
        var r = t.getItemVisual(e, "symbol") || "circle",
            a = t.hostModel,
            o = n(t.getItemVisual(e, "symbolSize"));
        if (r !== this._symbolType)
            this._createSymbol(r, t, e);
        else {
            var s = this.childAt(0);
            l.updateProps(s, {
                scale: o
            }, a, e)
        }
        this._updateCommon(t, e, o, i), this._seriesModel = a
    };
    var h = ["itemStyle", "normal"],
        d = ["itemStyle", "emphasis"],
        p = ["label", "normal"],
        f = ["label", "emphasis"];
    u._updateCommon = function(t, e, i, r) {
        var a = this.childAt(0),
            s = t.hostModel,
            u = t.getItemVisual(e, "color");
        "image" !== a.type && a.useStyle({
            strokeNoScale: !0
        }), r = r || null;
        var g = r && r.itemStyle,
            m = r && r.hoverItemStyle,
            v = r && r.symbolRotate,
            y = r && r.symbolOffset,
            x = r && r.labelModel,
            _ = r && r.hoverLabelModel,
            b = r && r.hoverAnimation;
        if (!r || t.hasItemOption) {
            var w = t.getItemModel(e);
            g = w.getModel(h).getItemStyle(["color"]), m = w.getModel(d).getItemStyle(), v = w.getShallow("symbolRotate"), y = w.getShallow("symbolOffset"), x = w.getModel(p), _ = w.getModel(f), b = w.getShallow("hoverAnimation")
        } else
            m = o.extend({}, m);
        var M = a.style;
        a.attr("rotation", (v || 0) * Math.PI / 180 || 0), y && a.attr("position", [c.parsePercent(y[0], i[0]), c.parsePercent(y[1], i[1])]), a.setColor(u), a.setStyle(g);
        var S = t.getItemVisual(e, "opacity");
        null != S && (M.opacity = S);
        for (var A, I, D = t.dimensions.slice(); D.length && (A = D.pop(), I = t.getDimensionInfo(A).type, "ordinal" === I || "time" === I);)
            ;
        null != A && x.getShallow("show") ? (l.setText(M, x, u), M.text = o.retrieve(s.getFormattedLabel(e, "normal"), t.get(A, e))) : M.text = "", null != A && _.getShallow("show") ? (l.setText(m, _, u), m.text = o.retrieve(s.getFormattedLabel(e, "emphasis"), t.get(A, e))) : m.text = "";
        var k = n(t.getItemVisual(e, "symbolSize"));
        if (a.off("mouseover").off("mouseout").off("emphasis").off("normal"), a.hoverStyle = m, l.setHoverStyle(a), b && s.ifEnableAnimation()) {
            var T = function() {
                    var t = k[1] / k[0];
                    this.animateTo({
                        scale: [Math.max(1.1 * k[0], k[0] + 3), Math.max(1.1 * k[1], k[1] + 3 * t)]
                    }, 400, "elasticOut")
                },
                C = function() {
                    this.animateTo({
                        scale: k
                    }, 400, "elasticOut")
                };
            a.on("mouseover", T).on("mouseout", C).on("emphasis", T).on("normal", C)
        }
    }, u.fadeOut = function(t) {
        var e = this.childAt(0);
        this.silent = !0, e.style.text = "", l.updateProps(e, {
            scale: [0, 0]
        }, this._seriesModel, this.dataIndex, t)
    }, o.inherits(r, l.Group), t.exports = r
}, function(t, e, i) {
    "use strict";
    var n = i(548),
        r = i(514),
        a = n.extendShape({
            type: "triangle",
            shape: {
                cx: 0,
                cy: 0,
                width: 0,
                height: 0
            },
            buildPath: function(t, e) {
                var i = e.cx,
                    n = e.cy,
                    r = e.width / 2,
                    a = e.height / 2;
                t.moveTo(i, n - a), t.lineTo(i + r, n + a), t.lineTo(i - r, n + a), t.closePath()
            }
        }),
        o = n.extendShape({
            type: "diamond",
            shape: {
                cx: 0,
                cy: 0,
                width: 0,
                height: 0
            },
            buildPath: function(t, e) {
                var i = e.cx,
                    n = e.cy,
                    r = e.width / 2,
                    a = e.height / 2;
                t.moveTo(i, n - a), t.lineTo(i + r, n), t.lineTo(i, n + a), t.lineTo(i - r, n), t.closePath()
            }
        }),
        s = n.extendShape({
            type: "pin",
            shape: {
                x: 0,
                y: 0,
                width: 0,
                height: 0
            },
            buildPath: function(t, e) {
                var i = e.x,
                    n = e.y,
                    r = e.width / 5 * 3,
                    a = Math.max(r, e.height),
                    o = r / 2,
                    s = o * o / (a - o),
                    l = n - a + o + s,
                    c = Math.asin(s / o),
                    u = Math.cos(c) * o,
                    h = Math.sin(c),
                    d = Math.cos(c);
                t.arc(i, l, o, Math.PI - c, 2 * Math.PI + c);
                var p = .6 * o,
                    f = .7 * o;
                t.bezierCurveTo(i + u - h * p, l + s + d * p, i, n - f, i, n), t.bezierCurveTo(i, n - f, i - u + h * p, l + s + d * p, i - u, l + s), t.closePath()
            }
        }),
        l = n.extendShape({
            type: "arrow",
            shape: {
                x: 0,
                y: 0,
                width: 0,
                height: 0
            },
            buildPath: function(t, e) {
                var i = e.height,
                    n = e.width,
                    r = e.x,
                    a = e.y,
                    o = n / 3 * 2;
                t.moveTo(r, a), t.lineTo(r + o, a + i), t.lineTo(r, a + i / 4 * 3), t.lineTo(r - o, a + i), t.lineTo(r, a), t.closePath()
            }
        }),
        c = {
            line: n.Line,
            rect: n.Rect,
            roundRect: n.Rect,
            square: n.Rect,
            circle: n.Circle,
            diamond: o,
            pin: s,
            arrow: l,
            triangle: a
        },
        u = {
            line: function(t, e, i, n, r) {
                r.x1 = t, r.y1 = e + n / 2, r.x2 = t + i, r.y2 = e + n / 2
            },
            rect: function(t, e, i, n, r) {
                r.x = t, r.y = e, r.width = i, r.height = n
            },
            roundRect: function(t, e, i, n, r) {
                r.x = t, r.y = e, r.width = i, r.height = n, r.r = Math.min(i, n) / 4
            },
            square: function(t, e, i, n, r) {
                var a = Math.min(i, n);
                r.x = t, r.y = e, r.width = a, r.height = a
            },
            circle: function(t, e, i, n, r) {
                r.cx = t + i / 2, r.cy = e + n / 2, r.r = Math.min(i, n) / 2
            },
            diamond: function(t, e, i, n, r) {
                r.cx = t + i / 2, r.cy = e + n / 2, r.width = i, r.height = n
            },
            pin: function(t, e, i, n, r) {
                r.x = t + i / 2, r.y = e + n / 2, r.width = i, r.height = n
            },
            arrow: function(t, e, i, n, r) {
                r.x = t + i / 2, r.y = e + n / 2, r.width = i, r.height = n
            },
            triangle: function(t, e, i, n, r) {
                r.cx = t + i / 2, r.cy = e + n / 2, r.width = i, r.height = n
            }
        },
        h = {};
    for (var d in c)
        c.hasOwnProperty(d) && (h[d] = new c[d]);
    var p = n.extendShape({
            type: "symbol",
            shape: {
                symbolType: "",
                x: 0,
                y: 0,
                width: 0,
                height: 0
            },
            beforeBrush: function() {
                var t = this.style,
                    e = this.shape;
                "pin" === e.symbolType && "inside" === t.textPosition && (t.textPosition = ["50%", "40%"], t.textAlign = "center", t.textVerticalAlign = "middle")
            },
            buildPath: function(t, e, i) {
                var n = e.symbolType,
                    r = h[n];
                "none" !== e.symbolType && (r || (n = "rect", r = h[n]), u[n](e.x, e.y, e.width, e.height, r.shape), r.buildPath(t, r.shape, i))
            }
        }),
        f = function(t) {
            if ("image" !== this.type) {
                var e = this.style,
                    i = this.shape;
                i && "line" === i.symbolType ? e.stroke = t : this.__isEmptyBrush ? (e.stroke = t, e.fill = "#fff") : (e.fill && (e.fill = t), e.stroke && (e.stroke = t)), this.dirty(!1)
            }
        },
        g = {
            createSymbol: function(t, e, i, a, o, s) {
                var l = 0 === t.indexOf("empty");
                l && (t = t.substr(5, 1).toLowerCase() + t.substr(6));
                var c;
                return c = 0 === t.indexOf("image://") ? new n.Image({
                    style: {
                        image: t.slice(8),
                        x: e,
                        y: i,
                        width: a,
                        height: o
                    }
                }) : 0 === t.indexOf("path://") ? n.makePath(t.slice(7), {}, new r(e, i, a, o)) : new p({
                    shape: {
                        symbolType: t,
                        x: e,
                        y: i,
                        width: a,
                        height: o
                    }
                }), c.__isEmptyBrush = l, c.setColor = f, c.setColor(s), c
            }
        };
    t.exports = g
}, function(t, e) {
    function i(t) {
        return t >= 0 ? 1 : -1
    }
    function n(t, e, n) {
        for (var r, a = t.getBaseAxis(), o = t.getOtherAxis(a), s = a.onZero ? 0 : o.scale.getExtent()[0], l = o.dim, c = "x" === l || "radius" === l ? 1 : 0, u = e.stackedOn, h = e.get(l, n); u && i(u.get(l, n)) === i(h);) {
            r = u;
            break
        }
        var d = [];
        return d[c] = e.get(a.dim, n), d[1 - c] = r ? r.get(l, n, !0) : s, t.dataToPoint(d)
    }
    function r(t, e) {
        var i = [];
        return e.diff(t).add(function(t) {
            i.push({
                cmd: "+",
                idx: t
            })
        }).update(function(t, e) {
            i.push({
                cmd: "=",
                idx: e,
                idx1: t
            })
        }).remove(function(t) {
            i.push({
                cmd: "-",
                idx: t
            })
        }).execute(), i
    }
    t.exports = function(t, e, i, a, o, s) {
        for (var l = r(t, e), c = [], u = [], h = [], d = [], p = [], f = [], g = [], m = s.dimensions, v = 0; v < l.length; v++) {
            var y = l[v],
                x = !0;
            switch (y.cmd) {
            case "=":
                var _ = t.getItemLayout(y.idx),
                    b = e.getItemLayout(y.idx1);
                (isNaN(_[0]) || isNaN(_[1])) && (_ = b.slice()), c.push(_), u.push(b), h.push(i[y.idx]), d.push(a[y.idx1]), g.push(e.getRawIndex(y.idx1));
                break;
            case "+":
                var w = y.idx;
                c.push(o.dataToPoint([e.get(m[0], w, !0), e.get(m[1], w, !0)])), u.push(e.getItemLayout(w).slice()), h.push(n(o, e, w)), d.push(a[w]), g.push(e.getRawIndex(w));
                break;
            case "-":
                var w = y.idx,
                    M = t.getRawIndex(w);
                M !== w ? (c.push(t.getItemLayout(w)), u.push(s.dataToPoint([t.get(m[0], w, !0), t.get(m[1], w, !0)])), h.push(i[w]), d.push(n(s, t, w)), g.push(M)) : x = !1
            }
            x && (p.push(y), f.push(f.length))
        }
        f.sort(function(t, e) {
            return g[t] - g[e]
        });
        for (var S = [], A = [], I = [], D = [], k = [], v = 0; v < f.length; v++) {
            var w = f[v];
            S[v] = c[w], A[v] = u[w], I[v] = h[w], D[v] = d[w], k[v] = p[w]
        }
        return {
            current: S,
            next: A,
            stackedOnCurrent: I,
            stackedOnNext: D,
            status: k
        }
    }
}, function(t, e, i) {
    function n(t) {
        return isNaN(t[0]) || isNaN(t[1])
    }
    function r(t, e, i, r, a, o, g, m, v, y, x) {
        for (var _ = 0, b = i, w = 0; w < r; w++) {
            var M = e[b];
            if (b >= a || b < 0)
                break;
            if (n(M)) {
                if (x) {
                    b += o;
                    continue
                }
                break
            }
            if (b === i)
                t[o > 0 ? "moveTo" : "lineTo"](M[0], M[1]), h(p, M);
            else if (v > 0) {
                var S = b + o,
                    A = e[S];
                if (x)
                    for (; A && n(e[S]);)
                        S += o, A = e[S];
                var I = .5,
                    D = e[_],
                    A = e[S];
                if (!A || n(A))
                    h(f, M);
                else {
                    n(A) && !x && (A = M), s.sub(d, A, D);
                    var k,
                        T;
                    if ("x" === y || "y" === y) {
                        var C = "x" === y ? 0 : 1;
                        k = Math.abs(M[C] - D[C]), T = Math.abs(M[C] - A[C])
                    } else
                        k = s.dist(M, D), T = s.dist(M, A);
                    I = T / (T + k), u(f, M, d, -v * (1 - I))
                }
                l(p, p, m), c(p, p, g), l(f, f, m), c(f, f, g), t.bezierCurveTo(p[0], p[1], f[0], f[1], M[0], M[1]), u(p, M, d, v * I)
            } else
                t.lineTo(M[0], M[1]);
            _ = b, b += o
        }
        return w
    }
    function a(t, e) {
        var i = [1 / 0, 1 / 0],
            n = [-(1 / 0), -(1 / 0)];
        if (e)
            for (var r = 0; r < t.length; r++) {
                var a = t[r];
                a[0] < i[0] && (i[0] = a[0]), a[1] < i[1] && (i[1] = a[1]), a[0] > n[0] && (n[0] = a[0]), a[1] > n[1] && (n[1] = a[1])
            }
        return {
            min: e ? i : n,
            max: e ? n : i
        }
    }
    var o = i(550),
        s = i(515),
        l = s.min,
        c = s.max,
        u = s.scaleAndAdd,
        h = s.copy,
        d = [],
        p = [],
        f = [];
    t.exports = {
        Polyline: o.extend({
            type: "ec-polyline",
            shape: {
                points: [],
                smooth: 0,
                smoothConstraint: !0,
                smoothMonotone: null,
                connectNulls: !1
            },
            style: {
                fill: null,
                stroke: "#000"
            },
            buildPath: function(t, e) {
                var i = e.points,
                    o = 0,
                    s = i.length,
                    l = a(i, e.smoothConstraint);
                if (e.connectNulls) {
                    for (; s > 0 && n(i[s - 1]); s--)
                        ;
                    for (; o < s && n(i[o]); o++)
                        ;
                }
                for (; o < s;)
                    o += r(t, i, o, s, s, 1, l.min, l.max, e.smooth, e.smoothMonotone, e.connectNulls) + 1
            }
        }),
        Polygon: o.extend({
            type: "ec-polygon",
            shape: {
                points: [],
                stackedOnPoints: [],
                smooth: 0,
                stackedOnSmooth: 0,
                smoothConstraint: !0,
                smoothMonotone: null,
                connectNulls: !1
            },
            buildPath: function(t, e) {
                var i = e.points,
                    o = e.stackedOnPoints,
                    s = 0,
                    l = i.length,
                    c = e.smoothMonotone,
                    u = a(i, e.smoothConstraint),
                    h = a(o, e.smoothConstraint);
                if (e.connectNulls) {
                    for (; l > 0 && n(i[l - 1]); l--)
                        ;
                    for (; s < l && n(i[s]); s++)
                        ;
                }
                for (; s < l;) {
                    var d = r(t, i, s, l, l, 1, u.min, u.max, e.smooth, c, e.connectNulls);
                    r(t, o, s + d - 1, d, l, -1, h.min, h.max, e.stackedOnSmooth, c, e.connectNulls), s += d + 1, t.closePath()
                }
            }
        })
    }
}, function(t, e) {
    t.exports = function(t, e, i, n, r) {
        n.eachRawSeriesByType(t, function(t) {
            var r = t.getData(),
                a = t.get("symbol") || e,
                o = t.get("symbolSize");
            r.setVisual({
                legendSymbol: i || a,
                symbol: a,
                symbolSize: o
            }), n.isSeriesFiltered(t) || ("function" == typeof o && r.each(function(e) {
                var i = t.getRawValue(e),
                    n = t.getDataParams(e);
                r.setItemVisual(e, "symbolSize", o(i, n))
            }), r.each(function(t) {
                var e = r.getItemModel(t),
                    i = e.getShallow("symbol", !0),
                    n = e.getShallow("symbolSize", !0);
                null != i && r.setItemVisual(t, "symbol", i), null != n && r.setItemVisual(t, "symbolSize", n)
            }))
        })
    }
}, function(t, e) {
    t.exports = function(t, e) {
        e.eachSeriesByType(t, function(t) {
            var e = t.getData(),
                i = t.coordinateSystem;
            if (i) {
                var n = i.dimensions;
                "singleAxis" === i.type ? e.each(n[0], function(t, n) {
                    e.setItemLayout(n, isNaN(t) ? [NaN, NaN] : i.dataToPoint(t))
                }) : e.each(n, function(t, n, r) {
                    e.setItemLayout(r, isNaN(t) || isNaN(n) ? [NaN, NaN] : i.dataToPoint([t, n]))
                }, !0)
            }
        })
    }
}, function(t, e) {
    var i = {
            average: function(t) {
                for (var e = 0, i = 0, n = 0; n < t.length; n++)
                    isNaN(t[n]) || (e += t[n], i++);
                return 0 === i ? NaN : e / i
            },
            sum: function(t) {
                for (var e = 0, i = 0; i < t.length; i++)
                    e += t[i] || 0;
                return e
            },
            max: function(t) {
                for (var e = -(1 / 0), i = 0; i < t.length; i++)
                    t[i] > e && (e = t[i]);
                return e
            },
            min: function(t) {
                for (var e = 1 / 0, i = 0; i < t.length; i++)
                    t[i] < e && (e = t[i]);
                return e
            },
            nearest: function(t) {
                return t[0]
            }
        },
        n = function(t, e) {
            return Math.round(t.length / 2)
        };
    t.exports = function(t, e, r) {
        e.eachSeriesByType(t, function(t) {
            var e = t.getData(),
                r = t.get("sampling"),
                a = t.coordinateSystem;
            if ("cartesian2d" === a.type && r) {
                var o = a.getBaseAxis(),
                    s = a.getOtherAxis(o),
                    l = o.getExtent(),
                    c = l[1] - l[0],
                    u = Math.round(e.count() / c);
                if (u > 1) {
                    var h;
                    "string" == typeof r ? h = i[r] : "function" == typeof r && (h = r), h && (e = e.downSample(s.dim, 1 / u, h, n), t.setData(e))
                }
            }
        }, this)
    }
}, function(t, e, i) {
    "use strict";
    var n = i(548),
        r = i(509),
        a = i(506);
    i(619), i(637), a.extendComponentView({
        type: "grid",
        render: function(t, e) {
            this.group.removeAll(), t.get("show") && this.group.add(new n.Rect({
                shape: t.coordinateSystem.getRect(),
                style: r.defaults({
                    fill: t.get("backgroundColor")
                }, t.getItemStyle()),
                silent: !0,
                z2: -1
            }))
        }
    }), a.registerPreprocessor(function(t) {
        t.xAxis && t.yAxis && !t.grid && (t.grid = {})
    })
}, function(t, e, i) {
    function n(t, e, i) {
        return t.findGridModel() === e
    }
    function r(t) {
        var e,
            i = t.model,
            n = i.getFormattedLabels(),
            r = i.getModel("axisLabel.textStyle"),
            a = 1,
            o = n.length;
        o > 40 && (a = Math.ceil(o / 40));
        for (var s = 0; s < o; s += a)
            if (!t.isLabelIgnored(s)) {
                var l = r.getTextRect(n[s]);
                e ? e.union(l) : e = l
            }
        return e
    }
    function a(t, e, i) {
        this._coordsMap = {}, this._coordsList = [], this._axesMap = {}, this._axesList = [], this._initCartesian(t, e, i), this._model = t
    }
    function o(t, e) {
        var i = t.getExtent(),
            n = i[0] + i[1];
        t.toGlobalCoord = "x" === t.dim ? function(t) {
            return t + e
        } : function(t) {
            return n - t + e
        }, t.toLocalCoord = "x" === t.dim ? function(t) {
            return t - e
        } : function(t) {
            return n - t + e
        }
    }
    function s(t, e) {
        return h.map(y, function(e) {
            var i = t.getReferringComponents(e)[0];
            if (__DEV__ && !i)
                throw new Error(e + ' "' + h.retrieve(t.get(e + "Index"), t.get(e + "Id"), 0) + '" not found');
            return i
        })
    }
    function l(t) {
        return "cartesian2d" === t.get("coordinateSystem")
    }
    var c = i(526),
        u = i(620),
        h = i(509),
        d = i(626),
        p = i(628),
        f = h.each,
        g = u.ifAxisCrossZero,
        m = u.niceScaleExtent;
    i(631);
    var v = a.prototype;
    v.type = "grid", v.getRect = function() {
        return this._rect
    }, v.update = function(t, e) {
        function i(t) {
            var e = n[t];
            for (var i in e)
                if (e.hasOwnProperty(i)) {
                    var r = e[i];
                    if (r && ("category" === r.type || !g(r)))
                        return !0
                }
            return !1
        }
        var n = this._axesMap;
        this._updateScale(t, this._model), f(n.x, function(t) {
            m(t, t.model)
        }), f(n.y, function(t) {
            m(t, t.model)
        }), f(n.x, function(t) {
            i("y") && (t.onZero = !1)
        }), f(n.y, function(t) {
            i("x") && (t.onZero = !1)
        }), this.resize(this._model, e)
    }, v.resize = function(t, e) {
        function i() {
            f(a, function(t) {
                var e = t.isHorizontal(),
                    i = e ? [0, n.width] : [0, n.height],
                    r = t.inverse ? 1 : 0;
                t.setExtent(i[r], i[1 - r]), o(t, e ? n.x : n.y)
            })
        }
        var n = c.getLayoutRect(t.getBoxLayoutParams(), {
            width: e.getWidth(),
            height: e.getHeight()
        });
        this._rect = n;
        var a = this._axesList;
        i(), t.get("containLabel") && (f(a, function(t) {
            if (!t.model.get("axisLabel.inside")) {
                var e = r(t);
                if (e) {
                    var i = t.isHorizontal() ? "height" : "width",
                        a = t.model.get("axisLabel.margin");
                    n[i] -= e[i] + a, "top" === t.position ? n.y += e.height + a : "left" === t.position && (n.x += e.width + a)
                }
            }
        }), i())
    }, v.getAxis = function(t, e) {
        var i = this._axesMap[t];
        if (null != i) {
            if (null == e)
                for (var n in i)
                    if (i.hasOwnProperty(n))
                        return i[n];
            return i[e]
        }
    }, v.getCartesian = function(t, e) {
        if (null != t && null != e) {
            var i = "x" + t + "y" + e;
            return this._coordsMap[i]
        }
        for (var n = 0, r = this._coordsList; n < r.length; n++)
            if (r[n].getAxis("x").index === t || r[n].getAxis("y").index === e)
                return r[n]
    }, v.convertToPixel = function(t, e, i) {
        var n = this._findConvertTarget(t, e);
        return n.cartesian ? n.cartesian.dataToPoint(i) : n.axis ? n.axis.toGlobalCoord(n.axis.dataToCoord(i)) : null
    }, v.convertFromPixel = function(t, e, i) {
        var n = this._findConvertTarget(t, e);
        return n.cartesian ? n.cartesian.pointToData(i) : n.axis ? n.axis.coordToData(n.axis.toLocalCoord(i)) : null
    }, v._findConvertTarget = function(t, e) {
        var i,
            n,
            r = e.seriesModel,
            a = e.xAxisModel || r && r.getReferringComponents("xAxis")[0],
            o = e.yAxisModel || r && r.getReferringComponents("yAxis")[0],
            s = e.gridModel,
            l = this._coordsList;
        if (r)
            i = r.coordinateSystem, h.indexOf(l, i) < 0 && (i = null);
        else if (a && o)
            i = this.getCartesian(a.componentIndex, o.componentIndex);
        else if (a)
            n = this.getAxis("x", a.componentIndex);
        else if (o)
            n = this.getAxis("y", o.componentIndex);
        else if (s) {
            var c = s.coordinateSystem;
            c === this && (i = this._coordsList[0])
        }
        return {
            cartesian: i,
            axis: n
        }
    }, v.containPoint = function(t) {
        var e = this._coordsList[0];
        if (e)
            return e.containPoint(t)
    }, v._initCartesian = function(t, e, i) {
        function r(i) {
            return function(r, l) {
                if (n(r, t, e)) {
                    var c = r.get("position");
                    "x" === i ? "top" !== c && "bottom" !== c && (c = "bottom", a[c] && (c = "top" === c ? "bottom" : "top")) : "left" !== c && "right" !== c && (c = "left", a[c] && (c = "left" === c ? "right" : "left")), a[c] = !0;
                    var h = new p(i, u.createScaleByModel(r), [0, 0], r.get("type"), c),
                        d = "category" === h.type;
                    h.onBand = d && r.get("boundaryGap"), h.inverse = r.get("inverse"), h.onZero = r.get("axisLine.onZero"), r.axis = h, h.model = r, h.grid = this, h.index = l, this._axesList.push(h), o[i][l] = h, s[i]++
                }
            }
        }
        var a = {
                left: !1,
                right: !1,
                top: !1,
                bottom: !1
            },
            o = {
                x: {},
                y: {}
            },
            s = {
                x: 0,
                y: 0
            };
        return e.eachComponent("xAxis", r("x"), this), e.eachComponent("yAxis", r("y"), this), s.x && s.y ? (this._axesMap = o, void f(o.x, function(t, e) {
            f(o.y, function(i, n) {
                var r = "x" + e + "y" + n,
                    a = new d(r);
                a.grid = this, this._coordsMap[r] = a, this._coordsList.push(a), a.addAxis(t), a.addAxis(i)
            }, this)
        }, this)) : (this._axesMap = {}, void (this._axesList = []))
    }, v._updateScale = function(t, e) {
        function i(t, e, i) {
            f(i.coordDimToDataDim(e.dim), function(i) {
                e.scale.unionExtent(t.getDataExtent(i, "ordinal" !== e.scale.type))
            })
        }
        h.each(this._axesList, function(t) {
            t.scale.setExtent(1 / 0, -(1 / 0))
        }), t.eachSeries(function(r) {
            if (l(r)) {
                var a = s(r, t),
                    o = a[0],
                    c = a[1];
                if (!n(o, e, t) || !n(c, e, t))
                    return;
                var u = this.getCartesian(o.componentIndex, c.componentIndex),
                    h = r.getData(),
                    d = u.getAxis("x"),
                    p = u.getAxis("y");
                "list" === h.type && (i(h, d, r), i(h, p, r))
            }
        }, this)
    };
    var y = ["xAxis", "yAxis"];
    a.create = function(t, e) {
        var i = [];
        return t.eachComponent("grid", function(n, r) {
            var o = new a(n, t, e);
            o.name = "grid_" + r, o.resize(n, e), n.coordinateSystem = o, i.push(o)
        }), t.eachSeries(function(e) {
            if (l(e)) {
                var i = s(e, t),
                    n = i[0],
                    r = i[1],
                    a = n.findGridModel();
                if (__DEV__) {
                    if (!a)
                        throw new Error('Grid "' + h.retrieve(n.get("gridIndex"), n.get("gridId"), 0) + '" not found');
                    if (n.findGridModel() !== r.findGridModel())
                        throw new Error("xAxis and yAxis must use the same grid")
                }
                var o = a.coordinateSystem;
                e.coordinateSystem = o.getCartesian(n.componentIndex, r.componentIndex)
            }
        }), i
    }, a.dimensions = d.prototype.dimensions, i(531).register("cartesian2d", a), t.exports = a
}, function(t, e, i) {
    var n = i(621),
        r = i(623);
    i(624), i(625);
    var a = i(622),
        o = i(512),
        s = i(509),
        l = i(513),
        c = {};
    c.getScaleExtent = function(t, e) {
        var i = t.scale,
            n = i.getExtent(),
            r = n[1] - n[0];
        if ("ordinal" === i.type)
            return isFinite(r) ? n : [0, 0];
        var a = e.getMin ? e.getMin() : e.get("min"),
            l = e.getMax ? e.getMax() : e.get("max"),
            c = e.getNeedCrossZero ? e.getNeedCrossZero() : !e.get("scale"),
            u = e.get("boundaryGap");
        s.isArray(u) || (u = [u || 0, u || 0]), u[0] = o.parsePercent(u[0], 1), u[1] = o.parsePercent(u[1], 1);
        var h = !0,
            d = !0;
        return null == a && (a = n[0] - u[0] * r, h = !1), null == l && (l = n[1] + u[1] * r, d = !1), "dataMin" === a && (a = n[0]), "dataMax" === l && (l = n[1]), c && (a > 0 && l > 0 && !h && (a = 0), a < 0 && l < 0 && !d && (l = 0)), [a, l]
    }, c.niceScaleExtent = function(t, e) {
        var i = t.scale,
            n = c.getScaleExtent(t, e),
            r = null != (e.getMin ? e.getMin() : e.get("min")),
            a = null != (e.getMax ? e.getMax() : e.get("max")),
            o = e.get("splitNumber");
        "log" === i.type && (i.base = e.get("logBase")), i.setExtent(n[0], n[1]), i.niceExtent(o, r, a);
        var s = e.get("minInterval");
        if (isFinite(s) && !r && !a && "interval" === i.type) {
            var l = i.getInterval(),
                u = Math.max(Math.abs(l), s) / l;
            n = i.getExtent();
            var h = (n[1] + n[0]) / 2;
            i.setExtent(u * (n[0] - h) + h, u * (n[1] - h) + h), i.niceExtent(o)
        }
        var l = e.get("interval");
        null != l && i.setInterval && i.setInterval(l)
    }, c.createScaleByModel = function(t, e) {
        if (e = e || t.get("type"))
            switch (e) {
            case "category":
                return new n(t.getCategories(), [1 / 0, -(1 / 0)]);
            case "value":
                return new r;
            default:
                return (a.getClass(e) || r).create(t)
            }
    }, c.ifAxisCrossZero = function(t) {
        var e = t.scale.getExtent(),
            i = e[0],
            n = e[1];
        return !(i > 0 && n > 0 || i < 0 && n < 0)
    }, c.getAxisLabelInterval = function(t, e, i, n) {
        var r,
            a = 0,
            o = 0,
            s = 1;
        e.length > 40 && (s = Math.floor(e.length / 40));
        for (var c = 0; c < t.length; c += s) {
            var u = t[c],
                h = l.getBoundingRect(e[c], i, "center", "top");
            h[n ? "x" : "y"] += u, h[n ? "width" : "height"] *= 1.3, r ? r.intersect(h) ? (o++, a = Math.max(a, o)) : (r.union(h), o = 0) : r = h.clone()
        }
        return 0 === a && s > 1 ? s : (a + 1) * s - 1
    }, c.getFormattedLabels = function(t, e) {
        var i = t.scale,
            n = i.getTicksLabels(),
            r = i.getTicks();
        return "string" == typeof e ? (e = function(t) {
            return function(e) {
                return t.replace("{value}", null != e ? e : "")
            }
        }(e), s.map(n, e)) : "function" == typeof e ? s.map(r, function(n, r) {
            return e("category" === t.type ? i.getLabel(n) : n, r)
        }, this) : n
    }, t.exports = c
}, function(t, e, i) {
    var n = i(509),
        r = i(622),
        a = r.prototype,
        o = r.extend({
            type: "ordinal",
            init: function(t, e) {
                this._data = t, this._extent = e || [0, t.length - 1]
            },
            parse: function(t) {
                return "string" == typeof t ? n.indexOf(this._data, t) : Math.round(t)
            },
            contain: function(t) {
                return t = this.parse(t), a.contain.call(this, t) && null != this._data[t]
            },
            normalize: function(t) {
                return a.normalize.call(this, this.parse(t))
            },
            scale: function(t) {
                return Math.round(a.scale.call(this, t))
            },
            getTicks: function() {
                for (var t = [], e = this._extent, i = e[0]; i <= e[1];)
                    t.push(i), i++;
                return t
            },
            getLabel: function(t) {
                return this._data[t]
            },
            count: function() {
                return this._extent[1] - this._extent[0] + 1
            },
            niceTicks: n.noop,
            niceExtent: n.noop
        });
    o.create = function() {
        return new o
    }, t.exports = o
}, function(t, e, i) {
    function n() {
        this._extent = [1 / 0, -(1 / 0)], this._interval = 0, this.init && this.init.apply(this, arguments)
    }
    var r = i(518),
        a = n.prototype;
    a.parse = function(t) {
        return t
    }, a.contain = function(t) {
        var e = this._extent;
        return t >= e[0] && t <= e[1]
    }, a.normalize = function(t) {
        var e = this._extent;
        return e[1] === e[0] ? .5 : (t - e[0]) / (e[1] - e[0])
    }, a.scale = function(t) {
        var e = this._extent;
        return t * (e[1] - e[0]) + e[0]
    }, a.unionExtent = function(t) {
        var e = this._extent;
        t[0] < e[0] && (e[0] = t[0]), t[1] > e[1] && (e[1] = t[1])
    }, a.getExtent = function() {
        return this._extent.slice()
    }, a.setExtent = function(t, e) {
        var i = this._extent;
        isNaN(t) || (i[0] = t), isNaN(e) || (i[1] = e)
    }, a.getTicksLabels = function() {
        for (var t = [], e = this.getTicks(), i = 0; i < e.length; i++)
            t.push(this.getLabel(e[i]));
        return t
    }, r.enableClassExtend(n), r.enableClassManagement(n, {
        registerWhenExtend: !0
    }), t.exports = n
}, function(t, e, i) {
    var n = i(512),
        r = i(511),
        a = i(622),
        o = Math.floor,
        s = Math.ceil,
        l = n.getPrecisionSafe,
        c = n.round,
        u = a.extend({
            type: "interval",
            _interval: 0,
            setExtent: function(t, e) {
                var i = this._extent;
                isNaN(t) || (i[0] = parseFloat(t)), isNaN(e) || (i[1] = parseFloat(e))
            },
            unionExtent: function(t) {
                var e = this._extent;
                t[0] < e[0] && (e[0] = t[0]), t[1] > e[1] && (e[1] = t[1]), u.prototype.setExtent.call(this, e[0], e[1])
            },
            getInterval: function() {
                return this._interval || this.niceTicks(), this._interval
            },
            setInterval: function(t) {
                this._interval = t, this._niceExtent = this._extent.slice()
            },
            getTicks: function() {
                this._interval || this.niceTicks();
                var t = this._interval,
                    e = this._extent,
                    i = [],
                    n = 1e4;
                if (t) {
                    var r = this._niceExtent,
                        a = l(t) + 2;
                    e[0] < r[0] && i.push(e[0]);
                    for (var o = r[0]; o <= r[1];)
                        if (i.push(o), o = c(o + t, a), i.length > n)
                            return [];
                    e[1] > (i.length ? i[i.length - 1] : r[1]) && i.push(e[1])
                }
                return i
            },
            getTicksLabels: function() {
                for (var t = [], e = this.getTicks(), i = 0; i < e.length; i++)
                    t.push(this.getLabel(e[i]));
                return t
            },
            getLabel: function(t) {
                return r.addCommas(t)
            },
            niceTicks: function(t) {
                t = t || 5;
                var e = this._extent,
                    i = e[1] - e[0];
                if (isFinite(i)) {
                    i < 0 && (i = -i, e.reverse());
                    var r = c(n.nice(i / t, !0), Math.max(l(e[0]), l(e[1])) + 2),
                        a = l(r) + 2,
                        u = [c(s(e[0] / r) * r, a), c(o(e[1] / r) * r, a)];
                    this._interval = r, this._niceExtent = u
                }
            },
            niceExtent: function(t, e, i) {
                var n = this._extent;
                if (n[0] === n[1])
                    if (0 !== n[0]) {
                        var r = n[0];
                        i ? n[0] -= r / 2 : (n[1] += r / 2, n[0] -= r / 2)
                    } else
                        n[1] = 1;
                var a = n[1] - n[0];
                isFinite(a) || (n[0] = 0, n[1] = 1), this.niceTicks(t);
                var l = this._interval;
                e || (n[0] = c(o(n[0] / l) * l)), i || (n[1] = c(s(n[1] / l) * l))
            }
        });
    u.create = function() {
        return new u
    }, t.exports = u
}, function(t, e, i) {
    var n = i(509),
        r = i(512),
        a = i(511),
        o = i(623),
        s = o.prototype,
        l = Math.ceil,
        c = Math.floor,
        u = 1e3,
        h = 60 * u,
        d = 60 * h,
        p = 24 * d,
        f = function(t, e, i, n) {
            for (; i < n;) {
                var r = i + n >>> 1;
                t[r][2] < e ? i = r + 1 : n = r
            }
            return i
        },
        g = o.extend({
            type: "time",
            getLabel: function(t) {
                var e = this._stepLvl,
                    i = new Date(t);
                return a.formatTime(e[0], i)
            },
            niceExtent: function(t, e, i) {
                var n = this._extent;
                if (n[0] === n[1] && (n[0] -= p, n[1] += p), n[1] === -(1 / 0) && n[0] === 1 / 0) {
                    var a = new Date;
                    n[1] = new Date(a.getFullYear(), a.getMonth(), a.getDate()), n[0] = n[1] - p
                }
                this.niceTicks(t);
                var o = this._interval;
                e || (n[0] = r.round(c(n[0] / o) * o)), i || (n[1] = r.round(l(n[1] / o) * o))
            },
            niceTicks: function(t) {
                t = t || 10;
                var e = this._extent,
                    i = e[1] - e[0],
                    n = i / t,
                    a = m.length,
                    o = f(m, n, 0, a),
                    s = m[Math.min(o, a - 1)],
                    u = s[2];
                if ("year" === s[0]) {
                    var h = i / u,
                        d = r.nice(h / t, !0);
                    u *= d
                }
                var p = [l(e[0] / u) * u, c(e[1] / u) * u];
                this._stepLvl = s, this._interval = u, this._niceExtent = p
            },
            parse: function(t) {
                return +r.parseDate(t)
            }
        });
    n.each(["contain", "normalize"], function(t) {
        g.prototype[t] = function(e) {
            return s[t].call(this, this.parse(e))
        }
    });
    var m = [["hh:mm:ss", 1, u], ["hh:mm:ss", 5, 5 * u], ["hh:mm:ss", 10, 10 * u], ["hh:mm:ss", 15, 15 * u], ["hh:mm:ss", 30, 30 * u], ["hh:mm\nMM-dd", 1, h], ["hh:mm\nMM-dd", 5, 5 * h], ["hh:mm\nMM-dd", 10, 10 * h], ["hh:mm\nMM-dd", 15, 15 * h], ["hh:mm\nMM-dd", 30, 30 * h], ["hh:mm\nMM-dd", 1, d], ["hh:mm\nMM-dd", 2, 2 * d], ["hh:mm\nMM-dd", 6, 6 * d], ["hh:mm\nMM-dd", 12, 12 * d], ["MM-dd\nyyyy", 1, p], ["week", 7, 7 * p], ["month", 1, 31 * p], ["quarter", 3, 380 * p / 4], ["half-year", 6, 380 * p / 2], ["year", 1, 380 * p]];
    g.create = function() {
        return new g
    }, t.exports = g
}, function(t, e, i) {
    function n(t, e) {
        return h(t, u(e))
    }
    var r = i(509),
        a = i(622),
        o = i(512),
        s = i(623),
        l = a.prototype,
        c = s.prototype,
        u = o.getPrecisionSafe,
        h = o.round,
        d = Math.floor,
        p = Math.ceil,
        f = Math.pow,
        g = Math.log,
        m = a.extend({
            type: "log",
            base: 10,
            $constructor: function() {
                a.apply(this, arguments), this._originalScale = new s
            },
            getTicks: function() {
                var t = this._originalScale,
                    e = this._extent,
                    i = t.getExtent();
                return r.map(c.getTicks.call(this), function(r) {
                    var a = o.round(f(this.base, r));
                    return a = r === e[0] && t.__fixMin ? n(a, i[0]) : a, a = r === e[1] && t.__fixMax ? n(a, i[1]) : a
                }, this)
            },
            getLabel: c.getLabel,
            scale: function(t) {
                return t = l.scale.call(this, t), f(this.base, t)
            },
            setExtent: function(t, e) {
                var i = this.base;
                t = g(t) / g(i), e = g(e) / g(i), c.setExtent.call(this, t, e)
            },
            getExtent: function() {
                var t = this.base,
                    e = l.getExtent.call(this);
                e[0] = f(t, e[0]), e[1] = f(t, e[1]);
                var i = this._originalScale,
                    r = i.getExtent();
                return i.__fixMin && (e[0] = n(e[0], r[0])), i.__fixMax && (e[1] = n(e[1], r[1])), e
            },
            unionExtent: function(t) {
                this._originalScale.unionExtent(t);
                var e = this.base;
                t[0] = g(t[0]) / g(e), t[1] = g(t[1]) / g(e), l.unionExtent.call(this, t)
            },
            niceTicks: function(t) {
                t = t || 10;
                var e = this._extent,
                    i = e[1] - e[0];
                if (!(i === 1 / 0 || i <= 0)) {
                    var n = o.quantity(i),
                        r = t / i * n;
                    for (r <= .5 && (n *= 10); !isNaN(n) && Math.abs(n) < 1 && Math.abs(n) > 0;)
                        n *= 10;
                    var a = [o.round(p(e[0] / n) * n), o.round(d(e[1] / n) * n)];
                    this._interval = n, this._niceExtent = a
                }
            },
            niceExtent: function(t, e, i) {
                c.niceExtent.call(this, t, e, i);
                var n = this._originalScale;
                n.__fixMin = e, n.__fixMax = i
            }
        });
    r.each(["contain", "normalize"], function(t) {
        m.prototype[t] = function(e) {
            return e = g(e) / g(this.base), l[t].call(this, e)
        }
    }), m.create = function() {
        return new m
    }, t.exports = m
}, function(t, e, i) {
    "use strict";
    function n(t) {
        a.call(this, t)
    }
    var r = i(509),
        a = i(627);
    n.prototype = {
        constructor: n,
        type: "cartesian2d",
        dimensions: ["x", "y"],
        getBaseAxis: function() {
            return this.getAxesByScale("ordinal")[0] || this.getAxesByScale("time")[0] || this.getAxis("x")
        },
        containPoint: function(t) {
            var e = this.getAxis("x"),
                i = this.getAxis("y");
            return e.contain(e.toLocalCoord(t[0])) && i.contain(i.toLocalCoord(t[1]))
        },
        containData: function(t) {
            return this.getAxis("x").containData(t[0]) && this.getAxis("y").containData(t[1])
        },
        dataToPoints: function(t, e) {
            return t.mapArray(["x", "y"], function(t, e) {
                return this.dataToPoint([t, e])
            }, e, this)
        },
        dataToPoint: function(t, e) {
            var i = this.getAxis("x"),
                n = this.getAxis("y");
            return [i.toGlobalCoord(i.dataToCoord(t[0], e)), n.toGlobalCoord(n.dataToCoord(t[1], e))]
        },
        pointToData: function(t, e) {
            var i = this.getAxis("x"),
                n = this.getAxis("y");
            return [i.coordToData(i.toLocalCoord(t[0]), e), n.coordToData(n.toLocalCoord(t[1]), e)]
        },
        getOtherAxis: function(t) {
            return this.getAxis("x" === t.dim ? "y" : "x")
        }
    }, r.inherits(n, a), t.exports = n
}, function(t, e, i) {
    "use strict";
    function n(t) {
        return this._axes[t]
    }
    var r = i(509),
        a = function(t) {
            this._axes = {}, this._dimList = [], this.name = t || ""
        };
    a.prototype = {
        constructor: a,
        type: "cartesian",
        getAxis: function(t) {
            return this._axes[t]
        },
        getAxes: function() {
            return r.map(this._dimList, n, this)
        },
        getAxesByScale: function(t) {
            return t = t.toLowerCase(), r.filter(this.getAxes(), function(e) {
                return e.scale.type === t
            })
        },
        addAxis: function(t) {
            var e = t.dim;
            this._axes[e] = t, this._dimList.push(e)
        },
        dataToCoord: function(t) {
            return this._dataCoordConvert(t, "dataToCoord")
        },
        coordToData: function(t) {
            return this._dataCoordConvert(t, "coordToData")
        },
        _dataCoordConvert: function(t, e) {
            for (var i = this._dimList, n = t instanceof Array ? [] : {}, r = 0; r < i.length; r++) {
                var a = i[r],
                    o = this._axes[a];
                n[a] = o[e](t[a])
            }
            return n
        }
    }, t.exports = a
}, function(t, e, i) {
    var n = i(509),
        r = i(629),
        a = i(630),
        o = function(t, e, i, n, a) {
            r.call(this, t, e, i), this.type = n || "value", this.position = a || "bottom"
        };
    o.prototype = {
        constructor: o,
        index: 0,
        onZero: !1,
        model: null,
        isHorizontal: function() {
            var t = this.position;
            return "top" === t || "bottom" === t
        },
        getGlobalExtent: function() {
            var t = this.getExtent();
            return t[0] = this.toGlobalCoord(t[0]), t[1] = this.toGlobalCoord(t[1]), t
        },
        getLabelInterval: function() {
            var t = this._labelInterval;
            return t || (t = this._labelInterval = a(this)), t
        },
        isLabelIgnored: function(t) {
            if ("category" === this.type) {
                var e = this.getLabelInterval();
                return "function" == typeof e && !e(t, this.scale.getLabel(t)) || t % (e + 1)
            }
        },
        toLocalCoord: null,
        toGlobalCoord: null
    }, n.inherits(o, r), t.exports = o
}, function(t, e, i) {
    function n(t, e) {
        var i = t[1] - t[0],
            n = e,
            r = i / n / 2;
        t[0] += r, t[1] -= r
    }
    var r = i(512),
        a = r.linearMap,
        o = i(509),
        s = [0, 1],
        l = function(t, e, i) {
            this.dim = t, this.scale = e, this._extent = i || [0, 0], this.inverse = !1, this.onBand = !1
        };
    l.prototype = {
        constructor: l,
        contain: function(t) {
            var e = this._extent,
                i = Math.min(e[0], e[1]),
                n = Math.max(e[0], e[1]);
            return t >= i && t <= n
        },
        containData: function(t) {
            return this.contain(this.dataToCoord(t))
        },
        getExtent: function() {
            var t = this._extent.slice();
            return t
        },
        getPixelPrecision: function(t) {
            return r.getPixelPrecision(t || this.scale.getExtent(), this._extent)
        },
        setExtent: function(t, e) {
            var i = this._extent;
            i[0] = t, i[1] = e
        },
        dataToCoord: function(t, e) {
            var i = this._extent,
                r = this.scale;
            return t = r.normalize(t), this.onBand && "ordinal" === r.type && (i = i.slice(), n(i, r.count())), a(t, s, i, e)
        },
        coordToData: function(t, e) {
            var i = this._extent,
                r = this.scale;
            this.onBand && "ordinal" === r.type && (i = i.slice(), n(i, r.count()));
            var o = a(t, i, s, e);
            return this.scale.scale(o)
        },
        getTicksCoords: function(t) {
            if (this.onBand && !t) {
                for (var e = this.getBands(), i = [], n = 0; n < e.length; n++)
                    i.push(e[n][0]);
                return e[n - 1] && i.push(e[n - 1][1]), i
            }
            return o.map(this.scale.getTicks(), this.dataToCoord, this)
        },
        getLabelsCoords: function() {
            return o.map(this.scale.getTicks(), this.dataToCoord, this)
        },
        getBands: function() {
            for (var t = this.getExtent(), e = [], i = this.scale.count(), n = t[0], r = t[1], a = r - n, o = 0; o < i; o++)
                e.push([a * o / i + n, a * (o + 1) / i + n]);
            return e
        },
        getBandWidth: function() {
            var t = this._extent,
                e = this.scale.getExtent(),
                i = e[1] - e[0] + (this.onBand ? 1 : 0);
            0 === i && (i = 1);
            var n = Math.abs(t[1] - t[0]);
            return Math.abs(n) / i
        }
    }, t.exports = l
}, function(t, e, i) {
    "use strict";
    var n = i(509),
        r = i(620);
    t.exports = function(t) {
        var e = t.model,
            i = e.getModel("axisLabel"),
            a = i.get("interval");
        return "category" !== t.type || "auto" !== a ? "auto" === a ? 0 : a : r.getAxisLabelInterval(n.map(t.scale.getTicks(), t.dataToCoord, t), e.getFormattedLabels(), i.getModel("textStyle").getFont(), t.isHorizontal())
    }
}, function(t, e, i) {
    "use strict";
    i(632);
    var n = i(524);
    t.exports = n.extend({
        type: "grid",
        dependencies: ["xAxis", "yAxis"],
        layoutMode: "box",
        coordinateSystem: null,
        defaultOption: {
            show: !1,
            zlevel: 0,
            z: 0,
            left: "10%",
            top: 60,
            right: "10%",
            bottom: 60,
            containLabel: !1,
            backgroundColor: "rgba(0,0,0,0)",
            borderWidth: 1,
            borderColor: "#ccc"
        }
    })
}, function(t, e, i) {
    "use strict";
    function n(t, e) {
        return e.type || (e.data ? "category" : "value")
    }
    var r = i(524),
        a = i(509),
        o = i(633),
        s = r.extend({
            type: "cartesian2dAxis",
            axis: null,
            init: function() {
                s.superApply(this, "init", arguments), this.resetRange()
            },
            mergeOption: function() {
                s.superApply(this, "mergeOption", arguments), this.resetRange()
            },
            restoreData: function() {
                s.superApply(this, "restoreData", arguments), this.resetRange()
            },
            findGridModel: function() {
                return this.ecModel.queryComponents({
                    mainType: "grid",
                    index: this.get("gridIndex"),
                    id: this.get("gridId")
                })[0]
            }
        });
    a.merge(s.prototype, i(635)), a.merge(s.prototype, i(636));
    var l = {
        offset: 0
    };
    o("x", s, n, l), o("y", s, n, l), t.exports = s
}, function(t, e, i) {
    var n = i(634),
        r = i(509),
        a = i(524),
        o = i(526),
        s = ["value", "category", "time", "log"];
    t.exports = function(t, e, i, l) {
        r.each(s, function(a) {
            e.extend({
                type: t + "Axis." + a,
                mergeDefaultAndTheme: function(e, n) {
                    var s = this.layoutMode,
                        l = s ? o.getLayoutParams(e) : {},
                        c = n.getTheme();
                    r.merge(e, c.get(a + "Axis")), r.merge(e, this.getDefaultOption()), e.type = i(t, e), s && o.mergeLayoutParam(e, l, s)
                },
                defaultOption: r.mergeAll([{}, n[a + "Axis"], l], !0)
            })
        }), a.registerSubTypeDefaulter(t + "Axis", r.curry(i, t))
    }
}, function(t, e, i) {
    var n = i(509),
        r = {
            show: !0,
            zlevel: 0,
            z: 0,
            inverse: !1,
            name: "",
            nameLocation: "end",
            nameRotate: null,
            nameTruncate: {
                maxWidth: null,
                ellipsis: "...",
                placeholder: "."
            },
            nameTextStyle: {},
            nameGap: 15,
            silent: !1,
            triggerEvent: !1,
            tooltip: {
                show: !1
            },
            axisLine: {
                show: !0,
                onZero: !0,
                lineStyle: {
                    color: "#333",
                    width: 1,
                    type: "solid"
                }
            },
            axisTick: {
                show: !0,
                inside: !1,
                length: 5,
                lineStyle: {
                    width: 1
                }
            },
            axisLabel: {
                show: !0,
                inside: !1,
                rotate: 0,
                margin: 8,
                textStyle: {
                    fontSize: 12
                }
            },
            splitLine: {
                show: !0,
                lineStyle: {
                    color: ["#ccc"],
                    width: 1,
                    type: "solid"
                }
            },
            splitArea: {
                show: !1,
                areaStyle: {
                    color: ["rgba(250,250,250,0.3)", "rgba(200,200,200,0.3)"]
                }
            }
        },
        a = n.merge({
            boundaryGap: !0,
            splitLine: {
                show: !1
            },
            axisTick: {
                alignWithLabel: !1,
                interval: "auto"
            },
            axisLabel: {
                interval: "auto"
            }
        }, r),
        o = n.merge({
            boundaryGap: [0, 0],
            splitNumber: 5
        }, r),
        s = n.defaults({
            scale: !0,
            min: "dataMin",
            max: "dataMax"
        }, o),
        l = n.defaults({
            logBase: 10
        }, o);
    l.scale = !0, t.exports = {
        categoryAxis: a,
        valueAxis: o,
        timeAxis: s,
        logAxis: l
    }
}, function(t, e, i) {
    function n(t) {
        return o.isObject(t) && null != t.value ? t.value : t
    }
    function r() {
        return "category" === this.get("type") && o.map(this.get("data"), n)
    }
    function a() {
        return s.getFormattedLabels(this.axis, this.get("axisLabel.formatter"))
    }
    var o = i(509),
        s = i(620);
    t.exports = {
        getFormattedLabels: a,
        getCategories: r
    }
}, function(t, e) {
    t.exports = {
        getMin: function() {
            var t = this.option,
                e = null != t.rangeStart ? t.rangeStart : t.min;
            return e instanceof Date && (e = +e), e
        },
        getMax: function() {
            var t = this.option,
                e = null != t.rangeEnd ? t.rangeEnd : t.max;
            return e instanceof Date && (e = +e), e
        },
        getNeedCrossZero: function() {
            var t = this.option;
            return null == t.rangeStart && null == t.rangeEnd && !t.scale
        },
        setRange: function(t, e) {
            this.option.rangeStart = t, this.option.rangeEnd = e
        },
        resetRange: function() {
            this.option.rangeStart = this.option.rangeEnd = null
        }
    }
}, function(t, e, i) {
    "use strict";
    i(632), i(638)
}, function(t, e, i) {
    function n(t, e) {
        function i(t, e) {
            var i = n.getAxis(t);
            return i.toGlobalCoord(i.dataToCoord(0))
        }
        var n = t.coordinateSystem,
            r = e.axis,
            a = {},
            o = r.position,
            s = r.onZero ? "onZero" : o,
            l = r.dim,
            c = n.getRect(),
            u = [c.x, c.x + c.width, c.y, c.y + c.height],
            h = e.get("offset") || 0,
            d = {
                x: {
                    top: u[2] - h,
                    bottom: u[3] + h
                },
                y: {
                    left: u[0] - h,
                    right: u[1] + h
                }
            };
        d.x.onZero = Math.max(Math.min(i("y"), d.x.bottom), d.x.top), d.y.onZero = Math.max(Math.min(i("x"), d.y.right), d.y.left), a.position = ["y" === l ? d.y[s] : u[0], "x" === l ? d.x[s] : u[3]], a.rotation = Math.PI / 2 * ("x" === l ? 0 : 1);
        var p = {
            top: -1,
            bottom: 1,
            left: -1,
            right: 1
        };
        a.labelDirection = a.tickDirection = a.nameDirection = p[o], r.onZero && (a.labelOffset = d[l][o] - d[l].onZero), e.getModel("axisTick").get("inside") && (a.tickDirection = -a.tickDirection), e.getModel("axisLabel").get("inside") && (a.labelDirection = -a.labelDirection);
        var f = e.getModel("axisLabel").get("rotate");
        return a.labelRotation = "top" === s ? -f : f, a.labelInterval = r.getLabelInterval(), a.z2 = 1, a
    }
    var r = i(509),
        a = i(548),
        o = i(639),
        s = o.ifIgnoreOnTick,
        l = o.getInterval,
        c = ["axisLine", "axisLabel", "axisTick", "axisName"],
        u = ["splitArea", "splitLine"],
        h = i(506).extendComponentView({
            type: "axis",
            render: function(t, e) {
                this.group.removeAll();
                var i = this._axisGroup;
                if (this._axisGroup = new a.Group, this.group.add(this._axisGroup), t.get("show")) {
                    var s = t.findGridModel(),
                        l = n(s, t),
                        h = new o(t, l);
                    r.each(c, h.add, h), this._axisGroup.add(h.getGroup()), r.each(u, function(e) {
                        t.get(e + ".show") && this["_" + e](t, s, l.labelInterval)
                    }, this), a.groupTransition(i, this._axisGroup, t)
                }
            },
            _splitLine: function(t, e, i) {
                var n = t.axis,
                    o = t.getModel("splitLine"),
                    c = o.getModel("lineStyle"),
                    u = c.get("color"),
                    h = l(o, i);
                u = r.isArray(u) ? u : [u];
                for (var d = e.coordinateSystem.getRect(), p = n.isHorizontal(), f = 0, g = n.getTicksCoords(), m = n.scale.getTicks(), v = [], y = [], x = c.getLineStyle(), _ = 0; _ < g.length; _++)
                    if (!s(n, _, h)) {
                        var b = n.toGlobalCoord(g[_]);
                        p ? (v[0] = b, v[1] = d.y, y[0] = b, y[1] = d.y + d.height) : (v[0] = d.x, v[1] = b, y[0] = d.x + d.width, y[1] = b);
                        var w = f++ % u.length;
                        this._axisGroup.add(new a.Line(a.subPixelOptimizeLine({
                            anid: "line_" + m[_],
                            shape: {
                                x1: v[0],
                                y1: v[1],
                                x2: y[0],
                                y2: y[1]
                            },
                            style: r.defaults({
                                stroke: u[w]
                            }, x),
                            silent: !0
                        })))
                    }
            },
            _splitArea: function(t, e, i) {
                var n = t.axis,
                    o = t.getModel("splitArea"),
                    c = o.getModel("areaStyle"),
                    u = c.get("color"),
                    h = e.coordinateSystem.getRect(),
                    d = n.getTicksCoords(),
                    p = n.scale.getTicks(),
                    f = n.toGlobalCoord(d[0]),
                    g = n.toGlobalCoord(d[0]),
                    m = 0,
                    v = l(o, i),
                    y = c.getAreaStyle();
                u = r.isArray(u) ? u : [u];
                for (var x = 1; x < d.length; x++)
                    if (!s(n, x, v)) {
                        var _,
                            b,
                            w,
                            M,
                            S = n.toGlobalCoord(d[x]);
                        n.isHorizontal() ? (_ = f, b = h.y, w = S - _, M = h.height) : (_ = h.x, b = g, w = h.width, M = S - b);
                        var A = m++ % u.length;
                        this._axisGroup.add(new a.Rect({
                            anid: "area_" + p[x],
                            shape: {
                                x: _,
                                y: b,
                                width: w,
                                height: M
                            },
                            style: r.defaults({
                                fill: u[A]
                            }, y),
                            silent: !0
                        })), f = _ + w, g = b + M
                    }
            }
        });
    h.extend({
        type: "xAxis"
    }), h.extend({
        type: "yAxis"
    })
}, function(t, e, i) {
    function n(t) {
        var e = {
            componentType: t.mainType
        };
        return e[t.mainType + "Index"] = t.componentIndex, e
    }
    function r(t, e, i) {
        var n,
            r,
            a = d(e - t.rotation);
        return p(a) ? (r = i > 0 ? "top" : "bottom", n = "center") : p(a - v) ? (r = i > 0 ? "bottom" : "top", n = "center") : (r = "middle", n = a > 0 && a < v ? i > 0 ? "right" : "left" : i > 0 ? "left" : "right"), {
            rotation: a,
            textAlign: n,
            verticalAlign: r
        }
    }
    function a(t, e, i, n) {
        var r,
            a,
            o = d(i - t.rotation),
            s = n[0] > n[1],
            l = "start" === e && !s || "start" !== e && s;
        return p(o - v / 2) ? (a = l ? "bottom" : "top", r = "center") : p(o - 1.5 * v) ? (a = l ? "top" : "bottom", r = "center") : (a = "middle", r = o < 1.5 * v && o > v / 2 ? l ? "left" : "right" : l ? "right" : "left"), {
            rotation: o,
            textAlign: r,
            verticalAlign: a
        }
    }
    function o(t) {
        var e = t.get("tooltip");
        return t.get("silent") || !(t.get("triggerEvent") || e && e.show)
    }
    var s = i(509),
        l = i(511),
        c = i(548),
        u = i(517),
        h = i(512),
        d = h.remRadian,
        p = h.isRadianAroundZero,
        f = i(515),
        g = f.applyTransform,
        m = s.retrieve,
        v = Math.PI,
        y = function(t, e) {
            this.opt = e, this.axisModel = t, s.defaults(e, {
                labelOffset: 0,
                nameDirection: 1,
                tickDirection: 1,
                labelDirection: 1,
                silent: !0
            }), this.group = new c.Group;
            var i = new c.Group({
                position: e.position.slice(),
                rotation: e.rotation
            });
            i.updateTransform(), this._transform = i.transform, this._dumbGroup = i
        };
    y.prototype = {
        constructor: y,
        hasBuilder: function(t) {
            return !!x[t]
        },
        add: function(t) {
            x[t].call(this)
        },
        getGroup: function() {
            return this.group
        }
    };
    var x = {
            axisLine: function() {
                var t = this.opt,
                    e = this.axisModel;
                if (e.get("axisLine.show")) {
                    var i = this.axisModel.axis.getExtent(),
                        n = this._transform,
                        r = [i[0], 0],
                        a = [i[1], 0];
                    n && (g(r, r, n), g(a, a, n)), this.group.add(new c.Line(c.subPixelOptimizeLine({
                        anid: "line",
                        shape: {
                            x1: r[0],
                            y1: r[1],
                            x2: a[0],
                            y2: a[1]
                        },
                        style: s.extend({
                            lineCap: "round"
                        }, e.getModel("axisLine.lineStyle").getLineStyle()),
                        strokeContainThreshold: t.strokeContainThreshold || 5,
                        silent: !0,
                        z2: 1
                    })))
                }
            },
            axisTick: function() {
                var t = this.axisModel;
                if (t.get("axisTick.show"))
                    for (var e = t.axis, i = t.getModel("axisTick"), n = this.opt, r = i.getModel("lineStyle"), a = i.get("length"), o = b(i, n.labelInterval), l = e.getTicksCoords(i.get("alignWithLabel")), u = e.scale.getTicks(), h = [], d = [], p = this._transform, f = 0; f < l.length; f++)
                        if (!_(e, f, o)) {
                            var m = l[f];
                            h[0] = m, h[1] = 0, d[0] = m, d[1] = n.tickDirection * a, p && (g(h, h, p), g(d, d, p)), this.group.add(new c.Line(c.subPixelOptimizeLine({
                                anid: "tick_" + u[f],
                                shape: {
                                    x1: h[0],
                                    y1: h[1],
                                    x2: d[0],
                                    y2: d[1]
                                },
                                style: s.defaults(r.getLineStyle(), {
                                    stroke: t.get("axisLine.lineStyle.color")
                                }),
                                z2: 2,
                                silent: !0
                            })))
                        }
            },
            axisLabel: function() {
                function t(t, e) {
                    var i = t && t.getBoundingRect().clone(),
                        n = e && e.getBoundingRect().clone();
                    if (i && n)
                        return i.applyTransform(t.getLocalTransform()), n.applyTransform(e.getLocalTransform()), i.intersect(n)
                }
                var e = this.opt,
                    i = this.axisModel,
                    a = m(e.axisLabelShow, i.get("axisLabel.show"));
                if (a) {
                    var l = i.axis,
                        h = i.getModel("axisLabel"),
                        d = h.getModel("textStyle"),
                        p = h.get("margin"),
                        f = l.scale.getTicks(),
                        g = i.getFormattedLabels(),
                        y = m(e.labelRotation, h.get("rotate")) || 0;
                    y = y * v / 180;
                    var x = r(e, y, e.labelDirection),
                        b = i.get("data"),
                        w = [],
                        M = o(i),
                        S = i.get("triggerEvent");
                    if (s.each(f, function(t, r) {
                        if (!_(l, r, e.labelInterval)) {
                            var a = d;
                            b && b[t] && b[t].textStyle && (a = new u(b[t].textStyle, d, i.ecModel));
                            var o = a.getTextColor() || i.get("axisLine.lineStyle.color"),
                                s = l.dataToCoord(t),
                                h = [s, e.labelOffset + e.labelDirection * p],
                                f = l.scale.getLabel(t),
                                m = new c.Text({
                                    anid: "label_" + t,
                                    style: {
                                        text: g[r],
                                        textAlign: a.get("align", !0) || x.textAlign,
                                        textVerticalAlign: a.get("baseline", !0) || x.verticalAlign,
                                        textFont: a.getFont(),
                                        fill: "function" == typeof o ? o(f) : o
                                    },
                                    position: h,
                                    rotation: x.rotation,
                                    silent: M,
                                    z2: 10
                                });
                            S && (m.eventData = n(i), m.eventData.targetType = "axisLabel", m.eventData.value = f), this._dumbGroup.add(m), m.updateTransform(), w.push(m), this.group.add(m), m.decomposeTransform()
                        }
                    }, this), "category" !== l.type) {
                        if (i.getMin ? i.getMin() : i.get("min")) {
                            var A = w[0],
                                I = w[1];
                            t(A, I) && (A.ignore = !0)
                        }
                        if (i.getMax ? i.getMax() : i.get("max")) {
                            var D = w[w.length - 1],
                                k = w[w.length - 2];
                            t(k, D) && (D.ignore = !0)
                        }
                    }
                }
            },
            axisName: function() {
                var t = this.opt,
                    e = this.axisModel,
                    i = m(t.axisName, e.get("name"));
                if (i) {
                    var u,
                        h = e.get("nameLocation"),
                        d = t.nameDirection,
                        p = e.getModel("nameTextStyle"),
                        f = e.get("nameGap") || 0,
                        g = this.axisModel.axis.getExtent(),
                        y = g[0] > g[1] ? -1 : 1,
                        x = ["start" === h ? g[0] - y * f : "end" === h ? g[1] + y * f : (g[0] + g[1]) / 2, "middle" === h ? t.labelOffset + d * f : 0],
                        _ = e.get("nameRotate");
                    null != _ && (_ = _ * v / 180);
                    var b;
                    "middle" === h ? u = r(t, null != _ ? _ : t.rotation, d) : (u = a(t, h, _ || 0, g), b = t.axisNameAvailableWidth, null != b && (b = Math.abs(b / Math.sin(u.rotation)), !isFinite(b) && (b = null)));
                    var w = p.getFont(),
                        M = e.get("nameTruncate", !0) || {},
                        S = M.ellipsis,
                        A = m(M.maxWidth, b),
                        I = null != S && null != A ? l.truncateText(i, A, w, S, {
                            minChar: 2,
                            placeholder: M.placeholder
                        }) : i,
                        D = e.get("tooltip", !0),
                        k = e.mainType,
                        T = {
                            componentType: k,
                            name: i,
                            $vars: ["name"]
                        };
                    T[k + "Index"] = e.componentIndex;
                    var C = new c.Text({
                        anid: "name",
                        __fullText: i,
                        __truncatedText: I,
                        style: {
                            text: I,
                            textFont: w,
                            fill: p.getTextColor() || e.get("axisLine.lineStyle.color"),
                            textAlign: u.textAlign,
                            textVerticalAlign: u.verticalAlign
                        },
                        position: x,
                        rotation: u.rotation,
                        silent: o(e),
                        z2: 1,
                        tooltip: D && D.show ? s.extend({
                            content: i,
                            formatter: function() {
                                return i
                            },
                            formatterParams: T
                        }, D) : null
                    });
                    e.get("triggerEvent") && (C.eventData = n(e), C.eventData.targetType = "axisName", C.eventData.name = i), this._dumbGroup.add(C), C.updateTransform(), this.group.add(C), C.decomposeTransform()
                }
            }
        },
        _ = y.ifIgnoreOnTick = function(t, e, i) {
            var n,
                r = t.scale;
            return "ordinal" === r.type && ("function" == typeof i ? (n = r.getTicks()[e], !i(n, r.getLabel(n))) : e % (i + 1))
        },
        b = y.getInterval = function(t, e) {
            var i = t.get("interval");
            return null != i && "auto" != i || (i = e), i
        };
    t.exports = y
}, function(t, e, i) {
    var n = i(509);
    i(619), i(641), i(642);
    var r = i(644),
        a = i(506);
    a.registerLayout(n.curry(r, "bar")), a.registerVisual(function(t) {
        t.eachSeriesByType("bar", function(t) {
            var e = t.getData();
            e.setVisual("legendSymbol", "roundRect")
        })
    }), i(618)
}, function(t, e, i) {
    "use strict";
    var n = i(533),
        r = i(607);
    t.exports = n.extend({
        type: "series.bar",
        dependencies: ["grid", "polar"],
        getInitialData: function(t, e) {
            if (__DEV__) {
                var i = t.coordinateSystem;
                if ("cartesian2d" !== i)
                    throw new Error("Bar only support cartesian2d coordinateSystem")
            }
            return r(t.data, this, e)
        },
        getMarkerPosition: function(t) {
            var e = this.coordinateSystem;
            if (e) {
                var i = e.dataToPoint(t, !0),
                    n = this.getData(),
                    r = n.getLayout("offset"),
                    a = n.getLayout("size"),
                    o = e.getBaseAxis().isHorizontal() ? 0 : 1;
                return i[o] += r + a / 2, i
            }
            return [NaN, NaN]
        },
        brushSelector: "rect",
        defaultOption: {
            zlevel: 0,
            z: 2,
            coordinateSystem: "cartesian2d",
            legendHoverLink: !0,
            barMinHeight: 0,
            itemStyle: {
                normal: {},
                emphasis: {}
            }
        }
    })
}, function(t, e, i) {
    "use strict";
    function n(t, e) {
        var i = t.width > 0 ? 1 : -1,
            n = t.height > 0 ? 1 : -1;
        e = Math.min(e, Math.abs(t.width), Math.abs(t.height)), t.x += i * e / 2, t.y += n * e / 2, t.width -= i * e, t.height -= n * e
    }
    var r = i(509),
        a = i(548);
    r.extend(i(517).prototype, i(643)), t.exports = i(506).extendChartView({
        type: "bar",
        render: function(t, e, i) {
            var n = t.get("coordinateSystem");
            return "cartesian2d" === n && this._renderOnCartesian(t, e, i), this.group
        },
        dispose: r.noop,
        _renderOnCartesian: function(t, e, i) {
            function o(e, i) {
                var o = l.getItemLayout(e),
                    s = l.getItemModel(e).get(f) || 0;
                n(o, s);
                var c = new a.Rect({
                    shape: r.extend({}, o)
                });
                if (p) {
                    var u = c.shape,
                        h = d ? "height" : "width",
                        g = {};
                    u[h] = 0, g[h] = o[h], a[i ? "updateProps" : "initProps"](c, {
                        shape: g
                    }, t, e)
                }
                return c
            }
            var s = this.group,
                l = t.getData(),
                c = this._data,
                u = t.coordinateSystem,
                h = u.getBaseAxis(),
                d = h.isHorizontal(),
                p = t.get("animation"),
                f = ["itemStyle", "normal", "barBorderWidth"];
            l.diff(c).add(function(t) {
                if (l.hasValue(t)) {
                    var e = o(t);
                    l.setItemGraphicEl(t, e), s.add(e)
                }
            }).update(function(e, i) {
                var r = c.getItemGraphicEl(i);
                if (!l.hasValue(e))
                    return void s.remove(r);
                r || (r = o(e, !0));
                var u = l.getItemLayout(e),
                    h = l.getItemModel(e).get(f) || 0;
                n(u, h), a.updateProps(r, {
                    shape: u
                }, t, e), l.setItemGraphicEl(e, r), s.add(r)
            }).remove(function(e) {
                var i = c.getItemGraphicEl(e);
                i && (i.style.text = "", a.updateProps(i, {
                    shape: {
                        width: 0
                    }
                }, t, e, function() {
                    s.remove(i)
                }))
            }).execute(), this._updateStyle(t, l, d), this._data = l
        },
        _updateStyle: function(t, e, i) {
            function n(t, e, i, n, r) {
                a.setText(t, e, i), t.text = n, "outside" === t.textPosition && (t.textPosition = r)
            }
            e.eachItemGraphicEl(function(o, s) {
                var l = e.getItemModel(s),
                    c = e.getItemVisual(s, "color"),
                    u = e.getItemVisual(s, "opacity"),
                    h = e.getItemLayout(s),
                    d = l.getModel("itemStyle.normal"),
                    p = l.getModel("itemStyle.emphasis").getBarItemStyle();
                o.setShape("r", d.get("barBorderRadius") || 0), o.useStyle(r.defaults({
                    fill: c,
                    opacity: u
                }, d.getBarItemStyle()));
                var f = i ? h.height > 0 ? "bottom" : "top" : h.width > 0 ? "left" : "right",
                    g = l.getModel("label.normal"),
                    m = l.getModel("label.emphasis"),
                    v = o.style;
                g.get("show") ? n(v, g, c, r.retrieve(t.getFormattedLabel(s, "normal"), t.getRawValue(s)), f) : v.text = "", m.get("show") ? n(p, m, c, r.retrieve(t.getFormattedLabel(s, "emphasis"), t.getRawValue(s)), f) : p.text = "", a.setHoverStyle(o, p)
            })
        },
        remove: function(t, e) {
            var i = this.group;
            t.get("animation") ? this._data && this._data.eachItemGraphicEl(function(e) {
                e.style.text = "", a.updateProps(e, {
                    shape: {
                        width: 0
                    }
                }, t, e.dataIndex, function() {
                    i.remove(e)
                })
            }) : i.removeAll()
        }
    })
}, function(t, e, i) {
    var n = i(520)([["fill", "color"], ["stroke", "borderColor"], ["lineWidth", "borderWidth"], ["stroke", "barBorderColor"], ["lineWidth", "barBorderWidth"], ["opacity"], ["shadowBlur"], ["shadowOffsetX"], ["shadowOffsetY"], ["shadowColor"]]);
    t.exports = {
        getBarItemStyle: function(t) {
            var e = n.call(this, t);
            if (this.getBorderLineDash) {
                var i = this.getBorderLineDash();
                i && (e.lineDash = i)
            }
            return e
        }
    }
}, function(t, e, i) {
    "use strict";
    function n(t) {
        return t.get("stack") || "__ec_stack_" + t.seriesIndex
    }
    function r(t) {
        return t.dim + t.index
    }
    function a(t, e) {
        var i = {};
        s.each(t, function(t, e) {
            var a = t.getData(),
                o = t.coordinateSystem,
                s = o.getBaseAxis(),
                l = s.getExtent(),
                u = "category" === s.type ? s.getBandWidth() : Math.abs(l[1] - l[0]) / a.count(),
                h = i[r(s)] || {
                    bandWidth: u,
                    remainedWidth: u,
                    autoWidthCount: 0,
                    categoryGap: "20%",
                    gap: "30%",
                    stacks: {}
                },
                d = h.stacks;
            i[r(s)] = h;
            var p = n(t);
            d[p] || h.autoWidthCount++, d[p] = d[p] || {
                width: 0,
                maxWidth: 0
            };
            var f = c(t.get("barWidth"), u),
                g = c(t.get("barMaxWidth"), u),
                m = t.get("barGap"),
                v = t.get("barCategoryGap");
            f && !d[p].width && (f = Math.min(h.remainedWidth, f), d[p].width = f, h.remainedWidth -= f), g && (d[p].maxWidth = g), null != m && (h.gap = m), null != v && (h.categoryGap = v)
        });
        var a = {};
        return s.each(i, function(t, e) {
            a[e] = {};
            var i = t.stacks,
                n = t.bandWidth,
                r = c(t.categoryGap, n),
                o = c(t.gap, 1),
                l = t.remainedWidth,
                u = t.autoWidthCount,
                h = (l - r) / (u + (u - 1) * o);
            h = Math.max(h, 0), s.each(i, function(t, e) {
                var i = t.maxWidth;
                !t.width && i && i < h && (i = Math.min(i, l), l -= i, t.width = i, u--)
            }), h = (l - r) / (u + (u - 1) * o), h = Math.max(h, 0);
            var d,
                p = 0;
            s.each(i, function(t, e) {
                t.width || (t.width = h), d = t, p += t.width * (1 + o)
            }), d && (p -= d.width * o);
            var f = -p / 2;
            s.each(i, function(t, i) {
                a[e][i] = a[e][i] || {
                    offset: f,
                    width: t.width
                }, f += t.width * (1 + o)
            })
        }), a
    }
    function o(t, e, i) {
        var o = a(s.filter(e.getSeriesByType(t), function(t) {
                return !e.isSeriesFiltered(t) && t.coordinateSystem && "cartesian2d" === t.coordinateSystem.type
            })),
            l = {},
            c = {};
        e.eachSeriesByType(t, function(t) {
            var e = t.getData(),
                i = t.coordinateSystem,
                a = i.getBaseAxis(),
                s = n(t),
                u = o[r(a)][s],
                h = u.offset,
                d = u.width,
                p = i.getOtherAxis(a),
                f = t.get("barMinHeight") || 0,
                g = a.onZero ? p.toGlobalCoord(p.dataToCoord(0)) : p.getGlobalExtent()[0],
                m = i.dataToPoints(e, !0);
            l[s] = l[s] || [], c[s] = c[s] || [], e.setLayout({
                offset: h,
                size: d
            }), e.each(p.dim, function(t, i) {
                if (!isNaN(t)) {
                    l[s][i] || (l[s][i] = {
                        p: g,
                        n: g
                    }, c[s][i] = {
                        p: g,
                        n: g
                    });
                    var n,
                        r,
                        a,
                        o,
                        u = t >= 0 ? "p" : "n",
                        v = m[i],
                        y = l[s][i][u],
                        x = c[s][i][u];
                    p.isHorizontal() ? (n = y, r = v[1] + h, a = v[0] - x, o = d, c[s][i][u] += a, Math.abs(a) < f && (a = (a < 0 ? -1 : 1) * f), l[s][i][u] += a) : (n = v[0] + h, r = y, a = d, o = v[1] - x, c[s][i][u] += o, Math.abs(o) < f && (o = (o <= 0 ? -1 : 1) * f), l[s][i][u] += o), e.setItemLayout(i, {
                        x: n,
                        y: r,
                        width: a,
                        height: o
                    })
                }
            }, !0)
        }, this)
    }
    var s = i(509),
        l = i(512),
        c = l.parsePercent;
    t.exports = o
}, function(t, e, i) {
    var n = i(509),
        r = i(506);
    i(646), i(648), i(649)("pie", [{
        type: "pieToggleSelect",
        event: "pieselectchanged",
        method: "toggleSelected"
    }, {
        type: "pieSelect",
        event: "pieselected",
        method: "select"
    }, {
        type: "pieUnSelect",
        event: "pieunselected",
        method: "unSelect"
    }]), r.registerVisual(n.curry(i(650), "pie")), r.registerLayout(n.curry(i(651), "pie")), r.registerProcessor(n.curry(i(653), "pie"))
}, function(t, e, i) {
    "use strict";
    var n = i(603),
        r = i(509),
        a = i(510),
        o = i(608),
        s = i(647),
        l = i(506).extendSeriesModel({
            type: "series.pie",
            init: function(t) {
                l.superApply(this, "init", arguments), this.legendDataProvider = function() {
                    return this._dataBeforeProcessed
                }, this.updateSelectedMap(t.data), this._defaultLabelLine(t)
            },
            mergeOption: function(t) {
                l.superCall(this, "mergeOption", t), this.updateSelectedMap(this.option.data)
            },
            getInitialData: function(t, e) {
                var i = o(["value"], t.data),
                    r = new n(i, this);
                return r.initData(t.data), r
            },
            getDataParams: function(t) {
                var e = this._data,
                    i = l.superCall(this, "getDataParams", t),
                    n = e.getSum("value");
                return i.percent = n ? +(e.get("value", t) / n * 100).toFixed(2) : 0, i.$vars.push("percent"), i
            },
            _defaultLabelLine: function(t) {
                a.defaultEmphasis(t.labelLine, ["show"]);
                var e = t.labelLine.normal,
                    i = t.labelLine.emphasis;
                e.show = e.show && t.label.normal.show, i.show = i.show && t.label.emphasis.show
            },
            defaultOption: {
                zlevel: 0,
                z: 2,
                legendHoverLink: !0,
                hoverAnimation: !0,
                center: ["50%", "50%"],
                radius: [0, "75%"],
                clockwise: !0,
                startAngle: 90,
                minAngle: 0,
                selectedOffset: 10,
                avoidLabelOverlap: !0,
                label: {
                    normal: {
                        rotate: !1,
                        show: !0,
                        position: "outer"
                    },
                    emphasis: {}
                },
                labelLine: {
                    normal: {
                        show: !0,
                        length: 15,
                        length2: 15,
                        smooth: !1,
                        lineStyle: {
                            width: 1,
                            type: "solid"
                        }
                    }
                },
                itemStyle: {
                    normal: {
                        borderWidth: 1
                    },
                    emphasis: {}
                },
                animationEasing: "cubicOut",
                data: []
            }
        });
    r.mixin(l, s), t.exports = l
}, function(t, e, i) {
    var n = i(509);
    t.exports = {
        updateSelectedMap: function(t) {
            this._selectTargetMap = n.reduce(t || [], function(t, e) {
                return t[e.name] = e, t
            }, {})
        },
        select: function(t) {
            var e = this._selectTargetMap,
                i = e[t],
                r = this.get("selectedMode");
            "single" === r && n.each(e, function(t) {
                t.selected = !1
            }), i && (i.selected = !0)
        },
        unSelect: function(t) {
            var e = this._selectTargetMap[t];
            e && (e.selected = !1)
        },
        toggleSelected: function(t) {
            var e = this._selectTargetMap[t];
            if (null != e)
                return this[e.selected ? "unSelect" : "select"](t), e.selected
        },
        isSelected: function(t) {
            var e = this._selectTargetMap[t];
            return e && e.selected
        }
    }
}, function(t, e, i) {
    function n(t, e, i, n) {
        var a = e.getData(),
            o = this.dataIndex,
            s = a.getName(o),
            l = e.get("selectedOffset");
        n.dispatchAction({
            type: "pieToggleSelect",
            from: t,
            name: s,
            seriesId: e.id
        }), a.each(function(t) {
            r(a.getItemGraphicEl(t), a.getItemLayout(t), e.isSelected(a.getName(t)), l, i)
        })
    }
    function r(t, e, i, n, r) {
        var a = (e.startAngle + e.endAngle) / 2,
            o = Math.cos(a),
            s = Math.sin(a),
            l = i ? n : 0,
            c = [o * l, s * l];
        r ? t.animate().when(200, {
            position: c
        }).start("bounceOut") : t.attr("position", c)
    }
    function a(t, e) {
        function i() {
            a.ignore = a.hoverIgnore, o.ignore = o.hoverIgnore
        }
        function n() {
            a.ignore = a.normalIgnore, o.ignore = o.normalIgnore
        }
        s.Group.call(this);
        var r = new s.Sector({
                z2: 2
            }),
            a = new s.Polyline,
            o = new s.Text;
        this.add(r), this.add(a), this.add(o), this.updateData(t, e, !0), this.on("emphasis", i).on("normal", n).on("mouseover", i).on("mouseout", n)
    }
    function o(t, e, i, n, r) {
        var a = n.getModel("textStyle"),
            o = "inside" === r || "inner" === r;
        return {
            fill: a.getTextColor() || (o ? "#fff" : t.getItemVisual(e, "color")),
            opacity: t.getItemVisual(e, "opacity"),
            textFont: a.getFont(),
            text: l.retrieve(t.hostModel.getFormattedLabel(e, i), t.getName(e))
        }
    }
    var s = i(548),
        l = i(509),
        c = a.prototype;
    c.updateData = function(t, e, i) {
        function n() {
            o.stopAnimation(!0), o.animateTo({
                shape: {
                    r: h.r + 10
                }
            }, 300, "elasticOut")
        }
        function a() {
            o.stopAnimation(!0), o.animateTo({
                shape: {
                    r: h.r
                }
            }, 300, "elasticOut")
        }
        var o = this.childAt(0),
            c = t.hostModel,
            u = t.getItemModel(e),
            h = t.getItemLayout(e),
            d = l.extend({}, h);
        d.label = null, i ? (o.setShape(d), o.shape.endAngle = h.startAngle, s.updateProps(o, {
            shape: {
                endAngle: h.endAngle
            }
        }, c, e)) : s.updateProps(o, {
            shape: d
        }, c, e);
        var p = u.getModel("itemStyle"),
            f = t.getItemVisual(e, "color");
        o.useStyle(l.defaults({
            lineJoin: "bevel",
            fill: f
        }, p.getModel("normal").getItemStyle())), o.hoverStyle = p.getModel("emphasis").getItemStyle(), r(this, t.getItemLayout(e), u.get("selected"), c.get("selectedOffset"), c.get("animation")), o.off("mouseover").off("mouseout").off("emphasis").off("normal"), u.get("hoverAnimation") && c.ifEnableAnimation() && o.on("mouseover", n).on("mouseout", a).on("emphasis", n).on("normal", a), this._updateLabel(t, e), s.setHoverStyle(this)
    }, c._updateLabel = function(t, e) {
        var i = this.childAt(1),
            n = this.childAt(2),
            r = t.hostModel,
            a = t.getItemModel(e),
            l = t.getItemLayout(e),
            c = l.label,
            u = t.getItemVisual(e, "color");
        s.updateProps(i, {
            shape: {
                points: c.linePoints || [[c.x, c.y], [c.x, c.y], [c.x, c.y]]
            }
        }, r, e), s.updateProps(n, {
            style: {
                x: c.x,
                y: c.y
            }
        }, r, e), n.attr({
            style: {
                textVerticalAlign: c.verticalAlign,
                textAlign: c.textAlign,
                textFont: c.font
            },
            rotation: c.rotation,
            origin: [c.x, c.y],
            z2: 10
        });
        var h = a.getModel("label.normal"),
            d = a.getModel("label.emphasis"),
            p = a.getModel("labelLine.normal"),
            f = a.getModel("labelLine.emphasis"),
            g = h.get("position") || d.get("position");
        n.setStyle(o(t, e, "normal", h, g)), n.ignore = n.normalIgnore = !h.get("show"), n.hoverIgnore = !d.get("show"), i.ignore = i.normalIgnore = !p.get("show"), i.hoverIgnore = !f.get("show"), i.setStyle({
            stroke: u,
            opacity: t.getItemVisual(e, "opacity")
        }), i.setStyle(p.getModel("lineStyle").getLineStyle()), n.hoverStyle = o(t, e, "emphasis", d, g), i.hoverStyle = f.getModel("lineStyle").getLineStyle();
        var m = p.get("smooth");
        m && m === !0 && (m = .4), i.setShape({
            smooth: m
        })
    }, l.inherits(a, s.Group);
    var u = i(547).extend({
        type: "pie",
        init: function() {
            var t = new s.Group;
            this._sectorGroup = t
        },
        render: function(t, e, i, r) {
            if (!r || r.from !== this.uid) {
                var o = t.getData(),
                    s = this._data,
                    c = this.group,
                    u = e.get("animation"),
                    h = !s,
                    d = l.curry(n, this.uid, t, u, i),
                    p = t.get("selectedMode");
                if (o.diff(s).add(function(t) {
                    var e = new a(o, t);
                    h && e.eachChild(function(t) {
                        t.stopAnimation(!0)
                    }), p && e.on("click", d), o.setItemGraphicEl(t, e), c.add(e)
                }).update(function(t, e) {
                    var i = s.getItemGraphicEl(e);
                    i.updateData(o, t), i.off("click"), p && i.on("click", d), c.add(i), o.setItemGraphicEl(t, i)
                }).remove(function(t) {
                    var e = s.getItemGraphicEl(t);
                    c.remove(e)
                }).execute(), u && h && o.count() > 0) {
                    var f = o.getItemLayout(0),
                        g = Math.max(i.getWidth(), i.getHeight()) / 2,
                        m = l.bind(c.removeClipPath, c);
                    c.setClipPath(this._createClipPath(f.cx, f.cy, g, f.startAngle, f.clockwise, m, t))
                }
                this._data = o
            }
        },
        dispose: function() {},
        _createClipPath: function(t, e, i, n, r, a, o) {
            var l = new s.Sector({
                shape: {
                    cx: t,
                    cy: e,
                    r0: 0,
                    r: i,
                    startAngle: n,
                    endAngle: n,
                    clockwise: r
                }
            });
            return s.initProps(l, {
                shape: {
                    endAngle: n + (r ? 1 : -1) * Math.PI * 2
                }
            }, o, a), l
        },
        containPoint: function(t, e) {
            var i = e.getData(),
                n = i.getItemLayout(0);
            if (n) {
                var r = t[0] - n.cx,
                    a = t[1] - n.cy,
                    o = Math.sqrt(r * r + a * a);
                return o <= n.r && o >= n.r0
            }
        }
    });
    t.exports = u
}, function(t, e, i) {
    var n = i(506),
        r = i(509);
    t.exports = function(t, e) {
        r.each(e, function(e) {
            e.update = "updateView", n.registerAction(e, function(i, n) {
                var r = {};
                return n.eachComponent({
                    mainType: "series",
                    subType: t,
                    query: i
                }, function(t) {
                    t[e.method] && t[e.method](i.name);
                    var n = t.getData();
                    n.each(function(e) {
                        var i = n.getName(e);
                        r[i] = t.isSelected(i) || !1
                    })
                }), {
                    name: i.name,
                    selected: r
                }
            })
        })
    }
}, function(t, e) {
    t.exports = function(t, e) {
        var i = {};
        e.eachRawSeriesByType(t, function(t) {
            var n = t.getRawData(),
                r = {};
            if (!e.isSeriesFiltered(t)) {
                var a = t.getData();
                a.each(function(t) {
                    var e = a.getRawIndex(t);
                    r[e] = t
                }), n.each(function(e) {
                    var o = n.getItemModel(e),
                        s = r[e],
                        l = null != s && a.getItemVisual(s, "color", !0);
                    if (l)
                        n.setItemVisual(e, "color", l);
                    else {
                        var c = o.get("itemStyle.normal.color") || t.getColorFromPalette(n.getName(e), i);
                        n.setItemVisual(e, "color", c), null != s && a.setItemVisual(s, "color", c)
                    }
                })
            }
        })
    }
}, function(t, e, i) {
    var n = i(512),
        r = n.parsePercent,
        a = i(652),
        o = i(509),
        s = 2 * Math.PI,
        l = Math.PI / 180;
    t.exports = function(t, e, i, c) {
        e.eachSeriesByType(t, function(t) {
            var e = t.get("center"),
                c = t.get("radius");
            o.isArray(c) || (c = [0, c]), o.isArray(e) || (e = [e, e]);
            var u = i.getWidth(),
                h = i.getHeight(),
                d = Math.min(u, h),
                p = r(e[0], u),
                f = r(e[1], h),
                g = r(c[0], d / 2),
                m = r(c[1], d / 2),
                v = t.getData(),
                y = -t.get("startAngle") * l,
                x = t.get("minAngle") * l,
                _ = v.getSum("value"),
                b = Math.PI / (_ || v.count()) * 2,
                w = t.get("clockwise"),
                M = t.get("roseType"),
                S = v.getDataExtent("value");
            S[0] = 0;
            var A = s,
                I = 0,
                D = y,
                k = w ? 1 : -1;
            if (v.each("value", function(t, e) {
                var i;
                i = "area" !== M ? 0 === _ ? b : t * b : s / (v.count() || 1), i < x ? (i = x, A -= x) : I += t;
                var r = D + k * i;
                v.setItemLayout(e, {
                    angle: i,
                    startAngle: D,
                    endAngle: r,
                    clockwise: w,
                    cx: p,
                    cy: f,
                    r0: g,
                    r: M ? n.linearMap(t, S, [g, m]) : m
                }), D = r
            }, !0), A < s)
                if (A <= .001) {
                    var T = s / v.count();
                    v.each(function(t) {
                        var e = v.getItemLayout(t);
                        e.startAngle = y + k * t * T, e.endAngle = y + k * (t + 1) * T
                    })
                } else
                    b = A / I, D = y, v.each("value", function(t, e) {
                        var i = v.getItemLayout(e),
                            n = i.angle === x ? x : t * b;
                        i.startAngle = D, i.endAngle = D + k * n, D += k * n
                    });
            a(t, m, u, h)
        })
    }
}, function(t, e, i) {
    "use strict";
    function n(t, e, i, n, r, a, o) {
        function s(e, i, n, r) {
            for (var a = e; a < i; a++)
                if (t[a].y += n, a > e && a + 1 < i && t[a + 1].y > t[a].y + t[a].height)
                    return void l(a, n / 2);
            l(i - 1, n / 2)
        }
        function l(e, i) {
            for (var n = e; n >= 0 && (t[n].y -= i, !(n > 0 && t[n].y > t[n - 1].y + t[n - 1].height)); n--)
                ;
        }
        function c(t, e, i, n, r, a) {
            for (var o = a > 0 ? e ? Number.MAX_VALUE : 0 : e ? Number.MAX_VALUE : 0, s = 0, l = t.length; s < l; s++)
                if ("center" !== t[s].position) {
                    var c = Math.abs(t[s].y - n),
                        u = t[s].len,
                        h = t[s].len2,
                        d = c < r + u ? Math.sqrt((r + u + h) * (r + u + h) - c * c) : Math.abs(t[s].x - i);
                    e && d >= o && (d = o - 10), !e && d <= o && (d = o + 10), t[s].x = i + d * a, o = d
                }
        }
        t.sort(function(t, e) {
            return t.y - e.y
        });
        for (var u, h = 0, d = t.length, p = [], f = [], g = 0; g < d; g++)
            u = t[g].y - h, u < 0 && s(g, d, -u, r), h = t[g].y + t[g].height;
        o - h < 0 && l(d - 1, h - o);
        for (var g = 0; g < d; g++)
            t[g].y >= i ? f.push(t[g]) : p.push(t[g]);
        c(p, !1, e, i, n, r), c(f, !0, e, i, n, r)
    }
    function r(t, e, i, r, a, o) {
        for (var s = [], l = [], c = 0; c < t.length; c++)
            t[c].x < e ? s.push(t[c]) : l.push(t[c]);
        n(l, e, i, r, 1, a, o), n(s, e, i, r, -1, a, o);
        for (var c = 0; c < t.length; c++) {
            var u = t[c].linePoints;
            if (u) {
                var h = u[1][0] - u[2][0];
                t[c].x < e ? u[2][0] = t[c].x + 3 : u[2][0] = t[c].x - 3, u[1][1] = u[2][1] = t[c].y, u[1][0] = u[2][0] + h
            }
        }
    }
    var a = i(513);
    t.exports = function(t, e, i, n) {
        var o,
            s,
            l = t.getData(),
            c = [],
            u = !1;
        l.each(function(i) {
            var n,
                r,
                h,
                d,
                p = l.getItemLayout(i),
                f = l.getItemModel(i),
                g = f.getModel("label.normal"),
                m = g.get("position") || f.get("label.emphasis.position"),
                v = f.getModel("labelLine.normal"),
                y = v.get("length"),
                x = v.get("length2"),
                _ = (p.startAngle + p.endAngle) / 2,
                b = Math.cos(_),
                w = Math.sin(_);
            o = p.cx, s = p.cy;
            var M = "inside" === m || "inner" === m;
            if ("center" === m)
                n = p.cx, r = p.cy, d = "center";
            else {
                var S = (M ? (p.r + p.r0) / 2 * b : p.r * b) + o,
                    A = (M ? (p.r + p.r0) / 2 * w : p.r * w) + s;
                if (n = S + 3 * b, r = A + 3 * w, !M) {
                    var I = S + b * (y + e - p.r),
                        D = A + w * (y + e - p.r),
                        k = I + (b < 0 ? -1 : 1) * x,
                        T = D;
                    n = k + (b < 0 ? -5 : 5), r = T, h = [[S, A], [I, D], [k, T]]
                }
                d = M ? "center" : b > 0 ? "left" : "right"
            }
            var C = g.getModel("textStyle").getFont(),
                L = g.get("rotate") ? b < 0 ? -_ + Math.PI : -_ : 0,
                P = t.getFormattedLabel(i, "normal") || l.getName(i),
                E = a.getBoundingRect(P, C, d, "top");
            u = !!L, p.label = {
                x: n,
                y: r,
                position: m,
                height: E.height,
                len: y,
                len2: x,
                linePoints: h,
                textAlign: d,
                verticalAlign: "middle",
                font: C,
                rotation: L
            }, M || c.push(p.label)
        }), !u && t.get("avoidLabelOverlap") && r(c, o, s, e, i, n)
    }
}, function(t, e) {
    t.exports = function(t, e) {
        var i = e.findComponents({
            mainType: "legend"
        });
        i && i.length && e.eachSeriesByType(t, function(t) {
            var e = t.getData();
            e.filterSelf(function(t) {
                for (var n = e.getName(t), r = 0; r < i.length; r++)
                    if (!i[r].isSelected(n))
                        return !1;
                return !0
            }, this)
        }, this)
    }
}, function(t, e, i) {
    var n = i(509),
        r = i(506);
    i(655), i(656), r.registerVisual(n.curry(i(615), "scatter", "circle", null)), r.registerLayout(n.curry(i(616), "scatter")), i(618)
}, function(t, e, i) {
    "use strict";
    var n = i(607),
        r = i(533);
    t.exports = r.extend({
        type: "series.scatter",
        dependencies: ["grid", "polar"],
        getInitialData: function(t, e) {
            var i = n(t.data, this, e);
            return i
        },
        brushSelector: "point",
        defaultOption: {
            coordinateSystem: "cartesian2d",
            zlevel: 0,
            z: 2,
            legendHoverLink: !0,
            hoverAnimation: !0,
            symbolSize: 10,
            large: !1,
            largeThreshold: 2e3,
            itemStyle: {
                normal: {
                    opacity: .8
                }
            }
        }
    })
}, function(t, e, i) {
    var n = i(610),
        r = i(657);
    i(506).extendChartView({
        type: "scatter",
        init: function() {
            this._normalSymbolDraw = new n, this._largeSymbolDraw = new r
        },
        render: function(t, e, i) {
            var n = t.getData(),
                r = this._largeSymbolDraw,
                a = this._normalSymbolDraw,
                o = this.group,
                s = t.get("large") && n.count() > t.get("largeThreshold") ? r : a;
            this._symbolDraw = s, s.updateData(n), o.add(s.group), o.remove(s === r ? a.group : r.group)
        },
        updateLayout: function(t) {
            this._symbolDraw.updateLayout(t)
        },
        remove: function(t, e) {
            this._symbolDraw && this._symbolDraw.remove(e, !0)
        },
        dispose: function() {}
    })
}, function(t, e, i) {
    function n() {
        this.group = new r.Group, this._symbolEl = new o({})
    }
    var r = i(548),
        a = i(612),
        o = r.extendShape({
            shape: {
                points: null,
                sizes: null
            },
            symbolProxy: null,
            buildPath: function(t, e) {
                for (var i = e.points, n = e.sizes, r = this.symbolProxy, a = r.shape, o = 0; o < i.length; o++) {
                    var s = i[o],
                        l = n[o];
                    l[0] < 4 ? t.rect(s[0] - l[0] / 2, s[1] - l[1] / 2, l[0], l[1]) : (a.x = s[0] - l[0] / 2, a.y = s[1] - l[1] / 2, a.width = l[0], a.height = l[1], r.buildPath(t, a, !0))
                }
            },
            findDataIndex: function(t, e) {
                for (var i = this.shape, n = i.points, r = i.sizes, a = n.length - 1; a >= 0; a--) {
                    var o = n[a],
                        s = r[a],
                        l = o[0] - s[0] / 2,
                        c = o[1] - s[1] / 2;
                    if (t >= l && e >= c && t <= l + s[0] && e <= c + s[1])
                        return a
                }
                return -1
            }
        }),
        s = n.prototype;
    s.updateData = function(t) {
        this.group.removeAll();
        var e = this._symbolEl,
            i = t.hostModel;
        e.setShape({
            points: t.mapArray(t.getItemLayout),
            sizes: t.mapArray(function(e) {
                var i = t.getItemVisual(e, "symbolSize");
                return i instanceof Array || (i = [i, i]), i
            })
        }), e.symbolProxy = a.createSymbol(t.getVisual("symbol"), 0, 0, 0, 0), e.setColor = e.symbolProxy.setColor, e.useStyle(i.getModel("itemStyle.normal").getItemStyle(["color"]));
        var n = t.getVisual("color");
        n && e.setColor(n), e.seriesIndex = i.seriesIndex, e.on("mousemove", function(t) {
            e.dataIndex = null;
            var i = e.findDataIndex(t.offsetX, t.offsetY);
            i > 0 && (e.dataIndex = i)
        }), this.group.add(e)
    }, s.updateLayout = function(t) {
        var e = t.getData();
        this._symbolEl.setShape({
            points: e.mapArray(e.getItemLayout)
        })
    }, s.remove = function() {
        this.group.removeAll()
    }, t.exports = n
}, function(t, e, i) {
    var n = i(509),
        r = i(506);
    i(659), i(664), i(665), r.registerVisual(n.curry(i(650), "radar")), r.registerVisual(n.curry(i(615), "radar", "circle", null)), r.registerLayout(i(666)), r.registerProcessor(n.curry(i(653), "radar")), r.registerPreprocessor(i(667))
}, function(t, e, i) {
    i(660), i(662), i(663)
}, function(t, e, i) {
    function n(t, e, i) {
        this._model = t, this.dimensions = [], this._indicatorAxes = r.map(t.getIndicatorModels(), function(t, e) {
            var i = "indicator_" + e,
                n = new a(i, new o);
            return n.name = t.get("name"), n.model = t, t.axis = n, this.dimensions.push(i), n
        }, this), this.resize(t, i), this.cx, this.cy, this.r, this.startAngle
    }
    var r = i(509),
        a = i(661),
        o = i(623),
        s = i(512),
        l = i(620);
    n.prototype.getIndicatorAxes = function() {
        return this._indicatorAxes
    }, n.prototype.dataToPoint = function(t, e) {
        var i = this._indicatorAxes[e];
        return this.coordToPoint(i.dataToCoord(t), e)
    }, n.prototype.coordToPoint = function(t, e) {
        var i = this._indicatorAxes[e],
            n = i.angle,
            r = this.cx + t * Math.cos(n),
            a = this.cy - t * Math.sin(n);
        return [r, a]
    }, n.prototype.pointToData = function(t) {
        var e = t[0] - this.cx,
            i = t[1] - this.cy,
            n = Math.sqrt(e * e + i * i);
        e /= n, i /= n;
        for (var r, a = Math.atan2(-i, e), o = 1 / 0, s = -1, l = 0; l < this._indicatorAxes.length; l++) {
            var c = this._indicatorAxes[l],
                u = Math.abs(a - c.angle);
            u < o && (r = c, s = l, o = u)
        }
        return [s, +(r && r.coodToData(n))]
    }, n.prototype.resize = function(t, e) {
        var i = t.get("center"),
            n = e.getWidth(),
            a = e.getHeight(),
            o = Math.min(n, a) / 2;
        this.cx = s.parsePercent(i[0], n), this.cy = s.parsePercent(i[1], a), this.startAngle = t.get("startAngle") * Math.PI / 180, this.r = s.parsePercent(t.get("radius"), o), r.each(this._indicatorAxes, function(t, e) {
            t.setExtent(0, this.r);
            var i = this.startAngle + e * Math.PI * 2 / this._indicatorAxes.length;
            i = Math.atan2(Math.sin(i), Math.cos(i)), t.angle = i
        }, this)
    }, n.prototype.update = function(t, e) {
        function i(t) {
            var e = Math.pow(10, Math.floor(Math.log(t) / Math.LN10)),
                i = t / e;
            return 2 === i ? i = 5 : i *= 2, i * e
        }
        var n = this._indicatorAxes,
            a = this._model;
        r.each(n, function(t) {
            t.scale.setExtent(1 / 0, -(1 / 0))
        }), t.eachSeriesByType("radar", function(e, i) {
            if ("radar" === e.get("coordinateSystem") && t.getComponent("radar", e.get("radarIndex")) === a) {
                var o = e.getData();
                r.each(n, function(t) {
                    t.scale.unionExtent(o.getDataExtent(t.dim))
                })
            }
        }, this);
        var o = a.get("splitNumber");
        r.each(n, function(t, e) {
            var n = l.getScaleExtent(t, t.model);
            l.niceScaleExtent(t, t.model);
            var r = t.model,
                a = t.scale,
                c = r.get("min"),
                u = r.get("max"),
                h = a.getInterval();
            if (null != c && null != u)
                a.setInterval((u - c) / o);
            else if (null != c) {
                var d;
                do d = c + h * o, a.setExtent(+c, d), a.setInterval(h), h = i(h);
                while (d < n[1] && isFinite(d) && isFinite(n[1]))
            } else if (null != u) {
                var p;
                do p = u - h * o, a.setExtent(p, +u), a.setInterval(h), h = i(h);
                while (p > n[0] && isFinite(p) && isFinite(n[0]))
            } else {
                var f = a.getTicks().length - 1;
                f > o && (h = i(h));
                var g = Math.round((n[0] + n[1]) / 2 / h) * h,
                    m = Math.round(o / 2);
                a.setExtent(s.round(g - m * h), s.round(g + (o - m) * h)), a.setInterval(h)
            }
        })
    }, n.dimensions = [], n.create = function(t, e) {
        var i = [];
        return t.eachComponent("radar", function(r) {
            var a = new n(r, t, e);
            i.push(a), r.coordinateSystem = a
        }), t.eachSeriesByType("radar", function(t) {
            "radar" === t.get("coordinateSystem") && (t.coordinateSystem = i[t.get("radarIndex") || 0])
        }), i
    }, i(531).register("radar", n), t.exports = n
}, function(t, e, i) {
    function n(t, e, i) {
        a.call(this, t, e, i), this.type = "value", this.angle = 0, this.name = "", this.model
    }
    var r = i(509),
        a = i(629);
    r.inherits(n, a), t.exports = n
}, function(t, e, i) {
    function n(t, e) {
        return s.defaults({
            show: e
        }, t)
    }
    var r = i(634),
        a = r.valueAxis,
        o = i(517),
        s = i(509),
        l = i(635),
        c = i(506).extendComponentModel({
            type: "radar",
            optionUpdated: function() {
                var t = this.get("boundaryGap"),
                    e = this.get("splitNumber"),
                    i = this.get("scale"),
                    n = this.get("axisLine"),
                    r = this.get("axisTick"),
                    a = this.get("axisLabel"),
                    c = this.get("name.textStyle"),
                    u = this.get("name.show"),
                    h = this.get("name.formatter"),
                    d = this.get("nameGap"),
                    p = this.get("triggerEvent"),
                    f = s.map(this.get("indicator") || [], function(f) {
                        if (null != f.max && f.max > 0 && !f.min ? f.min = 0 : null != f.min && f.min < 0 && !f.max && (f.max = 0), f = s.merge(s.clone(f), {
                            boundaryGap: t,
                            splitNumber: e,
                            scale: i,
                            axisLine: n,
                            axisTick: r,
                            axisLabel: a,
                            name: f.text,
                            nameLocation: "end",
                            nameGap: d,
                            nameTextStyle: c,
                            triggerEvent: p
                        }, !1), u || (f.name = ""), "string" == typeof h) {
                            var g = f.name;
                            f.name = h.replace("{value}", null != g ? g : "")
                        } else
                            "function" == typeof h && (f.name = h(f.name, f));
                        var m = s.extend(new o(f, null, this.ecModel), l);
                        return m.mainType = "radar", m.componentIndex = this.componentIndex, m
                    }, this);
                this.getIndicatorModels = function() {
                    return f
                }
            },
            defaultOption: {
                zlevel: 0,
                z: 0,
                center: ["50%", "50%"],
                radius: "75%",
                startAngle: 90,
                name: {
                    show: !0
                },
                boundaryGap: [0, 0],
                splitNumber: 5,
                nameGap: 15,
                scale: !1,
                shape: "polygon",
                axisLine: s.merge({
                    lineStyle: {
                        color: "#bbb"
                    }
                }, a.axisLine),
                axisLabel: n(a.axisLabel, !1),
                axisTick: n(a.axisTick, !1),
                splitLine: n(a.splitLine, !0),
                splitArea: n(a.splitArea, !0),
                indicator: []
            }
        });
    t.exports = c
}, function(t, e, i) {
    var n = i(639),
        r = i(509),
        a = i(548),
        o = ["axisLine", "axisLabel", "axisTick", "axisName"];
    t.exports = i(506).extendComponentView({
        type: "radar",
        render: function(t, e, i) {
            var n = this.group;
            n.removeAll(), this._buildAxes(t), this._buildSplitLineAndArea(t)
        },
        _buildAxes: function(t) {
            var e = t.coordinateSystem,
                i = e.getIndicatorAxes(),
                a = r.map(i, function(t) {
                    var i = new n(t.model, {
                        position: [e.cx, e.cy],
                        rotation: t.angle,
                        labelDirection: -1,
                        tickDirection: -1,
                        nameDirection: 1
                    });
                    return i
                });
            r.each(a, function(t) {
                r.each(o, t.add, t), this.group.add(t.getGroup())
            }, this)
        },
        _buildSplitLineAndArea: function(t) {
            function e(t, e, i) {
                var n = i % e.length;
                return t[n] = t[n] || [], n
            }
            var i = t.coordinateSystem,
                n = t.get("splitNumber"),
                o = i.getIndicatorAxes();
            if (o.length) {
                var s = t.get("shape"),
                    l = t.getModel("splitLine"),
                    c = t.getModel("splitArea"),
                    u = l.getModel("lineStyle"),
                    h = c.getModel("areaStyle"),
                    d = l.get("show"),
                    p = c.get("show"),
                    f = u.get("color"),
                    g = h.get("color");
                f = r.isArray(f) ? f : [f], g = r.isArray(g) ? g : [g];
                var m = [],
                    v = [];
                if ("circle" === s)
                    for (var y = o[0].getTicksCoords(), x = i.cx, _ = i.cy, b = 0; b < y.length; b++) {
                        if (d) {
                            var w = e(m, f, b);
                            m[w].push(new a.Circle({
                                shape: {
                                    cx: x,
                                    cy: _,
                                    r: y[b]
                                }
                            }))
                        }
                        if (p && b < y.length - 1) {
                            var w = e(v, g, b);
                            v[w].push(new a.Ring({
                                shape: {
                                    cx: x,
                                    cy: _,
                                    r0: y[b],
                                    r: y[b + 1]
                                }
                            }))
                        }
                    }
                else
                    for (var M = r.map(o, function(t, e) {
                            var n = t.getTicksCoords();
                            return r.map(n, function(t) {
                                return i.coordToPoint(t, e)
                            })
                        }), S = [], b = 0; b <= n; b++) {
                        for (var A = [], I = 0; I < o.length; I++)
                            A.push(M[I][b]);
                        if (A[0] ? A.push(A[0].slice()) : __DEV__ && console.error("Can't draw value axis " + b), d) {
                            var w = e(m, f, b);
                            m[w].push(new a.Polyline({
                                shape: {
                                    points: A
                                }
                            }))
                        }
                        if (p && S) {
                            var w = e(v, g, b - 1);
                            v[w].push(new a.Polygon({
                                shape: {
                                    points: A.concat(S)
                                }
                            }))
                        }
                        S = A.slice().reverse()
                    }
                var D = u.getLineStyle(),
                    k = h.getAreaStyle();
                r.each(v, function(t, e) {
                    this.group.add(a.mergePath(t, {
                        style: r.defaults({
                            stroke: "none",
                            fill: g[e % g.length]
                        }, k),
                        silent: !0
                    }))
                }, this), r.each(m, function(t, e) {
                    this.group.add(a.mergePath(t, {
                        style: r.defaults({
                            fill: "none",
                            stroke: f[e % f.length]
                        }, D),
                        silent: !0
                    }))
                }, this)
            }
        }
    })
}, function(t, e, i) {
    "use strict";
    var n = i(533),
        r = i(603),
        a = i(608),
        o = i(509),
        s = n.extend({
            type: "series.radar",
            dependencies: ["radar"],
            init: function(t) {
                s.superApply(this, "init", arguments), this.legendDataProvider = function() {
                    return this._dataBeforeProcessed
                }
            },
            getInitialData: function(t, e) {
                var i = t.data || [],
                    n = a([], i, [], "indicator_"),
                    o = new r(n, this);
                return o.initData(i), o
            },
            formatTooltip: function(t) {
                var e = this.getRawValue(t),
                    i = this.coordinateSystem,
                    n = i.getIndicatorAxes();
                return ("" == this._data.getName(t) ? this.name : this._data.getName(t)) + "<br/>" + o.map(n, function(t, i) {
                    return t.name + " : " + e[i]
                }).join("<br />")
            },
            defaultOption: {
                zlevel: 0,
                z: 2,
                coordinateSystem: "radar",
                legendHoverLink: !0,
                radarIndex: 0,
                lineStyle: {
                    normal: {
                        width: 2,
                        type: "solid"
                    }
                },
                label: {
                    normal: {
                        position: "top"
                    }
                },
                symbol: "emptyCircle",
                symbolSize: 4
            }
        });
    t.exports = s
}, function(t, e, i) {
    function n(t) {
        return a.isArray(t) || (t = [+t, +t]), t
    }
    var r = i(548),
        a = i(509),
        o = i(612);
    t.exports = i(506).extendChartView({
        type: "radar",
        render: function(t, e, i) {
            function s(t, e) {
                var i = t.getItemVisual(e, "symbol") || "circle",
                    r = t.getItemVisual(e, "color");
                if ("none" !== i) {
                    var a = o.createSymbol(i, -.5, -.5, 1, 1, r);
                    return a.attr({
                        style: {
                            strokeNoScale: !0
                        },
                        z2: 100,
                        scale: n(t.getItemVisual(e, "symbolSize"))
                    }), a
                }
            }
            function l(e, i, n, a, o, l) {
                n.removeAll();
                for (var c = 0; c < i.length - 1; c++) {
                    var u = s(a, o);
                    u && (u.__dimIdx = c, e[c] ? (u.attr("position", e[c]), r[l ? "initProps" : "updateProps"](u, {
                        position: i[c]
                    }, t, o)) : u.attr("position", i[c]), n.add(u))
                }
            }
            function c(t) {
                return a.map(t, function(t) {
                    return [u.cx, u.cy]
                })
            }
            var u = t.coordinateSystem,
                h = this.group,
                d = t.getData(),
                p = this._data;
            d.diff(p).add(function(e) {
                var i = d.getItemLayout(e);
                if (i) {
                    var n = new r.Polygon,
                        a = new r.Polyline,
                        o = {
                            shape: {
                                points: i
                            }
                        };
                    n.shape.points = c(i), a.shape.points = c(i), r.initProps(n, o, t, e), r.initProps(a, o, t, e);
                    var s = new r.Group,
                        u = new r.Group;
                    s.add(a), s.add(n), s.add(u), l(a.shape.points, i, u, d, e, !0), d.setItemGraphicEl(e, s)
                }
            }).update(function(e, i) {
                var n = p.getItemGraphicEl(i),
                    a = n.childAt(0),
                    o = n.childAt(1),
                    s = n.childAt(2),
                    c = {
                        shape: {
                            points: d.getItemLayout(e)
                        }
                    };
                c.shape.points && (l(a.shape.points, c.shape.points, s, d, e, !1), r.updateProps(a, c, t), r.updateProps(o, c, t), d.setItemGraphicEl(e, n))
            }).remove(function(t) {
                h.remove(p.getItemGraphicEl(t))
            }).execute(), d.eachItemGraphicEl(function(e, i) {
                function n() {
                    c.attr("ignore", v)
                }
                function o() {
                    c.attr("ignore", m)
                }
                var s = d.getItemModel(i),
                    l = e.childAt(0),
                    c = e.childAt(1),
                    u = e.childAt(2),
                    p = d.getItemVisual(i, "color");
                h.add(e), l.useStyle(a.defaults(s.getModel("lineStyle.normal").getLineStyle(), {
                    fill: "none",
                    stroke: p
                })), l.hoverStyle = s.getModel("lineStyle.emphasis").getLineStyle();
                var f = s.getModel("areaStyle.normal"),
                    g = s.getModel("areaStyle.emphasis"),
                    m = f.isEmpty() && f.parentModel.isEmpty(),
                    v = g.isEmpty() && g.parentModel.isEmpty();
                v = v && m, c.ignore = m, c.useStyle(a.defaults(f.getAreaStyle(), {
                    fill: p,
                    opacity: .7
                })), c.hoverStyle = g.getAreaStyle();
                var y = s.getModel("itemStyle.normal").getItemStyle(["color"]),
                    x = s.getModel("itemStyle.emphasis").getItemStyle(),
                    _ = s.getModel("label.normal"),
                    b = s.getModel("label.emphasis");
                u.eachChild(function(e) {
                    e.setStyle(y), e.hoverStyle = a.clone(x);
                    var n = d.get(d.dimensions[e.__dimIdx], i);
                    r.setText(e.style, _, p), e.setStyle({
                        text: _.get("show") ? a.retrieve(t.getFormattedLabel(i, "normal", null, e.__dimIdx), n) : ""
                    }), r.setText(e.hoverStyle, b, p), e.hoverStyle.text = b.get("show") ? a.retrieve(t.getFormattedLabel(i, "emphasis", null, e.__dimIdx), n) : ""
                }), e.off("mouseover").off("mouseout").off("normal").off("emphasis"), e.on("emphasis", n).on("mouseover", n).on("normal", o).on("mouseout", o), r.setHoverStyle(e)
            }), this._data = d
        },
        remove: function() {
            this.group.removeAll(), this._data = null
        },
        dispose: function() {}
    })
}, function(t, e) {
    t.exports = function(t) {
        t.eachSeriesByType("radar", function(t) {
            function e(t, e) {
                n[e] = n[e] || [], n[e][a] = r.dataToPoint(t, a)
            }
            var i = t.getData(),
                n = [],
                r = t.coordinateSystem;
            if (r) {
                for (var a = 0; a < r.getIndicatorAxes().length; a++) {
                    var o = i.dimensions[a];
                    i.each(o, e)
                }
                i.each(function(t) {
                    n[t][0] && n[t].push(n[t][0].slice()), i.setItemLayout(t, n[t])
                })
            }
        })
    }
}, function(t, e, i) {
    var n = i(509);
    t.exports = function(t) {
        var e = t.polar;
        if (e) {
            n.isArray(e) || (e = [e]);
            var i = [];
            n.each(e, function(e, r) {
                e.indicator ? (e.type && !e.shape && (e.shape = e.type), t.radar = t.radar || [], n.isArray(t.radar) || (t.radar = [t.radar]), t.radar.push(e)) : i.push(e)
            }), t.polar = i
        }
        n.each(t.series, function(t) {
            "radar" === t.type && t.polarIndex && (t.radarIndex = t.polarIndex)
        })
    }
}, function(t, e, i) {
    var n = i(506),
        r = n.PRIORITY;
    i(669), i(679), i(683), i(670), n.registerLayout(i(685)), n.registerVisual(i(686)), n.registerProcessor(r.PROCESSOR.STATISTIC, i(687)), n.registerPreprocessor(i(688)), i(649)("map", [{
        type: "mapToggleSelect",
        event: "mapselectchanged",
        method: "toggleSelected"
    }, {
        type: "mapSelect",
        event: "mapselected",
        method: "select"
    }, {
        type: "mapUnSelect",
        event: "mapunselected",
        method: "unSelect"
    }])
}, function(t, e, i) {
    var n = i(603),
        r = i(533),
        a = i(509),
        o = i(608),
        s = i(511),
        l = s.encodeHTML,
        c = s.addCommas,
        u = i(647),
        h = i(670),
        d = r.extend({
            type: "series.map",
            layoutMode: "box",
            needsDrawMap: !1,
            seriesGroup: [],
            init: function(t) {
                t = this._fillOption(t, t.map), this.option = t, d.superApply(this, "init", arguments), this.updateSelectedMap(t.data)
            },
            getInitialData: function(t) {
                var e = o(["value"], t.data || []),
                    i = new n(e, this);
                return i.initData(t.data), i
            },
            mergeOption: function(t) {
                t.data && (t = this._fillOption(t, this.option.map)), d.superCall(this, "mergeOption", t), this.updateSelectedMap(this.option.data)
            },
            _fillOption: function(t, e) {
                return t = a.extend({}, t), t.data = h.getFilledRegions(t.data, e), t
            },
            getRawValue: function(t) {
                return this._data.get("value", t)
            },
            getRegionModel: function(t) {
                var e = this.getData();
                return e.getItemModel(e.indexOfName(t))
            },
            formatTooltip: function(t) {
                for (var e = this.getData(), i = c(this.getRawValue(t)), n = e.getName(t), r = this.seriesGroup, a = [], o = 0; o < r.length; o++) {
                    var s = r[o].originalData.indexOfName(n);
                    isNaN(r[o].originalData.get("value", s)) || a.push(l(r[o].name))
                }
                return a.join(", ") + "<br />" + n + " : " + i
            },
            getTooltipPosition: function(t) {
                if (null != t) {
                    var e = this.getData().getName(t),
                        i = this.coordinateSystem,
                        n = i.getRegion(e);
                    return n && i.dataToPoint(n.center)
                }
            },
            setZoom: function(t) {
                this.option.zoom = t
            },
            setCenter: function(t) {
                this.option.center = t
            },
            defaultOption: {
                zlevel: 0,
                z: 2,
                coordinateSystem: "geo",
                map: "china",
                left: "center",
                top: "center",
                aspectScale: .75,
                showLegendSymbol: !0,
                dataRangeHoverLink: !0,
                center: null,
                zoom: 1,
                scaleLimit: null,
                label: {
                    normal: {
                        show: !1,
                        textStyle: {
                            color: "#000"
                        }
                    },
                    emphasis: {
                        show: !0,
                        textStyle: {
                            color: "rgb(100,0,0)"
                        }
                    }
                },
                itemStyle: {
                    normal: {
                        borderWidth: .5,
                        borderColor: "#444",
                        areaColor: "#eee"
                    },
                    emphasis: {
                        areaColor: "rgba(255,215,0,0.8)"
                    }
                }
            }
        });
    a.mixin(d, u), t.exports = d
}, function(t, e, i) {
    function n(t, e) {
        var i,
            n = this.getBoundingRect(),
            r = t.get("layoutCenter"),
            a = t.get("layoutSize"),
            s = e.getWidth(),
            c = e.getHeight(),
            u = t.get("aspectScale") || .75,
            h = n.width / n.height * u,
            d = !1;
        r && a && (r = [l.parsePercent(r[0], s), l.parsePercent(r[1], c)], a = l.parsePercent(a, Math.min(s, c)), isNaN(r[0]) || isNaN(r[1]) || isNaN(a) ? __DEV__ && console.warn("Given layoutCenter or layoutSize data are invalid. Use left/top/width/height instead.") : d = !0);
        var p;
        if (d) {
            var p = {};
            h > 1 ? (p.width = a, p.height = a / h) : (p.height = a, p.width = a * h), p.y = r[1] - p.height / 2, p.x = r[0] - p.width / 2
        } else
            i = t.getBoxLayoutParams(), i.aspect = h, p = o.getLayoutRect(i, {
                width: s,
                height: c
            });
        this.setViewRect(p.x, p.y, p.width, p.height), this.setCenter(t.get("center")), this.setZoom(t.get("zoom"))
    }
    function r(t, e) {
        s.each(e.get("geoCoord"), function(e, i) {
            t.addGeoCoord(i, e)
        })
    }
    var a = i(671),
        o = i(526),
        s = i(509),
        l = i(512),
        c = {};
    if (__DEV__)
        var u = function(t) {
            console.error("Map " + t + " not exists. You can download map file on http://echarts.baidu.com/download-map.html")
        };
    var h = {
            dimensions: a.prototype.dimensions,
            create: function(t, e) {
                var i = [];
                t.eachComponent("geo", function(t, o) {
                    var s = t.get("map"),
                        l = c[s];
                    __DEV__ && (l || u(s));
                    var h = new a(s + o, s, l && l.geoJson, l && l.specialAreas, t.get("nameMap"));
                    h.zoomLimit = t.get("scaleLimit"), i.push(h), r(h, t), t.coordinateSystem = h, h.model = t, h.resize = n, h.resize(t, e)
                }), t.eachSeries(function(t) {
                    var e = t.get("coordinateSystem");
                    if ("geo" === e) {
                        var n = t.get("geoIndex") || 0;
                        t.coordinateSystem = i[n]
                    }
                });
                var o = {};
                return t.eachSeriesByType("map", function(t) {
                    var e = t.get("map");
                    o[e] = o[e] || [], o[e].push(t)
                }), s.each(o, function(t, o) {
                    var l = c[o];
                    __DEV__ && (l || u(t[0].get("map")));
                    var h = s.map(t, function(t) {
                            return t.get("nameMap")
                        }),
                        d = new a(o, o, l && l.geoJson, l && l.specialAreas, s.mergeAll(h));
                    d.zoomLimit = s.retrieve.apply(null, s.map(t, function(t) {
                        return t.get("scaleLimit")
                    })), i.push(d), d.resize = n, d.resize(t[0], e), s.each(t, function(t) {
                        t.coordinateSystem = d, r(d, t)
                    })
                }), i
            },
            registerMap: function(t, e, i) {
                e.geoJson && !e.features && (i = e.specialAreas, e = e.geoJson), "string" == typeof e && (e = "undefined" != typeof JSON && JSON.parse ? JSON.parse(e) : new Function("return (" + e + ");")()), c[t] = {
                    geoJson: e,
                    specialAreas: i
                }
            },
            getMap: function(t) {
                return c[t]
            },
            getFilledRegions: function(t, e) {
                var i = (t || []).slice(),
                    n = h.getMap(e),
                    r = n && n.geoJson;
                if (!r)
                    return __DEV__ && u(e), t;
                for (var a = {}, o = r.features, s = 0; s < i.length; s++)
                    a[i[s].name] = i[s];
                for (var s = 0; s < o.length; s++) {
                    var l = o[s].properties.name;
                    a[l] || i.push({
                        name: l
                    })
                }
                return i
            }
        },
        d = i(506);
    d.registerMap = h.registerMap, d.getMap = h.getMap, d.loadMap = function() {}, d.registerCoordinateSystem("geo", h), t.exports = h
}, function(t, e, i) {
    function n(t, e, i, n, r) {
        l.call(this, t), this.map = e, this._nameCoordMap = {}, this.loadGeoJson(i, n, r)
    }
    function r(t, e, i, n) {
        var r = i.geoModel,
            a = i.seriesModel,
            o = r ? r.coordinateSystem : a ? a.coordinateSystem || (a.getReferringComponents("geo")[0] || {}).coordinateSystem : null;
        return o === this ? o[t](n) : null
    }
    var a = i(672),
        o = i(509),
        s = i(514),
        l = i(675),
        c = [i(676), i(677), i(678)];
    n.prototype = {
        constructor: n,
        type: "geo",
        dimensions: ["lng", "lat"],
        containCoord: function(t) {
            for (var e = this.regions, i = 0; i < e.length; i++)
                if (e[i].contain(t))
                    return !0;
            return !1
        },
        loadGeoJson: function(t, e, i) {
            try {
                this.regions = t ? a(t) : []
            } catch (t) {
                throw "Invalid geoJson format\n" + t
            }
            e = e || {}, i = i || {};
            for (var n = this.regions, r = {}, s = 0; s < n.length; s++) {
                var l = n[s].name;
                l = i[l] || l, n[s].name = l, r[l] = n[s], this.addGeoCoord(l, n[s].center);
                var u = e[l];
                u && n[s].transformTo(u.left, u.top, u.width, u.height)
            }
            this._regionsMap = r, this._rect = null, o.each(c, function(t) {
                t(this)
            }, this)
        },
        transformTo: function(t, e, i, n) {
            var r = this.getBoundingRect();
            r = r.clone(), r.y = -r.y - r.height;
            var a = this._viewTransform;
            a.transform = r.calculateTransform(new s(t, e, i, n)), a.decomposeTransform();
            var o = a.scale;
            o[1] = -o[1], a.updateTransform(), this._updateTransform()
        },
        getRegion: function(t) {
            return this._regionsMap[t]
        },
        getRegionByCoord: function(t) {
            for (var e = this.regions, i = 0; i < e.length; i++)
                if (e[i].contain(t))
                    return e[i]
        },
        addGeoCoord: function(t, e) {
            this._nameCoordMap[t] = e
        },
        getGeoCoord: function(t) {
            return this._nameCoordMap[t]
        },
        getBoundingRect: function() {
            if (this._rect)
                return this._rect;
            for (var t, e = this.regions, i = 0; i < e.length; i++) {
                var n = e[i].getBoundingRect();
                t = t || n.clone(), t.union(n)
            }
            return this._rect = t || new s(0, 0, 0, 0)
        },
        dataToPoints: function(t) {
            var e = [];
            return t.mapArray(["lng", "lat"], function(t, i) {
                return e[0] = t, e[1] = i, this.dataToPoint(e)
            }, this)
        },
        dataToPoint: function(t) {
            if ("string" == typeof t && (t = this.getGeoCoord(t)), t)
                return l.prototype.dataToPoint.call(this, t)
        },
        convertToPixel: o.curry(r, "dataToPoint"),
        convertFromPixel: o.curry(r, "pointToData")
    }, o.mixin(n, l), t.exports = n
}, function(t, e, i) {
    function n(t) {
        if (!t.UTF8Encoding)
            return t;
        for (var e = t.features, i = 0; i < e.length; i++)
            for (var n = e[i], a = n.geometry, o = a.coordinates, s = a.encodeOffsets, l = 0; l < o.length; l++) {
                var c = o[l];
                if ("Polygon" === a.type)
                    o[l] = r(c, s[l]);
                else if ("MultiPolygon" === a.type)
                    for (var u = 0; u < c.length; u++) {
                        var h = c[u];
                        c[u] = r(h, s[l][u])
                    }
            }
        return t.UTF8Encoding = !1, t
    }
    function r(t, e) {
        for (var i = [], n = e[0], r = e[1], a = 0; a < t.length; a += 2) {
            var o = t.charCodeAt(a) - 64,
                s = t.charCodeAt(a + 1) - 64;
            o = o >> 1 ^ -(1 & o), s = s >> 1 ^ -(1 & s), o += n, s += r, n = o, r = s, i.push([o / 1024, s / 1024])
        }
        return i
    }
    function a(t) {
        for (var e = [], i = 0; i < t.length; i++)
            for (var n = 0; n < t[i].length; n++)
                e.push(t[i][n]);
        return e
    }
    var o = i(509),
        s = i(673);
    t.exports = function(t) {
        return n(t), o.map(o.filter(t.features, function(t) {
            return t.geometry && t.properties
        }), function(t) {
            var e = t.properties,
                i = t.geometry,
                n = i.coordinates;
            return "MultiPolygon" === i.type && (n = a(n)), new s(e.name, n, e.cp)
        })
    }
}, function(t, e, i) {
    function n(t, e, i) {
        if (this.name = t, this.contours = e, i)
            i = [i[0], i[1]];
        else {
            var n = this.getBoundingRect();
            i = [n.x + n.width / 2, n.y + n.height / 2]
        }
        this.center = i
    }
    var r = i(674),
        a = i(514),
        o = i(556),
        s = i(515);
    n.prototype = {
        constructor: n,
        getBoundingRect: function() {
            var t = this._rect;
            if (t)
                return t;
            for (var e = Number.MAX_VALUE, i = [e, e], n = [-e, -e], r = [], l = [], c = this.contours, u = 0; u < c.length; u++)
                o.fromPoints(c[u], r, l), s.min(i, i, r), s.max(n, n, l);
            return 0 === u && (i[0] = i[1] = n[0] = n[1] = 0), this._rect = new a(i[0], i[1], n[0] - i[0], n[1] - i[1])
        },
        contain: function(t) {
            var e = this.getBoundingRect(),
                i = this.contours;
            if (e.contain(t[0], t[1]))
                for (var n = 0, a = i.length; n < a; n++)
                    if (r.contain(i[n], t[0], t[1]))
                        return !0;
            return !1
        },
        transformTo: function(t, e, i, n) {
            var r = this.getBoundingRect(),
                o = r.width / r.height;
            i ? n || (n = i / o) : i = o * n;
            for (var l = new a(t, e, i, n), c = r.calculateTransform(l), u = this.contours, h = 0; h < u.length; h++)
                for (var d = 0; d < u[h].length; d++)
                    s.applyTransform(u[h][d], u[h][d], c);
            r = this._rect, r.copy(l), this.center = [r.x + r.width / 2, r.y + r.height / 2]
        }
    }, t.exports = n
}, function(t, e, i) {
    function n(t, e) {
        return Math.abs(t - e) < o
    }
    function r(t, e, i) {
        var r = 0,
            o = t[0];
        if (!o)
            return !1;
        for (var s = 1; s < t.length; s++) {
            var l = t[s];
            r += a(o[0], o[1], l[0], l[1], e, i), o = l
        }
        var c = t[0];
        return n(o[0], c[0]) && n(o[1], c[1]) || (r += a(o[0], o[1], c[0], c[1], e, i)), 0 !== r
    }
    var a = i(563),
        o = 1e-8;
    t.exports = {
        contain: r
    }
}, function(t, e, i) {
    function n() {
        l.call(this)
    }
    function r(t) {
        this.name = t, this.zoomLimit, l.call(this), this._roamTransform = new n, this._viewTransform = new n, this._center, this._zoom
    }
    function a(t, e, i, n) {
        var r = i.seriesModel,
            a = r ? r.coordinateSystem : null;
        return a === this ? a[t](n) : null
    }
    var o = i(515),
        s = i(516),
        l = i(539),
        c = i(509),
        u = i(514),
        h = o.applyTransform;
    c.mixin(n, l), r.prototype = {
        constructor: r,
        type: "view",
        dimensions: ["x", "y"],
        setBoundingRect: function(t, e, i, n) {
            return this._rect = new u(t, e, i, n), this._rect
        },
        getBoundingRect: function() {
            return this._rect
        },
        setViewRect: function(t, e, i, n) {
            this.transformTo(t, e, i, n), this._viewRect = new u(t, e, i, n)
        },
        transformTo: function(t, e, i, n) {
            var r = this.getBoundingRect(),
                a = this._viewTransform;
            a.transform = r.calculateTransform(new u(t, e, i, n)), a.decomposeTransform(), this._updateTransform()
        },
        setCenter: function(t) {
            t && (this._center = t, this._updateCenterAndZoom())
        },
        setZoom: function(t) {
            t = t || 1;
            var e = this.zoomLimit;
            e && (null != e.max && (t = Math.min(e.max, t)), null != e.min && (t = Math.max(e.min, t))), this._zoom = t, this._updateCenterAndZoom()
        },
        getDefaultCenter: function() {
            var t = this.getBoundingRect(),
                e = t.x + t.width / 2,
                i = t.y + t.height / 2;
            return [e, i]
        },
        getCenter: function() {
            return this._center || this.getDefaultCenter()
        },
        getZoom: function() {
            return this._zoom || 1
        },
        getRoamTransform: function() {
            return this._roamTransform
        },
        _updateCenterAndZoom: function() {
            var t = this._viewTransform.getLocalTransform(),
                e = this._roamTransform,
                i = this.getDefaultCenter(),
                n = this.getCenter(),
                r = this.getZoom();
            n = o.applyTransform([], n, t), i = o.applyTransform([], i, t), e.origin = n, e.position = [i[0] - n[0], i[1] - n[1]], e.scale = [r, r], this._updateTransform()
        },
        _updateTransform: function() {
            var t = this._roamTransform,
                e = this._viewTransform;
            e.parent = t, t.updateTransform(), e.updateTransform(), e.transform && s.copy(this.transform || (this.transform = []), e.transform), this.transform ? (this.invTransform = this.invTransform || [], s.invert(this.invTransform, this.transform)) : this.invTransform = null, this.decomposeTransform()
        },
        getViewRect: function() {
            return this._viewRect
        },
        getViewRectAfterRoam: function() {
            var t = this.getBoundingRect().clone();
            return t.applyTransform(this.transform), t
        },
        dataToPoint: function(t) {
            var e = this.transform;
            return e ? h([], t, e) : [t[0], t[1]]
        },
        pointToData: function(t) {
            var e = this.invTransform;
            return e ? h([], t, e) : [t[0], t[1]]
        },
        convertToPixel: c.curry(a, "dataToPoint"),
        convertFromPixel: c.curry(a, "pointToData"),
        containPoint: function(t) {
            return this.getViewRectAfterRoam().contain(t[0], t[1])
        }
    }, c.mixin(r, l), t.exports = r
}, function(t, e, i) {
    for (var n = i(673), r = [126, 25], a = [[[0, 3.5], [7, 11.2], [15, 11.9], [30, 7], [42, .7], [52, .7], [56, 7.7], [59, .7], [64, .7], [64, 0], [5, 0], [0, 3.5]], [[13, 16.1], [19, 14.7], [16, 21.7], [11, 23.1], [13, 16.1]], [[12, 32.2], [14, 38.5], [15, 38.5], [13, 32.2], [12, 32.2]], [[16, 47.6], [12, 53.2], [13, 53.2], [18, 47.6], [16, 47.6]], [[6, 64.4], [8, 70], [9, 70], [8, 64.4], [6, 64.4]], [[23, 82.6], [29, 79.8], [30, 79.8], [25, 82.6], [23, 82.6]], [[37, 70.7], [43, 62.3], [44, 62.3], [39, 70.7], [37, 70.7]], [[48, 51.1], [51, 45.5], [53, 45.5], [50, 51.1], [48, 51.1]], [[51, 35], [51, 28.7], [53, 28.7], [53, 35], [51, 35]], [[52, 22.4], [55, 17.5], [56, 17.5], [53, 22.4], [52, 22.4]], [[58, 12.6], [62, 7], [63, 7], [60, 12.6], [58, 12.6]], [[0, 3.5], [0, 93.1], [64, 93.1], [64, 0], [63, 0], [63, 92.4], [1, 92.4], [1, 3.5], [0, 3.5]]], o = 0; o < a.length; o++)
        for (var s = 0; s < a[o].length; s++)
            a[o][s][0] /= 10.5, a[o][s][1] /= -14, a[o][s][0] += r[0], a[o][s][1] += r[1];
    t.exports = function(t) {
        "china" === t.map && t.regions.push(new n("南海诸岛", a, r))
    }
}, function(t, e, i) {
    var n = i(509),
        r = {
            "南海诸岛": [32, 80],
            "广东": [0, -10],
            "香港": [10, 5],
            "澳门": [-10, 10],
            "天津": [5, 5]
        };
    t.exports = function(t) {
        n.each(t.regions, function(t) {
            var e = r[t.name];
            if (e) {
                var i = t.center;
                i[0] += e[0] / 10.5, i[1] += -e[1] / 14
            }
        })
    }
}, function(t, e, i) {
    var n = i(509),
        r = {
            Russia: [100, 60],
            "United States of America": [-99, 38]
        };
    t.exports = function(t) {
        n.each(t.regions, function(t) {
            var e = r[t.name];
            if (e) {
                var i = t.center;
                i[0] = e[0], i[1] = e[1]
            }
        })
    }
}, function(t, e, i) {
    var n = i(548),
        r = i(680);
    i(506).extendChartView({
        type: "map",
        render: function(t, e, i, n) {
            if (!n || "mapToggleSelect" !== n.type || n.from !== this.uid) {
                var a = this.group;
                if (a.removeAll(), n && "geoRoam" === n.type && "series" === n.componentType && n.seriesId === t.id) {
                    var o = this._mapDraw;
                    o && a.add(o.group)
                } else if (t.needsDrawMap) {
                    var o = this._mapDraw || new r(i, !0);
                    a.add(o.group), o.draw(t, e, i, this, n), this._mapDraw = o
                } else
                    this._mapDraw && this._mapDraw.remove(), this._mapDraw = null;
                t.get("showLegendSymbol") && e.getComponent("legend") && this._renderSymbols(t, e, i)
            }
        },
        remove: function() {
            this._mapDraw && this._mapDraw.remove(), this._mapDraw = null, this.group.removeAll()
        },
        dispose: function() {
            this._mapDraw && this._mapDraw.remove(), this._mapDraw = null
        },
        _renderSymbols: function(t, e, i) {
            var r = t.originalData,
                a = this.group;
            r.each("value", function(e, i) {
                if (!isNaN(e)) {
                    var o = r.getItemLayout(i);
                    if (o && o.point) {
                        var s = o.point,
                            l = o.offset,
                            c = new n.Circle({
                                style: {
                                    fill: t.getData().getVisual("color")
                                },
                                shape: {
                                    cx: s[0] + 9 * l,
                                    cy: s[1],
                                    r: 3
                                },
                                silent: !0,
                                z2: 10
                            });
                        if (!l) {
                            var u = t.mainSeries.getData(),
                                h = r.getName(i),
                                d = h,
                                p = u.indexOfName(h),
                                f = r.getItemModel(i),
                                g = f.getModel("label.normal"),
                                m = f.getModel("label.emphasis"),
                                v = g.getModel("textStyle"),
                                y = m.getModel("textStyle"),
                                x = u.getItemGraphicEl(p);
                            c.setStyle({
                                textPosition: "bottom"
                            });
                            var _ = function() {
                                    c.setStyle({
                                        text: m.get("show") ? d : "",
                                        textFill: y.getTextColor(),
                                        textFont: y.getFont()
                                    })
                                },
                                b = function() {
                                    c.setStyle({
                                        text: g.get("show") ? d : "",
                                        textFill: v.getTextColor(),
                                        textFont: v.getFont()
                                    })
                                };
                            x.on("mouseover", _).on("mouseout", b).on("emphasis", _).on("normal", b), b()
                        }
                        a.add(c)
                    }
                }
            })
        }
    })
}, function(t, e, i) {
    function n(t, e) {
        var i = t.getItemStyle(),
            n = t.get("areaColor");
        return n && (i.fill = n), i
    }
    function r(t, e, i, n, r) {
        i.off("click"), i.off("mousedown"), e.get("selectedMode") && (i.on("mousedown", function() {
            t._mouseDownFlag = !0
        }), i.on("click", function(o) {
            if (t._mouseDownFlag) {
                t._mouseDownFlag = !1;
                for (var s = o.target; !s.__region;)
                    s = s.parent;
                if (s) {
                    var l = s.__region,
                        c = {
                            type: ("geo" === e.mainType ? "geo" : "map") + "ToggleSelect",
                            name: l.name,
                            from: r.uid
                        };
                    c[e.mainType + "Id"] = e.id, n.dispatchAction(c), a(e, i)
                }
            }
        }))
    }
    function a(t, e) {
        e.eachChild(function(e) {
            e.__region && e.trigger(t.isSelected(e.__region.name) ? "emphasis" : "normal")
        })
    }
    function o(t, e) {
        var i = new l.Group;
        this._controller = new s(t.getZr(), e ? i : null, null), this.group = i, this._updateGroup = e, this._mouseDownFlag
    }
    var s = i(681),
        l = i(548),
        c = i(509);
    o.prototype = {
        constructor: o,
        draw: function(t, e, i, o, s) {
            var u = t.getData && t.getData(),
                h = t.coordinateSystem,
                d = this.group,
                p = h.scale,
                f = {
                    position: h.position,
                    scale: p
                };
            !d.childAt(0) || s ? d.attr(f) : l.updateProps(d, f, t), d.removeAll();
            var g = ["itemStyle", "normal"],
                m = ["itemStyle", "emphasis"],
                v = ["label", "normal"],
                y = ["label", "emphasis"];
            c.each(h.regions, function(e) {
                var i = new l.Group,
                    r = new l.CompoundPath({
                        shape: {
                            paths: []
                        }
                    });
                i.add(r);
                var a,
                    o = t.getRegionModel(e.name) || t,
                    s = o.getModel(g),
                    h = o.getModel(m),
                    f = n(s, p),
                    x = n(h, p),
                    _ = o.getModel(v),
                    b = o.getModel(y);
                if (u) {
                    a = u.indexOfName(e.name);
                    var w = u.getItemVisual(a, "color", !0);
                    w && (f.fill = w)
                }
                var M = _.getModel("textStyle"),
                    S = b.getModel("textStyle");
                c.each(e.contours, function(t) {
                    var e = new l.Polygon({
                        shape: {
                            points: t
                        }
                    });
                    r.shape.paths.push(e)
                }), r.setStyle(f), r.style.strokeNoScale = !0, r.culling = !0;
                var A = _.get("show"),
                    I = b.get("show"),
                    D = u && isNaN(u.get("value", a)),
                    k = u && u.getItemLayout(a);
                if (!u || D && (A || I) || k && k.showLabel) {
                    var T = u ? a : e.name,
                        C = t.getFormattedLabel(T, "normal"),
                        L = t.getFormattedLabel(T, "emphasis"),
                        P = new l.Text({
                            style: {
                                text: A ? C || e.name : "",
                                fill: M.getTextColor(),
                                textFont: M.getFont(),
                                textAlign: "center",
                                textVerticalAlign: "middle"
                            },
                            hoverStyle: {
                                text: I ? L || e.name : "",
                                fill: S.getTextColor(),
                                textFont: S.getFont()
                            },
                            position: e.center.slice(),
                            scale: [1 / p[0], 1 / p[1]],
                            z2: 10,
                            silent: !0
                        });
                    i.add(P)
                }
                if (u)
                    u.setItemGraphicEl(a, i);
                else {
                    var o = t.getRegionModel(e.name);
                    r.eventData = {
                        componentType: "geo",
                        geoIndex: t.componentIndex,
                        name: e.name,
                        region: o && o.option || {}
                    }
                }
                i.__region = e, l.setHoverStyle(i, x, {
                    hoverSilentOnTouch: !!t.get("selectedMode")
                }), d.add(i)
            }), this._updateController(t, e, i), r(this, t, d, i, o), a(t, d)
        },
        remove: function() {
            this.group.removeAll(), this._controller.dispose()
        },
        _updateController: function(t, e, i) {
            function n() {
                var e = {
                    type: "geoRoam",
                    componentType: o
                };
                return e[o + "Id"] = t.id, e
            }
            var r = t.coordinateSystem,
                a = this._controller;
            a.zoomLimit = t.get("scaleLimit"), a.zoom = r.getZoom(), a.enable(t.get("roam") || !1);
            var o = t.mainType;
            a.off("pan").on("pan", function(t, e) {
                this._mouseDownFlag = !1, i.dispatchAction(c.extend(n(), {
                    dx: t,
                    dy: e
                }))
            }, this), a.off("zoom").on("zoom", function(t, e, r) {
                if (this._mouseDownFlag = !1, i.dispatchAction(c.extend(n(), {
                    zoom: t,
                    originX: e,
                    originY: r
                })), this._updateGroup) {
                    var a = this.group,
                        o = a.scale;
                    a.traverse(function(t) {
                        "text" === t.type && t.attr("scale", [1 / o[0], 1 / o[1]])
                    })
                }
            }, this), a.setContainsPoint(function(t, e) {
                return r.getViewRectAfterRoam().contain(t, e)
            })
        }
    }, t.exports = o
}, function(t, e, i) {
    function n(t) {
        if (!t.target || !t.target.draggable) {
            var e = t.offsetX,
                i = t.offsetY;
            this.containsPoint && this.containsPoint(e, i) && (this._x = e, this._y = i, this._dragging = !0)
        }
    }
    function r(t) {
        if (this._dragging && (d.stop(t.event), "pinch" !== t.gestureEvent)) {
            if (p.isTaken(this._zr, "globalPan"))
                return;
            var e = t.offsetX,
                i = t.offsetY,
                n = this._x,
                r = this._y,
                a = e - n,
                o = i - r;
            this._x = e, this._y = i;
            var s = this.target;
            if (s) {
                var l = s.position;
                l[0] += a, l[1] += o, s.dirty()
            }
            d.stop(t.event), this.trigger("pan", a, o, n, r, e, i)
        }
    }
    function a(t) {
        this._dragging = !1
    }
    function o(t) {
        var e = t.wheelDelta > 0 ? 1.1 : 1 / 1.1;
        l.call(this, t, e, t.offsetX, t.offsetY)
    }
    function s(t) {
        if (!p.isTaken(this._zr, "globalPan")) {
            var e = t.pinchScale > 1 ? 1.1 : 1 / 1.1;
            l.call(this, t, e, t.pinchX, t.pinchY)
        }
    }
    function l(t, e, i, n) {
        if (this.containsPoint && this.containsPoint(i, n)) {
            d.stop(t.event);
            var r = this.target,
                a = this.zoomLimit;
            if (r) {
                var o = r.position,
                    s = r.scale,
                    l = this.zoom = this.zoom || 1;
                if (l *= e, a) {
                    var c = a.min || 0,
                        u = a.max || 1 / 0;
                    l = Math.max(Math.min(u, l), c)
                }
                var h = l / this.zoom;
                this.zoom = l, o[0] -= (i - o[0]) * (h - 1), o[1] -= (n - o[1]) * (h - 1), s[0] *= h, s[1] *= h, r.dirty()
            }
            this.trigger("zoom", e, i, n)
        }
    }
    function c(t, e) {
        this.target = e, this.containsPoint, this.zoomLimit, this.zoom, this._zr = t;
        var i = h.bind,
            l = i(n, this),
            c = i(r, this),
            d = i(a, this),
            p = i(o, this),
            f = i(s, this);
        u.call(this), this.setContainsPoint = function(t) {
            this.containsPoint = t
        }, this.enable = function(e) {
            this.disable(), null == e && (e = !0), e !== !0 && "move" !== e && "pan" !== e || (t.on("mousedown", l), t.on("mousemove", c), t.on("mouseup", d)), e !== !0 && "scale" !== e && "zoom" !== e || (t.on("mousewheel", p), t.on("pinch", f))
        }, this.disable = function() {
            t.off("mousedown", l), t.off("mousemove", c), t.off("mouseup", d), t.off("mousewheel", p), t.off("pinch", f)
        }, this.dispose = this.disable, this.isDragging = function() {
            return this._dragging
        }, this.isPinching = function() {
            return this._pinching
        }
    }
    var u = i(538),
        h = i(509),
        d = i(593),
        p = i(682);
    h.mixin(c, u), t.exports = c
}, function(t, e, i) {
    function n(t) {
        return t[r] || (t[r] = {})
    }
    var r = "\0_ec_interaction_mutex",
        a = {
            take: function(t, e, i) {
                var r = n(t);
                r[e] = i
            },
            release: function(t, e, i) {
                var r = n(t),
                    a = r[e];
                a === i && (r[e] = null)
            },
            isTaken: function(t, e) {
                return !!n(t)[e]
            }
        };
    i(506).registerAction({
        type: "takeGlobalCursor",
        event: "globalCursorTaken",
        update: "update"
    }, function() {}), t.exports = a
}, function(t, e, i) {
    var n = i(509),
        r = i(684),
        a = i(506);
    a.registerAction({
        type: "geoRoam",
        event: "geoRoam",
        update: "updateLayout"
    }, function(t, e) {
        var i = t.componentType || "series";
        e.eachComponent({
            mainType: i,
            query: t
        }, function(e) {
            var a = e.coordinateSystem;
            if ("geo" === a.type) {
                var o = r.updateCenterAndZoom(a, t, e.get("scaleLimit"));
                e.setCenter && e.setCenter(o.center), e.setZoom && e.setZoom(o.zoom), "series" === i && n.each(e.seriesGroup, function(t) {
                    t.setCenter(o.center), t.setZoom(o.zoom)
                })
            }
        })
    })
}, function(t, e) {
    var i = {};
    i.updateCenterAndZoom = function(t, e, i) {
        var n = t.getZoom(),
            r = t.getCenter(),
            a = e.zoom,
            o = t.dataToPoint(r);
        if (null != e.dx && null != e.dy) {
            o[0] -= e.dx, o[1] -= e.dy;
            var r = t.pointToData(o);
            t.setCenter(r)
        }
        if (null != a) {
            if (i) {
                var s = i.min || 0,
                    l = i.max || 1 / 0;
                a = Math.max(Math.min(n * a, l), s) / n
            }
            t.scale[0] *= a, t.scale[1] *= a;
            var c = t.position,
                u = (e.originX - c[0]) * (a - 1),
                h = (e.originY - c[1]) * (a - 1);
            c[0] -= u, c[1] -= h, t.updateTransform();
            var r = t.pointToData(o);
            t.setCenter(r), t.setZoom(a * n)
        }
        return {
            center: t.getCenter(),
            zoom: t.getZoom()
        }
    }, t.exports = i
}, function(t, e, i) {
    var n = i(509);
    t.exports = function(t) {
        var e = {};
        t.eachSeriesByType("map", function(i) {
            var r = i.get("map");
            if (!e[r]) {
                var a = {};
                n.each(i.seriesGroup, function(e) {
                    var i = e.coordinateSystem,
                        n = e.originalData;
                    e.get("showLegendSymbol") && t.getComponent("legend") && n.each("value", function(t, e) {
                        var r = n.getName(e),
                            o = i.getRegion(r);
                        if (o && !isNaN(t)) {
                            var s = a[r] || 0,
                                l = i.dataToPoint(o.center);
                            a[r] = s + 1, n.setItemLayout(e, {
                                point: l,
                                offset: s
                            })
                        }
                    })
                });
                var o = i.getData();
                o.each(function(t) {
                    var e = o.getName(t),
                        i = o.getItemLayout(t) || {};
                    i.showLabel = !a[e], o.setItemLayout(t, i)
                }), e[r] = !0
            }
        })
    }
}, function(t, e) {
    t.exports = function(t) {
        t.eachSeriesByType("map", function(t) {
            var e = t.get("color"),
                i = t.getModel("itemStyle.normal"),
                n = i.get("areaColor"),
                r = i.get("color") || e[t.seriesIndex % e.length];
            t.getData().setVisual({
                areaColor: n,
                color: r
            })
        })
    }
}, function(t, e, i) {
    function n(t, e) {
        for (var i = {}, n = ["value"], r = 0; r < t.length; r++)
            t[r].each(n, function(e, n) {
                var a = t[r].getName(n);
                i[a] = i[a] || [], isNaN(e) || i[a].push(e)
            });
        return t[0].map(n, function(n, r) {
            for (var a = t[0].getName(r), o = 0, s = 1 / 0, l = -(1 / 0), c = i[a].length, u = 0; u < c; u++)
                s = Math.min(s, i[a][u]), l = Math.max(l, i[a][u]), o += i[a][u];
            var h;
            return h = "min" === e ? s : "max" === e ? l : "average" === e ? o / c : o, 0 === c ? NaN : h
        })
    }
    var r = i(509);
    t.exports = function(t) {
        var e = {};
        t.eachSeriesByType("map", function(t) {
            var i = t.get("map");
            e[i] = e[i] || [], e[i].push(t)
        }), r.each(e, function(t, e) {
            for (var i = n(r.map(t, function(t) {
                    return t.getData()
                }), t[0].get("mapValueCalculation")), a = 0; a < t.length; a++)
                t[a].originalData = t[a].getData();
            for (var a = 0; a < t.length; a++)
                t[a].seriesGroup = t, t[a].needsDrawMap = 0 === a, t[a].setData(i.cloneShallow()), t[a].mainSeries = t[0]
        })
    }
}, function(t, e, i) {
    var n = i(509);
    t.exports = function(t) {
        var e = [];
        n.each(t.series, function(t) {
            "map" === t.type && e.push(t)
        }), n.each(e, function(t) {
            t.map = t.map || t.mapType, n.defaults(t, t.mapLocation)
        })
    }
}, function(t, e, i) {
    var n = i(506);
    i(690), i(694), i(697), n.registerVisual(i(698)), n.registerLayout(i(700))
}, function(t, e, i) {
    function n(t, e) {
        var i = 0;
        s.each(t.children, function(t) {
            n(t, e);
            var r = t.value;
            s.isArray(r) && (r = r[0]), i += r
        });
        var r = t.value;
        e >= 0 && (s.isArray(r) ? r = r[0] : t.value = new Array(e)), (null == r || isNaN(r)) && (r = i), r < 0 && (r = 0), e >= 0 ? t.value[0] = r : t.value = r
    }
    function r(t, e) {
        var i = e.get("color");
        if (i) {
            t = t || [];
            var n;
            if (s.each(t, function(t) {
                var e = new l(t),
                    i = e.get("color");
                (e.get("itemStyle.normal.color") || i && "none" !== i) && (n = !0)
            }), !n) {
                var r = t[0] || (t[0] = {});
                r.color = i.slice()
            }
            return t
        }
    }
    var a = i(533),
        o = i(691),
        s = i(509),
        l = i(517),
        c = i(511),
        u = i(693),
        h = c.encodeHTML,
        d = c.addCommas;
    t.exports = a.extend({
        type: "series.treemap",
        layoutMode: "box",
        dependencies: ["grid", "polar"],
        _viewRoot: null,
        defaultOption: {
            progressive: 0,
            hoverLayerThreshold: 1 / 0,
            left: "center",
            top: "middle",
            right: null,
            bottom: null,
            width: "80%",
            height: "80%",
            sort: !0,
            clipWindow: "origin",
            squareRatio: .5 * (1 + Math.sqrt(5)),
            leafDepth: null,
            drillDownIcon: "▶",
            zoomToNodeRatio: .1024,
            roam: !0,
            nodeClick: "zoomToNode",
            animation: !0,
            animationDurationUpdate: 900,
            animationEasing: "quinticInOut",
            breadcrumb: {
                show: !0,
                height: 22,
                left: "center",
                top: "bottom",
                emptyItemWidth: 25,
                itemStyle: {
                    normal: {
                        color: "rgba(0,0,0,0.7)",
                        borderColor: "rgba(255,255,255,0.7)",
                        borderWidth: 1,
                        shadowColor: "rgba(150,150,150,1)",
                        shadowBlur: 3,
                        shadowOffsetX: 0,
                        shadowOffsetY: 0,
                        textStyle: {
                            color: "#fff"
                        }
                    },
                    emphasis: {
                        textStyle: {}
                    }
                }
            },
            label: {
                normal: {
                    show: !0,
                    position: "inside",
                    textStyle: {
                        color: "#fff",
                        ellipsis: !0
                    }
                }
            },
            itemStyle: {
                normal: {
                    color: null,
                    colorAlpha: null,
                    colorSaturation: null,
                    borderWidth: 0,
                    gapWidth: 0,
                    borderColor: "#fff",
                    borderColorSaturation: null
                },
                emphasis: {}
            },
            visualDimension: 0,
            visualMin: null,
            visualMax: null,
            color: [],
            colorAlpha: null,
            colorSaturation: null,
            colorMappingBy: "index",
            visibleMin: 10,
            childrenVisibleMin: null,
            levels: []
        },
        getInitialData: function(t, e) {
            var i = t.data || [],
                a = t.name;
            null == a && (a = t.name);
            var l = {
                    name: a,
                    children: t.data
                },
                c = (i[0] || {}).value;
            n(l, s.isArray(c) ? c.length : -1);
            var u = t.levels || [];
            return u = t.levels = r(u, e), o.createTree(l, this, u).data
        },
        optionUpdated: function() {
            this.resetViewRoot()
        },
        formatTooltip: function(t) {
            var e = this.getData(),
                i = this.getRawValue(t),
                n = d(s.isArray(i) ? i[0] : i),
                r = e.getName(t);
            return h(r) + ": " + n
        },
        getDataParams: function(t) {
            var e = a.prototype.getDataParams.apply(this, arguments),
                i = this.getData().tree.getNodeByDataIndex(t);
            return e.treePathInfo = u.wrapTreePathInfo(i, this), e
        },
        setLayoutInfo: function(t) {
            this.layoutInfo = this.layoutInfo || {}, s.extend(this.layoutInfo, t)
        },
        mapIdToIndex: function(t) {
            var e = this._idIndexMap;
            e || (e = this._idIndexMap = {}, this._idIndexMapCount = 0);
            var i = e[t];
            return null == i && (e[t] = i = this._idIndexMapCount++), i
        },
        getViewRoot: function() {
            return this._viewRoot
        },
        resetViewRoot: function(t) {
            t ? this._viewRoot = t : t = this._viewRoot;
            var e = this.getData().tree.root;
            t && (t === e || e.contains(t)) || (this._viewRoot = e)
        }
    })
}, function(t, e, i) {
    function n(t, e) {
        this.root, this.data, this._nodes = [], this.hostModel = t, this.levelModels = a.map(e || [], function(e) {
            return new o(e, t, t.ecModel)
        })
    }
    function r(t, e) {
        var i = e.children;
        t.parentNode !== e && (i.push(t), t.parentNode = e)
    }
    var a = i(509),
        o = i(517),
        s = i(603),
        l = i(692),
        c = i(608),
        u = function(t, e) {
            this.name = t || "", this.depth = 0, this.height = 0, this.parentNode = null, this.dataIndex = -1, this.children = [], this.viewChildren = [], this.hostTree = e
        };
    u.prototype = {
        constructor: u,
        isRemoved: function() {
            return this.dataIndex < 0
        },
        eachNode: function(t, e, i) {
            "function" == typeof t && (i = e, e = t, t = null), t = t || {}, a.isString(t) && (t = {
                order: t
            });
            var n,
                r = t.order || "preorder",
                o = this[t.attr || "children"];
            "preorder" === r && (n = e.call(i, this));
            for (var s = 0; !n && s < o.length; s++)
                o[s].eachNode(t, e, i);
            "postorder" === r && e.call(i, this)
        },
        updateDepthAndHeight: function(t) {
            var e = 0;
            this.depth = t;
            for (var i = 0; i < this.children.length; i++) {
                var n = this.children[i];
                n.updateDepthAndHeight(t + 1), n.height > e && (e = n.height)
            }
            this.height = e + 1
        },
        getNodeById: function(t) {
            if (this.getId() === t)
                return this;
            for (var e = 0, i = this.children, n = i.length; e < n; e++) {
                var r = i[e].getNodeById(t);
                if (r)
                    return r
            }
        },
        contains: function(t) {
            if (t === this)
                return !0;
            for (var e = 0, i = this.children, n = i.length; e < n; e++) {
                var r = i[e].contains(t);
                if (r)
                    return r
            }
        },
        getAncestors: function(t) {
            for (var e = [], i = t ? this : this.parentNode; i;)
                e.push(i), i = i.parentNode;
            return e.reverse(), e
        },
        getValue: function(t) {
            var e = this.hostTree.data;
            return e.get(e.getDimension(t || "value"), this.dataIndex)
        },
        setLayout: function(t, e) {
            this.dataIndex >= 0 && this.hostTree.data.setItemLayout(this.dataIndex, t, e)
        },
        getLayout: function() {
            return this.hostTree.data.getItemLayout(this.dataIndex)
        },
        getModel: function(t) {
            if (!(this.dataIndex < 0)) {
                var e = this.hostTree,
                    i = e.data.getItemModel(this.dataIndex),
                    n = this.getLevelModel();
                return i.getModel(t, (n || e.hostModel).getModel(t))
            }
        },
        getLevelModel: function() {
            return (this.hostTree.levelModels || [])[this.depth]
        },
        setVisual: function(t, e) {
            this.dataIndex >= 0 && this.hostTree.data.setItemVisual(this.dataIndex, t, e)
        },
        getVisual: function(t, e) {
            return this.hostTree.data.getItemVisual(this.dataIndex, t, e)
        },
        getRawIndex: function() {
            return this.hostTree.data.getRawIndex(this.dataIndex)
        },
        getId: function() {
            return this.hostTree.data.getId(this.dataIndex)
        }
    }, n.prototype = {
        constructor: n,
        type: "tree",
        eachNode: function(t, e, i) {
            this.root.eachNode(t, e, i)
        },
        getNodeByDataIndex: function(t) {
            var e = this.data.getRawIndex(t);
            return this._nodes[e]
        },
        getNodeByName: function(t) {
            return this.root.getNodeByName(t)
        },
        update: function() {
            for (var t = this.data, e = this._nodes, i = 0, n = e.length; i < n; i++)
                e[i].dataIndex = -1;
            for (var i = 0, n = t.count(); i < n; i++)
                e[t.getRawIndex(i)].dataIndex = i
        },
        clearLayouts: function() {
            this.data.clearItemLayouts()
        }
    }, n.createTree = function(t, e, i) {
        function a(t, e) {
            h.push(t);
            var i = new u(t.name, o);
            e ? r(i, e) : o.root = i, o._nodes.push(i);
            var n = t.children;
            if (n)
                for (var s = 0; s < n.length; s++)
                    a(n[s], i)
        }
        var o = new n(e, i),
            h = [];
        a(t), o.root.updateDepthAndHeight(0);
        var d = c([{
                name: "value"
            }], h),
            p = new s(d, e);
        return p.initData(h), l({
            mainData: p,
            struct: o,
            structAttr: "tree"
        }), o.update(), o
    }, t.exports = n
}, function(t, e, i) {
    function n(t) {
        var e = t.mainData,
            i = t.datas;
        i || (i = {
            main: e
        }, t.datasAttr = {
            main: "data"
        }), t.datas = t.mainData = null, c(e, i, t), d(i, function(i) {
            d(e.TRANSFERABLE_METHODS, function(e) {
                i.wrapMethod(e, h.curry(r, t))
            })
        }), e.wrapMethod("cloneShallow", h.curry(o, t)), d(e.CHANGABLE_METHODS, function(i) {
            e.wrapMethod(i, h.curry(a, t))
        }), h.assert(i[e.dataType] === e)
    }
    function r(t, e) {
        if (l(this)) {
            var i = h.extend({}, this[p]);
            i[this.dataType] = e, c(e, i, t)
        } else
            u(e, this.dataType, this[f], t);
        return e
    }
    function a(t, e) {
        return t.struct && t.struct.update(this), e
    }
    function o(t, e) {
        return d(e[p], function(i, n) {
            i !== e && u(i.cloneShallow(), n, e, t)
        }), e
    }
    function s(t) {
        var e = this[f];
        return null == t || null == e ? e : e[p][t]
    }
    function l(t) {
        return t[f] === t
    }
    function c(t, e, i) {
        t[p] = {}, d(e, function(e, n) {
            u(e, n, t, i)
        })
    }
    function u(t, e, i, n) {
        i[p][e] = t, t[f] = i, t.dataType = e, n.struct && (t[n.structAttr] = n.struct, n.struct[n.datasAttr[e]] = t), t.getLinkedData = s
    }
    var h = i(509),
        d = h.each,
        p = "\0__link_datas",
        f = "\0__link_mainData";
    t.exports = n
}, function(t, e, i) {
    var n = i(509),
        r = {
            retrieveTargetInfo: function(t, e) {
                if (t && ("treemapZoomToNode" === t.type || "treemapRootToNode" === t.type)) {
                    var i = e.getData().tree.root,
                        n = t.targetNode;
                    if (n && i.contains(n))
                        return {
                            node: n
                        };
                    var r = t.targetNodeId;
                    if (null != r && (n = i.getNodeById(r)))
                        return {
                            node: n
                        }
                }
            },
            getPathToRoot: function(t) {
                for (var e = []; t;)
                    t = t.parentNode, t && e.push(t);
                return e.reverse()
            },
            aboveViewRoot: function(t, e) {
                var i = r.getPathToRoot(t);
                return n.indexOf(i, e) >= 0
            },
            wrapTreePathInfo: function(t, e) {
                for (var i = []; t;) {
                    var n = t.dataIndex;
                    i.push({
                        name: t.name,
                        dataIndex: n,
                        value: e.getRawValue(n)
                    }), t = t.parentNode
                }
                return i.reverse(), i
            }
        };
    t.exports = r
}, function(t, e, i) {
    function n() {
        return {
            nodeGroup: [],
            background: [],
            content: []
        }
    }
    function r(t, e, i, n, r, l, c, u, h, d) {
        function p(e) {
            R.dataIndex = c.dataIndex, R.seriesIndex = t.seriesIndex;
            var i = I.borderWidth,
                n = Math.max(D - 2 * i, 0),
                r = Math.max(k - 2 * i, 0);
            R.culling = !0, R.setShape({
                x: i,
                y: i,
                width: n,
                height: r
            });
            var a = c.getVisual("color", !0);
            f(R, function() {
                var t = {
                        fill: a
                    },
                    e = c.getModel("itemStyle.emphasis").getItemStyle();
                g(t, e, a, n, r), R.setStyle(t), s.setHoverStyle(R, e)
            }), e.add(R)
        }
        function f(t, e) {
            T ? !t.invisible && l.push(t) : (e(), t.__tmWillVisible || (t.invisible = !1))
        }
        function g(e, i, n, r, a) {
            var o = c.getModel(),
                s = o.get("name");
            if (I.isLeafRoot) {
                var l = t.get("drillDownIcon", !0);
                s = l ? l + " " + s : s
            }
            y(s, e, o, _, n, r, a), y(s, i, o, b, n, r, a)
        }
        function y(t, e, i, n, r, a, o) {
            var l = i.getModel(n),
                c = l.getModel("textStyle");
            s.setText(e, l, r), e.textAlign = c.get("align"), e.textVerticalAlign = c.get("baseline");
            var u = c.getTextRect(t);
            !l.getShallow("show") || u.height > o ? e.text = "" : u.width > a ? e.text = c.get("ellipsis") ? c.truncateText(t, a, null, {
                minChar: 2
            }) : "" : e.text = t
        }
        function x(t, n, o, s) {
            var l = null != L && i[t][L],
                c = r[t];
            return l ? (i[t][L] = null, w(c, l, t)) : T || (l = new n({
                z: a(o, s)
            }), l.__tmDepth = o, l.__tmStorageName = t, A(c, l, t)), e[t][C] = l
        }
        function w(t, e, i) {
            var n = t[C] = {};
            n.old = "nodeGroup" === i ? e.position.slice() : o.extend({}, e.shape)
        }
        function A(t, e, i) {
            var a = t[C] = {},
                o = c.parentNode;
            if (o && (!n || "drillDown" === n.direction)) {
                var s = 0,
                    l = 0,
                    u = r.background[o.getRawIndex()];
                !n && u && u.old && (s = u.old.width, l = u.old.height), a.old = "nodeGroup" === i ? [0, l] : {
                    x: s,
                    y: l,
                    width: 0,
                    height: 0
                }
            }
            a.fadein = "nodeGroup" !== i
        }
        if (c) {
            var I = c.getLayout();
            if (I && I.isInView) {
                var D = I.width,
                    k = I.height,
                    T = I.invisible,
                    C = c.getRawIndex(),
                    L = u && u.getRawIndex(),
                    P = x("nodeGroup", m);
                if (P) {
                    if (h.add(P), P.attr("position", [I.x || 0, I.y || 0]), P.__tmNodeWidth = D, P.__tmNodeHeight = k, I.isAboveViewRoot)
                        return P;
                    var E = x("background", v, d, M);
                    E && (E.setShape({
                        x: 0,
                        y: 0,
                        width: D,
                        height: k
                    }), f(E, function() {
                        E.setStyle("fill", c.getVisual("borderColor", !0))
                    }), P.add(E));
                    var O = c.viewChildren;
                    if (!O || !O.length) {
                        var R = x("content", v, d, S);
                        R && p(P)
                    }
                    return P
                }
            }
        }
    }
    function a(t, e) {
        var i = t * w + e;
        return (i - 1) / i
    }
    var o = i(509),
        s = i(548),
        l = i(604),
        c = i(693),
        u = i(695),
        h = i(681),
        d = i(514),
        p = i(516),
        f = i(696),
        g = o.bind,
        m = s.Group,
        v = s.Rect,
        y = o.each,
        x = 3,
        _ = ["label", "normal"],
        b = ["label", "emphasis"],
        w = 10,
        M = 1,
        S = 2;
    t.exports = i(506).extendChartView({
        type: "treemap",
        init: function(t, e) {
            this._containerGroup, this._storage = n(), this._oldTree, this._breadcrumb, this._controller, this._state = "ready", this._mayClick
        },
        render: function(t, e, i, n) {
            var r = e.findComponents({
                mainType: "series",
                subType: "treemap",
                query: n
            });
            if (!(o.indexOf(r, t) < 0)) {
                this.seriesModel = t, this.api = i, this.ecModel = e;
                var a = c.retrieveTargetInfo(n, t),
                    s = n && n.type,
                    l = t.layoutInfo,
                    u = !this._oldTree,
                    h = this._storage,
                    d = "treemapRootToNode" === s && a && h ? {
                        rootNodeGroup: h.nodeGroup[a.node.getRawIndex()],
                        direction: n.direction
                    } : null,
                    p = this._giveContainerGroup(l),
                    f = this._doRender(p, t, d);
                u || s && "treemapZoomToNode" !== s && "treemapRootToNode" !== s ? f.renderFinally() : this._doAnimation(p, f, t, d), this._resetController(i), this._renderBreadcrumb(t, i, a)
            }
        },
        _giveContainerGroup: function(t) {
            var e = this._containerGroup;
            return e || (e = this._containerGroup = new m, this._initEvents(e), this.group.add(e)), e.attr("position", [t.x, t.y]), e
        },
        _doRender: function(t, e, i) {
            function a(t, e, i, n, r) {
                function s(t) {
                    return t.getId()
                }
                function c(o, s) {
                    var l = null != o ? t[o] : null,
                        c = null != s ? e[s] : null,
                        u = m(l, c, i, r);
                    u && a(l && l.viewChildren || [], c && c.viewChildren || [], u, n, r + 1)
                }
                n ? (e = t, y(t, function(t, e) {
                    !t.isRemoved() && c(e, e)
                })) : new l(e, t, s, s).add(c).update(c).remove(o.curry(c, null)).execute()
            }
            function s(t) {
                var e = n();
                return t && y(t, function(t, i) {
                    var n = e[i];
                    y(t, function(t) {
                        t && (n.push(t), t.__tmWillDelete = 1)
                    })
                }), e
            }
            function c() {
                y(v, function(t) {
                    y(t, function(t) {
                        t.parent && t.parent.remove(t)
                    })
                }), y(g, function(t) {
                    t.invisible = !0, t.dirty()
                })
            }
            var u = e.getData().tree,
                h = this._oldTree,
                d = n(),
                p = n(),
                f = this._storage,
                g = [],
                m = o.curry(r, e, p, f, i, d, g);
            a(u.root ? [u.root] : [], h && h.root ? [h.root] : [], t, u === h || !h, 0);
            var v = s(f);
            return this._oldTree = u, this._storage = p, {
                lastsForAnimation: d,
                willDeleteEls: v,
                renderFinally: c
            }
        },
        _doAnimation: function(t, e, i, n) {
            if (i.get("animation")) {
                var r = i.get("animationDurationUpdate"),
                    a = i.get("animationEasing"),
                    s = f.createWrap();
                y(e.willDeleteEls, function(t, e) {
                    y(t, function(t, i) {
                        if (!t.invisible) {
                            var o,
                                l = t.parent;
                            if (n && "drillDown" === n.direction)
                                o = l === n.rootNodeGroup ? {
                                    shape: {
                                        x: 0,
                                        y: 0,
                                        width: l.__tmNodeWidth,
                                        height: l.__tmNodeHeight
                                    },
                                    style: {
                                        opacity: 0
                                    }
                                } : {
                                    style: {
                                        opacity: 0
                                    }
                                };
                            else {
                                var c = 0,
                                    u = 0;
                                l.__tmWillDelete || (c = l.__tmNodeWidth / 2, u = l.__tmNodeHeight / 2), o = "nodeGroup" === e ? {
                                    position: [c, u],
                                    style: {
                                        opacity: 0
                                    }
                                } : {
                                    shape: {
                                        x: c,
                                        y: u,
                                        width: 0,
                                        height: 0
                                    },
                                    style: {
                                        opacity: 0
                                    }
                                }
                            }
                            o && s.add(t, o, r, a)
                        }
                    })
                }), y(this._storage, function(t, i) {
                    y(t, function(t, n) {
                        var l = e.lastsForAnimation[i][n],
                            c = {};
                        l && ("nodeGroup" === i ? l.old && (c.position = t.position.slice(),
                        t.attr("position", l.old)) : (l.old && (c.shape = o.extend({}, t.shape), t.setShape(l.old)), l.fadein ? (t.setStyle("opacity", 0), c.style = {
                            opacity: 1
                        }) : 1 !== t.style.opacity && (c.style = {
                            opacity: 1
                        })), s.add(t, c, r, a))
                    })
                }, this), this._state = "animating", s.done(g(function() {
                    this._state = "ready", e.renderFinally()
                }, this)).start()
            }
        },
        _resetController: function(t) {
            var e = this._controller;
            e || (e = this._controller = new h(t.getZr()), e.enable(this.seriesModel.get("roam")), e.on("pan", g(this._onPan, this)), e.on("zoom", g(this._onZoom, this)));
            var i = new d(0, 0, t.getWidth(), t.getHeight());
            e.setContainsPoint(function(t, e) {
                return i.contain(t, e)
            })
        },
        _clearController: function() {
            var t = this._controller;
            t && (t.dispose(), t = null)
        },
        _onPan: function(t, e) {
            if (this._mayClick = !1, "animating" !== this._state && (Math.abs(t) > x || Math.abs(e) > x)) {
                var i = this.seriesModel.getData().tree.root;
                if (!i)
                    return;
                var n = i.getLayout();
                if (!n)
                    return;
                this.api.dispatchAction({
                    type: "treemapMove",
                    from: this.uid,
                    seriesId: this.seriesModel.id,
                    rootRect: {
                        x: n.x + t,
                        y: n.y + e,
                        width: n.width,
                        height: n.height
                    }
                })
            }
        },
        _onZoom: function(t, e, i) {
            if (this._mayClick = !1, "animating" !== this._state) {
                var n = this.seriesModel.getData().tree.root;
                if (!n)
                    return;
                var r = n.getLayout();
                if (!r)
                    return;
                var a = new d(r.x, r.y, r.width, r.height),
                    o = this.seriesModel.layoutInfo;
                e -= o.x, i -= o.y;
                var s = p.create();
                p.translate(s, s, [-e, -i]), p.scale(s, s, [t, t]), p.translate(s, s, [e, i]), a.applyTransform(s), this.api.dispatchAction({
                    type: "treemapRender",
                    from: this.uid,
                    seriesId: this.seriesModel.id,
                    rootRect: {
                        x: a.x,
                        y: a.y,
                        width: a.width,
                        height: a.height
                    }
                })
            }
        },
        _initEvents: function(t) {
            function e(t) {
                var e = this.seriesModel.get("nodeClick", !0);
                if (e) {
                    var i = this.findTarget(t.offsetX, t.offsetY);
                    if (i) {
                        var n = i.node;
                        if (n.getLayout().isLeafRoot)
                            this._rootToNode(i);
                        else if ("zoomToNode" === e)
                            this._zoomToNode(i);
                        else if ("link" === e) {
                            var r = n.hostTree.data.getItemModel(n.dataIndex),
                                a = r.get("link", !0),
                                o = r.get("target", !0) || "blank";
                            a && window.open(a, o)
                        }
                    }
                }
            }
            t.on("mousedown", function(t) {
                "ready" === this._state && (this._mayClick = !0)
            }, this), t.on("mouseup", function(t) {
                this._mayClick && (this._mayClick = !1, "ready" === this._state && e.call(this, t))
            }, this)
        },
        _renderBreadcrumb: function(t, e, i) {
            function n(e) {
                "animating" !== this._state && (c.aboveViewRoot(t.getViewRoot(), e) ? this._rootToNode({
                    node: e
                }) : this._zoomToNode({
                    node: e
                }))
            }
            i || (i = null != t.get("leafDepth", !0) ? {
                node: t.getViewRoot()
            } : this.findTarget(e.getWidth() / 2, e.getHeight() / 2), i || (i = {
                node: t.getData().tree.root
            })), (this._breadcrumb || (this._breadcrumb = new u(this.group))).render(t, e, i.node, g(n, this))
        },
        remove: function() {
            this._clearController(), this._containerGroup && this._containerGroup.removeAll(), this._storage = n(), this._state = "ready", this._breadcrumb && this._breadcrumb.remove()
        },
        dispose: function() {
            this._clearController()
        },
        _zoomToNode: function(t) {
            this.api.dispatchAction({
                type: "treemapZoomToNode",
                from: this.uid,
                seriesId: this.seriesModel.id,
                targetNode: t.node
            })
        },
        _rootToNode: function(t) {
            this.api.dispatchAction({
                type: "treemapRootToNode",
                from: this.uid,
                seriesId: this.seriesModel.id,
                targetNode: t.node
            })
        },
        findTarget: function(t, e) {
            var i,
                n = this.seriesModel.getViewRoot();
            return n.eachNode({
                attr: "viewChildren",
                order: "preorder"
            }, function(n) {
                var r = this._storage.background[n.getRawIndex()];
                if (r) {
                    var a = r.transformCoordToLocal(t, e),
                        o = r.shape;
                    if (!(o.x <= a[0] && a[0] <= o.x + o.width && o.y <= a[1] && a[1] <= o.y + o.height))
                        return !1;
                    i = {
                        node: n,
                        offsetX: a[0],
                        offsetY: a[1]
                    }
                }
            }, this), i
        }
    })
}, function(t, e, i) {
    function n(t) {
        this.group = new o.Group, t.add(this.group)
    }
    function r(t, e, i, n, r, a) {
        var o = [[r ? t : t - d, e], [t + i, e], [t + i, e + n], [r ? t : t - d, e + n]];
        return !a && o.splice(2, 0, [t + i + d, e + n / 2]), !r && o.push([t, e + n / 2]), o
    }
    function a(t, e, i) {
        t.eventData = {
            componentType: "series",
            componentSubType: "treemap",
            seriesIndex: e.componentIndex,
            seriesName: e.name,
            seriesType: "treemap",
            selfType: "breadcrumb",
            nodeData: {
                dataIndex: i && i.dataIndex,
                name: i && i.name
            },
            treePathInfo: i && c.wrapTreePathInfo(i, e)
        }
    }
    var o = i(548),
        s = i(526),
        l = i(509),
        c = i(693),
        u = 8,
        h = 8,
        d = 5;
    n.prototype = {
        constructor: n,
        render: function(t, e, i, n) {
            var r = t.getModel("breadcrumb"),
                a = this.group;
            if (a.removeAll(), r.get("show") && i) {
                var o = r.getModel("itemStyle.normal"),
                    l = o.getModel("textStyle"),
                    c = {
                        pos: {
                            left: r.get("left"),
                            right: r.get("right"),
                            top: r.get("top"),
                            bottom: r.get("bottom")
                        },
                        box: {
                            width: e.getWidth(),
                            height: e.getHeight()
                        },
                        emptyItemWidth: r.get("emptyItemWidth"),
                        totalWidth: 0,
                        renderList: []
                    };
                this._prepare(i, c, l), this._renderContent(t, c, o, l, n), s.positionElement(a, c.pos, c.box)
            }
        },
        _prepare: function(t, e, i) {
            for (var n = t; n; n = n.parentNode) {
                var r = n.getModel().get("name"),
                    a = i.getTextRect(r),
                    o = Math.max(a.width + 2 * u, e.emptyItemWidth);
                e.totalWidth += o + h, e.renderList.push({
                    node: n,
                    text: r,
                    width: o
                })
            }
        },
        _renderContent: function(t, e, i, n, c) {
            for (var u = 0, d = e.emptyItemWidth, p = t.get("breadcrumb.height"), f = s.getAvailableSize(e.pos, e.box), g = e.totalWidth, m = e.renderList, v = m.length - 1; v >= 0; v--) {
                var y = m[v],
                    x = y.node,
                    _ = y.width,
                    b = y.text;
                g > f.width && (g -= _ - d, _ = d, b = "");
                var w = new o.Polygon({
                    shape: {
                        points: r(u, 0, _, p, v === m.length - 1, 0 === v)
                    },
                    style: l.defaults(i.getItemStyle(), {
                        lineJoin: "bevel",
                        text: b,
                        textFill: n.getTextColor(),
                        textFont: n.getFont()
                    }),
                    z: 10,
                    onclick: l.curry(c, x)
                });
                this.group.add(w), a(w, t, x), u += _ + h
            }
        },
        remove: function() {
            this.group.removeAll()
        }
    }, t.exports = n
}, function(t, e, i) {
    function n() {
        var t,
            e = [],
            i = {};
        return {
            add: function(t, n, a, o, s) {
                return r.isString(o) && (s = o, o = 0), !i[t.id] && (i[t.id] = 1, e.push({
                    el: t,
                    target: n,
                    time: a,
                    delay: o,
                    easing: s
                }), !0)
            },
            done: function(e) {
                return t = e, this
            },
            start: function() {
                function n() {
                    r--, r || (e.length = 0, i = {}, t && t())
                }
                for (var r = e.length, a = 0, o = e.length; a < o; a++) {
                    var s = e[a];
                    s.el.animateTo(s.target, s.time, s.delay, s.easing, n)
                }
                return this
            }
        }
    }
    var r = i(509);
    t.exports = {
        createWrap: n
    }
}, function(t, e, i) {
    for (var n = i(506), r = i(693), a = function() {}, o = ["treemapZoomToNode", "treemapRender", "treemapMove"], s = 0; s < o.length; s++)
        n.registerAction({
            type: o[s],
            update: "updateView"
        }, a);
    n.registerAction({
        type: "treemapRootToNode",
        update: "updateView"
    }, function(t, e) {
        function i(e, i) {
            var n = r.retrieveTargetInfo(t, e);
            if (n) {
                var a = e.getViewRoot();
                a && (t.direction = r.aboveViewRoot(a, n.node) ? "rollUp" : "drillDown"), e.resetViewRoot(n.node)
            }
        }
        e.eachComponent({
            mainType: "series",
            subType: "treemap",
            query: t
        }, i)
    })
}, function(t, e, i) {
    function n(t, e, i, s, c, h) {
        var d = t.getModel(),
            f = t.getLayout();
        if (f && !f.invisible && f.isInView) {
            var m,
                v = t.getModel(g),
                y = i[t.depth],
                x = r(v, e, y, s),
                _ = v.get("borderColor"),
                b = v.get("borderColorSaturation");
            null != b && (m = a(x, t), _ = o(b, m)), t.setVisual("borderColor", _);
            var w = t.viewChildren;
            if (w && w.length) {
                var M = l(t, d, f, v, x, w);
                p.each(w, function(t, e) {
                    if (t.depth >= c.length || t === c[t.depth]) {
                        var r = u(d, x, t, e, M, h);
                        n(t, r, i, s, c, h)
                    }
                })
            } else
                m = a(x, t), t.setVisual("color", m)
        }
    }
    function r(t, e, i, n) {
        var r = p.extend({}, e);
        return p.each(["color", "colorAlpha", "colorSaturation"], function(a) {
            var o = t.get(a, !0);
            null == o && i && (o = i[a]), null == o && (o = e[a]), null == o && (o = n.get(a)), null != o && (r[a] = o)
        }), r
    }
    function a(t) {
        var e = s(t, "color");
        if (e) {
            var i = s(t, "colorAlpha"),
                n = s(t, "colorSaturation");
            return n && (e = d.modifyHSL(e, null, null, n)), i && (e = d.modifyAlpha(e, i)), e
        }
    }
    function o(t, e) {
        return null != e ? d.modifyHSL(e, null, null, t) : null
    }
    function s(t, e) {
        var i = t[e];
        if (null != i && "none" !== i)
            return i
    }
    function l(t, e, i, n, r, a) {
        if (a && a.length) {
            var o = c(e, "color") || null != r.color && "none" !== r.color && (c(e, "colorAlpha") || c(e, "colorSaturation"));
            if (o) {
                var s = e.get("visualMin"),
                    l = e.get("visualMax"),
                    u = i.dataExtent.slice();
                null != s && s < u[0] && (u[0] = s), null != l && l > u[1] && (u[1] = l);
                var d = e.get("colorMappingBy"),
                    p = {
                        type: o.name,
                        dataExtent: u,
                        visual: o.range
                    };
                "color" !== p.type || "index" !== d && "id" !== d ? p.mappingMethod = "linear" : (p.mappingMethod = "category", p.loop = !0);
                var f = new h(p);
                return f.__drColorMappingBy = d, f
            }
        }
    }
    function c(t, e) {
        var i = t.get(e);
        return f(i) && i.length ? {
            name: e,
            range: i
        } : null
    }
    function u(t, e, i, n, r, a) {
        var o = p.extend({}, e);
        if (r) {
            var s = r.type,
                l = "color" === s && r.__drColorMappingBy,
                c = "index" === l ? n : "id" === l ? a.mapIdToIndex(i.getId()) : i.getValue(t.get("visualDimension"));
            o[s] = r.mapValueToVisual(c)
        }
        return o
    }
    var h = i(699),
        d = i(544),
        p = i(509),
        f = p.isArray,
        g = "itemStyle.normal";
    t.exports = function(t, e, i) {
        var r = {
            mainType: "series",
            subType: "treemap",
            query: i
        };
        t.eachComponent(r, function(t) {
            var e = t.getData().tree,
                i = e.root,
                r = t.getModel(g);
            if (!i.isRemoved()) {
                var a = p.map(e.levelModels, function(t) {
                    return t ? t.get(g) : null
                });
                n(i, {}, a, r, t.getViewRoot().getAncestors(), t)
            }
        })
    }
}, function(t, e, i) {
    function n(t) {
        var e = t.pieceList;
        t.hasSpecialVisual = !1, f.each(e, function(e, i) {
            e.originIndex = i, null != e.visual && (t.hasSpecialVisual = !0)
        })
    }
    function r(t) {
        var e = t.categories,
            i = t.visual,
            n = t.categoryMap = {};
        if (v(e, function(t, e) {
            n[t] = e
        }), !f.isArray(i)) {
            var r = [];
            f.isObject(i) ? v(i, function(t, e) {
                var i = n[e];
                r[null != i ? i : x] = t
            }) : r[x] = i, i = t.visual = r
        }
        for (var a = e.length - 1; a >= 0; a--)
            null == i[a] && (delete n[e[a]], e.pop())
    }
    function a(t, e) {
        var i = t.visual,
            n = [];
        f.isObject(i) ? v(i, function(t) {
            n.push(t)
        }) : null != i && n.push(i);
        var r = {
            color: 1,
            symbol: 1
        };
        e || 1 !== n.length || r.hasOwnProperty(t.type) || (n[1] = n[0]), t.visual = n
    }
    function o(t) {
        return {
            applyVisual: function(e, i, n) {
                e = this.mapValueToVisual(e), n("color", t(i("color"), e))
            },
            _doMap: h([0, 1])
        }
    }
    function s(t) {
        var e = this.option.visual;
        return e[Math.round(m(t, [0, 1], [0, e.length - 1], !0))] || {}
    }
    function l(t) {
        return function(e, i, n) {
            n(t, this.mapValueToVisual(e))
        }
    }
    function c(t) {
        var e = this.option.visual;
        return e[this.option.loop && t !== x ? t % e.length : t]
    }
    function u() {
        return this.option.visual[0]
    }
    function h(t) {
        return {
            linear: function(e) {
                return m(e, t, this.option.visual, !0)
            },
            category: c,
            piecewise: function(e, i) {
                var n = d.call(this, i);
                return null == n && (n = m(e, t, this.option.visual, !0)), n
            },
            fixed: u
        }
    }
    function d(t) {
        var e = this.option,
            i = e.pieceList;
        if (e.hasSpecialVisual) {
            var n = _.findPieceIndex(t, i),
                r = i[n];
            if (r && r.visual)
                return r.visual[this.type]
        }
    }
    function p(t, e, i) {
        return t ? e <= i : e < i
    }
    var f = i(509),
        g = i(544),
        m = i(512).linearMap,
        v = f.each,
        y = f.isObject,
        x = -1,
        _ = function(t) {
            var e = t.mappingMethod,
                i = t.type,
                o = this.option = f.clone(t);
            this.type = i, this.mappingMethod = e, this._normalizeData = w[e];
            var s = b[i];
            this.applyVisual = s.applyVisual, this.getColorMapper = s.getColorMapper, this._doMap = s._doMap[e], "piecewise" === e ? (a(o), n(o)) : "category" === e ? o.categories ? r(o) : a(o, !0) : (f.assert("linear" !== e || o.dataExtent), a(o))
        };
    _.prototype = {
        constructor: _,
        mapValueToVisual: function(t) {
            var e = this._normalizeData(t);
            return this._doMap(e, t)
        },
        getNormalizer: function() {
            return f.bind(this._normalizeData, this)
        }
    };
    var b = _.visualHandlers = {
            color: {
                applyVisual: l("color"),
                getColorMapper: function() {
                    var t = this.option,
                        e = f.map(t.visual, g.parse);
                    return f.bind("category" === t.mappingMethod ? function(t, e) {
                        return !e && (t = this._normalizeData(t)), c.call(this, t)
                    } : function(t, i, n) {
                        var r = !!n;
                        return !i && (t = this._normalizeData(t)), n = g.fastMapToColor(t, e, n), r ? n : f.stringify(n, "rgba")
                    }, this)
                },
                _doMap: {
                    linear: function(t) {
                        return g.mapToColor(t, this.option.visual)
                    },
                    category: c,
                    piecewise: function(t, e) {
                        var i = d.call(this, e);
                        return null == i && (i = g.mapToColor(t, this.option.visual)), i
                    },
                    fixed: u
                }
            },
            colorHue: o(function(t, e) {
                return g.modifyHSL(t, e)
            }),
            colorSaturation: o(function(t, e) {
                return g.modifyHSL(t, null, e)
            }),
            colorLightness: o(function(t, e) {
                return g.modifyHSL(t, null, null, e)
            }),
            colorAlpha: o(function(t, e) {
                return g.modifyAlpha(t, e)
            }),
            opacity: {
                applyVisual: l("opacity"),
                _doMap: h([0, 1])
            },
            symbol: {
                applyVisual: function(t, e, i) {
                    var n = this.mapValueToVisual(t);
                    if (f.isString(n))
                        i("symbol", n);
                    else if (y(n))
                        for (var r in n)
                            n.hasOwnProperty(r) && i(r, n[r])
                },
                _doMap: {
                    linear: s,
                    category: c,
                    piecewise: function(t, e) {
                        var i = d.call(this, e);
                        return null == i && (i = s.call(this, t)), i
                    },
                    fixed: u
                }
            },
            symbolSize: {
                applyVisual: l("symbolSize"),
                _doMap: h([0, 1])
            }
        },
        w = {
            linear: function(t) {
                return m(t, this.option.dataExtent, [0, 1], !0)
            },
            piecewise: function(t) {
                var e = this.option.pieceList,
                    i = _.findPieceIndex(t, e, !0);
                if (null != i)
                    return m(i, [0, e.length - 1], [0, 1], !0)
            },
            category: function(t) {
                var e = this.option.categories ? this.option.categoryMap[t] : t;
                return null == e ? x : e
            },
            fixed: f.noop
        };
    _.listVisualTypes = function() {
        var t = [];
        return f.each(b, function(e, i) {
            t.push(i)
        }), t
    }, _.addVisualHandler = function(t, e) {
        b[t] = e
    }, _.isValidType = function(t) {
        return b.hasOwnProperty(t)
    }, _.eachVisual = function(t, e, i) {
        f.isObject(t) ? f.each(t, e, i) : e.call(i, t)
    }, _.mapVisual = function(t, e, i) {
        var n,
            r = f.isArray(t) ? [] : f.isObject(t) ? {} : (n = !0, null);
        return _.eachVisual(t, function(t, a) {
            var o = e.call(i, t, a);
            n ? r = o : r[a] = o
        }), r
    }, _.retrieveVisuals = function(t) {
        var e,
            i = {};
        return t && v(b, function(n, r) {
            t.hasOwnProperty(r) && (i[r] = t[r], e = !0)
        }), e ? i : null
    }, _.prepareVisualTypes = function(t) {
        if (y(t)) {
            var e = [];
            v(t, function(t, i) {
                e.push(i)
            }), t = e
        } else {
            if (!f.isArray(t))
                return [];
            t = t.slice()
        }
        return t.sort(function(t, e) {
            return "color" === e && "color" !== t && 0 === t.indexOf("color") ? 1 : -1
        }), t
    }, _.dependsOn = function(t, e) {
        return "color" === e ? !(!t || 0 !== t.indexOf(e)) : t === e
    }, _.findPieceIndex = function(t, e, i) {
        function n(e, i) {
            var n = Math.abs(e - t);
            n < a && (a = n, r = i)
        }
        for (var r, a = 1 / 0, o = 0, s = e.length; o < s; o++) {
            var l = e[o].value;
            if (null != l) {
                if (l === t)
                    return o;
                i && n(l, o)
            }
        }
        for (var o = 0, s = e.length; o < s; o++) {
            var c = e[o],
                u = c.interval,
                h = c.close;
            if (u) {
                if (u[0] === -(1 / 0)) {
                    if (p(h[1], t, u[1]))
                        return o
                } else if (u[1] === 1 / 0) {
                    if (p(h[0], u[0], t))
                        return o
                } else if (p(h[0], u[0], t) && p(h[1], t, u[1]))
                    return o;
                i && n(u[0], o), i && n(u[1], o)
            }
        }
        if (i)
            return t === 1 / 0 ? e.length - 1 : t === -(1 / 0) ? 0 : r
    }, t.exports = _
}, function(t, e, i) {
    function n(t, e, i) {
        var n = {
            mainType: "series",
            subType: "treemap",
            query: i
        };
        t.eachComponent(n, function(t) {
            var n = e.getWidth(),
                a = e.getHeight(),
                o = t.option,
                s = o.size || [],
                l = b(w(o.width, s[0]), n),
                c = b(w(o.height, s[1]), a),
                u = m.getLayoutRect(t.getBoxLayoutParams(), {
                    width: e.getWidth(),
                    height: e.getHeight()
                }),
                g = i && i.type,
                x = v.retrieveTargetInfo(i, t),
                _ = "treemapRender" === g || "treemapMove" === g ? i.rootRect : null,
                S = t.getViewRoot(),
                A = v.getPathToRoot(S);
            if ("treemapMove" !== g) {
                var I = "treemapZoomToNode" === g ? h(t, x, S, l, c) : _ ? [_.width, _.height] : [l, c],
                    D = o.sort;
                D && "asc" !== D && "desc" !== D && (D = "desc");
                var k = {
                    squareRatio: o.squareRatio,
                    sort: D,
                    leafDepth: o.leafDepth
                };
                S.hostTree.clearLayouts();
                var T = {
                    x: 0,
                    y: 0,
                    width: I[0],
                    height: I[1],
                    area: I[0] * I[1]
                };
                S.setLayout(T), r(S, k, !1, 0);
                var T = S.getLayout();
                M(A, function(t, e) {
                    var i = (A[e + 1] || S).getValue();
                    t.setLayout(f.extend({
                        dataExtent: [i, i],
                        borderWidth: 0
                    }, T))
                })
            }
            var C = t.getData().tree.root;
            C.setLayout(d(u, _, x), !0), t.setLayoutInfo(u), p(C, new y(-u.x, -u.y, n, a), A, S, 0)
        })
    }
    function r(t, e, i, n) {
        var o,
            s;
        if (!t.isRemoved()) {
            var l = t.getLayout();
            o = l.width, s = l.height;
            var h = t.getModel("itemStyle.normal"),
                d = h.get("borderWidth"),
                p = h.get("gapWidth") / 2,
                f = d - p,
                g = t.getModel();
            t.setLayout({
                borderWidth: d
            }, !0), o = x(o - 2 * f, 0), s = x(s - 2 * f, 0);
            var m = o * s,
                v = a(t, g, m, e, i, n);
            if (v.length) {
                var y = {
                        x: f,
                        y: f,
                        width: o,
                        height: s
                    },
                    b = _(o, s),
                    w = 1 / 0,
                    M = [];
                M.area = 0;
                for (var S = 0, A = v.length; S < A;) {
                    var I = v[S];
                    M.push(I), M.area += I.getLayout().area;
                    var D = c(M, b, e.squareRatio);
                    D <= w ? (S++, w = D) : (M.area -= M.pop().getLayout().area, u(M, b, y, p, !1), b = _(y.width, y.height), M.length = M.area = 0, w = 1 / 0)
                }
                if (M.length && u(M, b, y, p, !0), !i) {
                    var k = g.get("childrenVisibleMin");
                    null != k && m < k && (i = !0)
                }
                for (var S = 0, A = v.length; S < A; S++)
                    r(v[S], e, i, n + 1)
            }
        }
    }
    function a(t, e, i, n, r, a) {
        var c = t.children || [],
            u = n.sort;
        "asc" !== u && "desc" !== u && (u = null);
        var h = null != n.leafDepth && n.leafDepth <= a;
        if (r && !h)
            return t.viewChildren = [];
        c = f.filter(c, function(t) {
            return !t.isRemoved()
        }), s(c, u);
        var d = l(e, c, u);
        if (0 === d.sum)
            return t.viewChildren = [];
        if (d.sum = o(e, i, d.sum, u, c), 0 === d.sum)
            return t.viewChildren = [];
        for (var p = 0, g = c.length; p < g; p++) {
            var m = c[p].getValue() / d.sum * i;
            c[p].setLayout({
                area: m
            })
        }
        return h && (c.length && t.setLayout({
            isLeafRoot: !0
        }, !0), c.length = 0), t.viewChildren = c, t.setLayout({
            dataExtent: d.dataExtent
        }, !0), c
    }
    function o(t, e, i, n, r) {
        if (!n)
            return i;
        for (var a = t.get("visibleMin"), o = r.length, s = o, l = o - 1; l >= 0; l--) {
            var c = r["asc" === n ? o - l - 1 : l].getValue();
            c / i * e < a && (s = l, i -= c)
        }
        return "asc" === n ? r.splice(0, o - s) : r.splice(s, o - s), i
    }
    function s(t, e) {
        return e && t.sort(function(t, i) {
            return "asc" === e ? t.getValue() - i.getValue() : i.getValue() - t.getValue()
        }), t
    }
    function l(t, e, i) {
        for (var n = 0, r = 0, a = e.length; r < a; r++)
            n += e[r].getValue();
        var o,
            s = t.get("visualDimension");
        if (e && e.length)
            if ("value" === s && i)
                o = [e[e.length - 1].getValue(), e[0].getValue()], "asc" === i && o.reverse();
            else {
                var o = [1 / 0, -(1 / 0)];
                M(e, function(t) {
                    var e = t.getValue(s);
                    e < o[0] && (o[0] = e), e > o[1] && (o[1] = e)
                })
            }
        else
            o = [NaN, NaN];
        return {
            sum: n,
            dataExtent: o
        }
    }
    function c(t, e, i) {
        for (var n, r = 0, a = 1 / 0, o = 0, s = t.length; o < s; o++)
            n = t[o].getLayout().area, n && (n < a && (a = n), n > r && (r = n));
        var l = t.area * t.area,
            c = e * e * i;
        return l ? x(c * r / l, l / (c * a)) : 1 / 0
    }
    function u(t, e, i, n, r) {
        var a = e === i.width ? 0 : 1,
            o = 1 - a,
            s = ["x", "y"],
            l = ["width", "height"],
            c = i[s[a]],
            u = e ? t.area / e : 0;
        (r || u > i[l[o]]) && (u = i[l[o]]);
        for (var h = 0, d = t.length; h < d; h++) {
            var p = t[h],
                f = {},
                g = u ? p.getLayout().area / u : 0,
                m = f[l[o]] = x(u - 2 * n, 0),
                v = i[s[a]] + i[l[a]] - c,
                y = h === d - 1 || v < g ? v : g,
                b = f[l[a]] = x(y - 2 * n, 0);
            f[s[o]] = i[s[o]] + _(n, m / 2), f[s[a]] = c + _(n, b / 2), c += y, p.setLayout(f, !0)
        }
        i[s[o]] += u, i[l[o]] -= u
    }
    function h(t, e, i, n, r) {
        var a = (e || {}).node,
            o = [n, r];
        if (!a || a === i)
            return o;
        for (var s, l = n * r, c = l * t.option.zoomToNodeRatio; s = a.parentNode;) {
            for (var u = 0, h = s.children, d = 0, p = h.length; d < p; d++)
                u += h[d].getValue();
            var f = a.getValue();
            if (0 === f)
                return o;
            c *= u / f;
            var m = s.getModel("itemStyle.normal").get("borderWidth");
            isFinite(m) && (c += 4 * m * m + 4 * m * Math.pow(c, .5)), c > g.MAX_SAFE_INTEGER && (c = g.MAX_SAFE_INTEGER), a = s
        }
        c < l && (c = l);
        var v = Math.pow(c / l, .5);
        return [n * v, r * v]
    }
    function d(t, e, i) {
        if (e)
            return {
                x: e.x,
                y: e.y
            };
        var n = {
            x: 0,
            y: 0
        };
        if (!i)
            return n;
        var r = i.node,
            a = r.getLayout();
        if (!a)
            return n;
        for (var o = [a.width / 2, a.height / 2], s = r; s;) {
            var l = s.getLayout();
            o[0] += l.x, o[1] += l.y, s = s.parentNode
        }
        return {
            x: t.width / 2 - o[0],
            y: t.height / 2 - o[1]
        }
    }
    function p(t, e, i, n, r) {
        var a = t.getLayout(),
            o = i[r],
            s = o && o === t;
        if (!(o && !s || r === i.length && t !== n)) {
            t.setLayout({
                isInView: !0,
                invisible: !s && !e.intersect(a),
                isAboveViewRoot: s
            }, !0);
            var l = new y(e.x - a.x, e.y - a.y, e.width, e.height);
            M(t.viewChildren || [], function(t) {
                p(t, l, i, n, r + 1)
            })
        }
    }
    var f = i(509),
        g = i(512),
        m = i(526),
        v = i(693),
        y = i(514),
        v = i(693),
        x = Math.max,
        _ = Math.min,
        b = g.parsePercent,
        w = f.retrieve,
        M = f.each;
    t.exports = n
}, function(t, e, i) {
    var n = i(506),
        r = i(509);
    i(702), i(705), i(710), n.registerProcessor(i(711)), n.registerVisual(r.curry(i(615), "graph", "circle", null)), n.registerVisual(i(712)), n.registerVisual(i(713)), n.registerLayout(i(714)), n.registerLayout(i(717)), n.registerLayout(i(719)), n.registerCoordinateSystem("graphView", {
        create: i(721)
    })
}, function(t, e, i) {
    "use strict";
    var n = i(603),
        r = i(509),
        a = i(510),
        o = i(517),
        s = i(703),
        l = i(506).extendSeriesModel({
            type: "series.graph",
            init: function(t) {
                l.superApply(this, "init", arguments), this.legendDataProvider = function() {
                    return this._categoriesData
                }, this.fillDataTextStyle(t.edges || t.links), this._updateCategoriesData()
            },
            mergeOption: function(t) {
                l.superApply(this, "mergeOption", arguments), this.fillDataTextStyle(t.edges || t.links), this._updateCategoriesData()
            },
            mergeDefaultAndTheme: function(t) {
                l.superApply(this, "mergeDefaultAndTheme", arguments), a.defaultEmphasis(t.edgeLabel, a.LABEL_OPTIONS)
            },
            getInitialData: function(t, e) {
                function i(t, e) {
                    t.wrapMethod("getItemModel", function(t) {
                        var e = a._categoriesModels,
                            i = t.getShallow("category"),
                            n = e[i];
                        return n && (n.parentModel = t.parentModel, t.parentModel = n), t
                    });
                    var i = a.getModel("edgeLabel"),
                        n = function(t, e) {
                            var r = (t || "").split(".");
                            "label" === r[0] && (e = e || i.getModel(r.slice(1)));
                            var a = o.prototype.getModel.call(this, r, e);
                            return a.getModel = n, a
                        };
                    e.wrapMethod("getItemModel", function(t) {
                        return t.getModel = n, t
                    })
                }
                var n = t.edges || t.links || [],
                    r = t.data || t.nodes || [],
                    a = this;
                if (r && n)
                    return s(r, n, this, !0, i).data
            },
            getGraph: function() {
                return this.getData().graph
            },
            getEdgeData: function() {
                return this.getGraph().edgeData
            },
            getCategoriesData: function() {
                return this._categoriesData
            },
            formatTooltip: function(t, e, i) {
                if ("edge" === i) {
                    var n = this.getData(),
                        r = this.getDataParams(t, i),
                        a = n.graph.getEdgeByIndex(t),
                        o = n.getName(a.node1.dataIndex),
                        s = n.getName(a.node2.dataIndex),
                        c = o + " > " + s;
                    return r.value && (c += " : " + r.value), c
                }
                return l.superApply(this, "formatTooltip", arguments)
            },
            _updateCategoriesData: function() {
                var t = r.map(this.option.categories || [], function(t) {
                        return null != t.value ? t : r.extend({
                            value: 0
                        }, t)
                    }),
                    e = new n(["value"], this);
                e.initData(t), this._categoriesData = e, this._categoriesModels = e.mapArray(function(t) {
                    return e.getItemModel(t, !0)
                })
            },
            setZoom: function(t) {
                this.option.zoom = t
            },
            setCenter: function(t) {
                this.option.center = t
            },
            ifEnableAnimation: function() {
                return l.superCall(this, "ifEnableAnimation") && !("force" === this.get("layout") && this.get("force.layoutAnimation"))
            },
            defaultOption: {
                zlevel: 0,
                z: 2,
                coordinateSystem: "view",
                legendHoverLink: !0,
                hoverAnimation: !0,
                layout: null,
                focusNodeAdjacency: !1,
                circular: {
                    rotateLabel: !1
                },
                force: {
                    initLayout: null,
                    repulsion: [0, 50],
                    gravity: .1,
                    edgeLength: 30,
                    layoutAnimation: !0
                },
                left: "center",
                top: "center",
                symbol: "circle",
                symbolSize: 10,
                edgeSymbol: ["none", "none"],
                edgeSymbolSize: 10,
                edgeLabel: {
                    normal: {
                        position: "middle"
                    },
                    emphasis: {}
                },
                draggable: !1,
                roam: !1,
                center: null,
                zoom: 1,
                nodeScaleRatio: .6,
                label: {
                    normal: {
                        show: !1,
                        formatter: "{b}"
                    },
                    emphasis: {
                        show: !0
                    }
                },
                itemStyle: {
                    normal: {},
                    emphasis: {}
                },
                lineStyle: {
                    normal: {
                        color: "#aaa",
                        width: 1,
                        curveness: 0,
                        opacity: .5
                    },
                    emphasis: {}
                }
            }
        });
    t.exports = l
}, function(t, e, i) {
    var n = i(603),
        r = i(704),
        a = i(692),
        o = i(608),
        s = i(531),
        l = i(509),
        c = i(607);
    t.exports = function(t, e, i, u, h) {
        for (var d = new r(u), p = 0; p < t.length; p++)
            d.addNode(l.retrieve(t[p].id, t[p].name, p), p);
        for (var f = [], g = [], m = 0, p = 0; p < e.length; p++) {
            var v = e[p],
                y = v.source,
                x = v.target;
            d.addEdge(y, x, m) && (g.push(v), f.push(l.retrieve(v.id, y + " > " + x)), m++)
        }
        var _,
            b = i.get("coordinateSystem");
        if ("cartesian2d" === b || "polar" === b)
            _ = c(t, i, i.ecModel);
        else {
            var w = s.get(b),
                M = o((w && "view" !== w.type ? w.dimensions || [] : []).concat(["value"]), t);
            _ = new n(M, i), _.initData(t)
        }
        var S = new n(["value"], i);
        return S.initData(g, f), h && h(_, S), a({
            mainData: _,
            struct: d,
            structAttr: "graph",
            datas: {
                node: _,
                edge: S
            },
            datasAttr: {
                node: "data",
                edge: "edgeData"
            }
        }), d.update(), d
    }
}, function(t, e, i) {
    "use strict";
    function n(t, e) {
        this.id = null == t ? "" : t, this.inEdges = [], this.outEdges = [], this.edges = [], this.hostGraph, this.dataIndex = null == e ? -1 : e
    }
    function r(t, e, i) {
        this.node1 = t, this.node2 = e, this.dataIndex = null == i ? -1 : i
    }
    var a = i(509),
        o = function(t) {
            this._directed = t || !1, this.nodes = [], this.edges = [], this._nodesMap = {}, this._edgesMap = {}, this.data, this.edgeData
        },
        s = o.prototype;
    s.type = "graph", s.isDirected = function() {
        return this._directed
    }, s.addNode = function(t, e) {
        t = t || "" + e;
        var i = this._nodesMap;
        if (!i[t]) {
            var r = new n(t, e);
            return r.hostGraph = this, this.nodes.push(r), i[t] = r, r
        }
    }, s.getNodeByIndex = function(t) {
        var e = this.data.getRawIndex(t);
        return this.nodes[e]
    }, s.getNodeById = function(t) {
        return this._nodesMap[t]
    }, s.addEdge = function(t, e, i) {
        var a = this._nodesMap,
            o = this._edgesMap;
        if ("number" == typeof t && (t = this.nodes[t]), "number" == typeof e && (e = this.nodes[e]), t instanceof n || (t = a[t]), e instanceof n || (e = a[e]), t && e) {
            var s = t.id + "-" + e.id;
            if (!o[s]) {
                var l = new r(t, e, i);
                return l.hostGraph = this, this._directed && (t.outEdges.push(l), e.inEdges.push(l)), t.edges.push(l), t !== e && e.edges.push(l), this.edges.push(l), o[s] = l, l
            }
        }
    }, s.getEdgeByIndex = function(t) {
        var e = this.edgeData.getRawIndex(t);
        return this.edges[e]
    }, s.getEdge = function(t, e) {
        t instanceof n && (t = t.id), e instanceof n && (e = e.id);
        var i = this._edgesMap;
        return this._directed ? i[t + "-" + e] : i[t + "-" + e] || i[e + "-" + t]
    }, s.eachNode = function(t, e) {
        for (var i = this.nodes, n = i.length, r = 0; r < n; r++)
            i[r].dataIndex >= 0 && t.call(e, i[r], r)
    }, s.eachEdge = function(t, e) {
        for (var i = this.edges, n = i.length, r = 0; r < n; r++)
            i[r].dataIndex >= 0 && i[r].node1.dataIndex >= 0 && i[r].node2.dataIndex >= 0 && t.call(e, i[r], r)
    }, s.breadthFirstTraverse = function(t, e, i, r) {
        if (e instanceof n || (e = this._nodesMap[e]), e) {
            for (var a = "out" === i ? "outEdges" : "in" === i ? "inEdges" : "edges", o = 0; o < this.nodes.length; o++)
                this.nodes[o].__visited = !1;
            if (!t.call(r, e, null))
                for (var s = [e]; s.length;)
                    for (var l = s.shift(), c = l[a], o = 0; o < c.length; o++) {
                        var u = c[o],
                            h = u.node1 === l ? u.node2 : u.node1;
                        if (!h.__visited) {
                            if (t.call(h, h, l))
                                return;
                            s.push(h), h.__visited = !0
                        }
                    }
        }
    }, s.update = function() {
        for (var t = this.data, e = this.edgeData, i = this.nodes, n = this.edges, r = 0, a = i.length; r < a; r++)
            i[r].dataIndex = -1;
        for (var r = 0, a = t.count(); r < a; r++)
            i[t.getRawIndex(r)].dataIndex = r;
        e.filterSelf(function(t) {
            var i = n[e.getRawIndex(t)];
            return i.node1.dataIndex >= 0 && i.node2.dataIndex >= 0
        });
        for (var r = 0, a = n.length; r < a; r++)
            n[r].dataIndex = -1;
        for (var r = 0, a = e.count(); r < a; r++)
            n[e.getRawIndex(r)].dataIndex = r
    }, s.clone = function() {
        for (var t = new o(this._directed), e = this.nodes, i = this.edges, n = 0; n < e.length; n++)
            t.addNode(e[n].id, e[n].dataIndex);
        for (var n = 0; n < i.length; n++) {
            var r = i[n];
            t.addEdge(r.node1.id, r.node2.id, r.dataIndex)
        }
        return t
    }, n.prototype = {
        constructor: n,
        degree: function() {
            return this.edges.length
        },
        inDegree: function() {
            return this.inEdges.length
        },
        outDegree: function() {
            return this.outEdges.length
        },
        getModel: function(t) {
            if (!(this.dataIndex < 0)) {
                var e = this.hostGraph,
                    i = e.data.getItemModel(this.dataIndex);
                return i.getModel(t)
            }
        }
    }, r.prototype.getModel = function(t) {
        if (!(this.dataIndex < 0)) {
            var e = this.hostGraph,
                i = e.edgeData.getItemModel(this.dataIndex);
            return i.getModel(t)
        }
    };
    var l = function(t, e) {
        return {
            getValue: function(i) {
                var n = this[t][e];
                return n.get(n.getDimension(i || "value"), this.dataIndex)
            },
            setVisual: function(i, n) {
                this.dataIndex >= 0 && this[t][e].setItemVisual(this.dataIndex, i, n)
            },
            getVisual: function(i, n) {
                return this[t][e].getItemVisual(this.dataIndex, i, n)
            },
            setLayout: function(i, n) {
                this.dataIndex >= 0 && this[t][e].setItemLayout(this.dataIndex, i, n)
            },
            getLayout: function() {
                return this[t][e].getItemLayout(this.dataIndex)
            },
            getGraphicEl: function() {
                return this[t][e].getItemGraphicEl(this.dataIndex)
            },
            getRawIndex: function() {
                return this[t][e].getRawIndex(this.dataIndex)
            }
        }
    };
    a.mixin(n, l("hostGraph", "data")), a.mixin(r, l("hostGraph", "edgeData")), o.Node = n, o.Edge = r, t.exports = o
}, function(t, e, i) {
    function n(t, e) {
        return t.getVisual("opacity") || t.getModel().get(e)
    }
    var r = i(610),
        a = i(706),
        o = i(681),
        s = i(548),
        l = i(709),
        c = i(509),
        u = ["itemStyle", "normal", "opacity"],
        h = ["lineStyle", "normal", "opacity"];
    i(506).extendChartView({
        type: "graph",
        init: function(t, e) {
            var i = new r,
                n = new a,
                s = this.group,
                l = new o(e.getZr(), s);
            s.add(i.group), s.add(n.group), this._symbolDraw = i, this._lineDraw = n, this._controller = l, this._firstRender = !0
        },
        render: function(t, e, i) {
            var n = t.coordinateSystem;
            this._model = t, this._nodeScaleRatio = t.get("nodeScaleRatio");
            var r = this._symbolDraw,
                a = this._lineDraw,
                o = this.group;
            if ("view" === n.type) {
                var c = {
                    position: n.position,
                    scale: n.scale
                };
                this._firstRender ? o.attr(c) : s.updateProps(o, c, t)
            }
            l(t.getGraph(), this._getNodeGlobalScale(t));
            var u = t.getData();
            r.updateData(u);
            var h = t.getEdgeData();
            a.updateData(h), this._updateNodeAndLinkScale(), this._updateController(t, i), clearTimeout(this._layoutTimeout);
            var d = t.forceLayout,
                p = t.get("force.layoutAnimation");
            d && this._startForceLayoutIteration(d, p), u.eachItemGraphicEl(function(t, e) {
                var i = u.getItemModel(e);
                t.off("drag").off("dragend");
                var n = u.getItemModel(e).get("draggable");
                n && t.on("drag", function() {
                    d && (d.warmUp(), !this._layouting && this._startForceLayoutIteration(d, p), d.setFixed(e), u.setItemLayout(e, t.position))
                }, this).on("dragend", function() {
                    d && d.setUnfixed(e)
                }, this), t.setDraggable(n && d), t.off("mouseover", this._focusNodeAdjacency), t.off("mouseout", this._unfocusAll), i.get("focusNodeAdjacency") && (t.on("mouseover", this._focusNodeAdjacency, this), t.on("mouseout", this._unfocusAll, this))
            }, this);
            var f = "circular" === t.get("layout") && t.get("circular.rotateLabel"),
                g = u.getLayout("cx"),
                m = u.getLayout("cy");
            u.eachItemGraphicEl(function(t, e) {
                var i = t.getSymbolPath();
                if (f) {
                    var n = u.getItemLayout(e),
                        r = Math.atan2(n[1] - m, n[0] - g);
                    r < 0 && (r = 2 * Math.PI + r);
                    var a = n[0] < g;
                    a && (r -= Math.PI);
                    var o = a ? "left" : "right";
                    i.setStyle({
                        textRotation: r,
                        textPosition: o
                    }), i.hoverStyle && (i.hoverStyle.textPosition = o)
                } else
                    i.setStyle({
                        textRotation: 0
                    })
            }), this._firstRender = !1
        },
        dispose: function() {
            this._controller && this._controller.dispose()
        },
        _focusNodeAdjacency: function(t) {
            function e(t, e) {
                var i = n(t, e),
                    r = t.getGraphicEl();
                null == i && (i = 1), r.traverse(function(t) {
                    t.trigger("normal"), "group" !== t.type && t.setStyle("opacity", .1 * i)
                })
            }
            function i(t, e) {
                var i = n(t, e),
                    r = t.getGraphicEl();
                r.traverse(function(t) {
                    t.trigger("emphasis"), "group" !== t.type && t.setStyle("opacity", i)
                })
            }
            var r = this._model.getData(),
                a = r.graph,
                o = t.target,
                s = o.dataIndex,
                l = o.dataType;
            if (null !== s && "edge" !== l) {
                a.eachNode(function(t) {
                    e(t, u)
                }), a.eachEdge(function(t) {
                    e(t, h)
                });
                var d = a.getNodeByIndex(s);
                i(d, u), c.each(d.edges, function(t) {
                    t.dataIndex < 0 || (i(t, h), i(t.node1, u), i(t.node2, u))
                })
            }
        },
        _unfocusAll: function() {
            var t = this._model.getData(),
                e = t.graph;
            e.eachNode(function(t) {
                var e = n(t, u);
                t.getGraphicEl().traverse(function(t) {
                    t.trigger("normal"), "group" !== t.type && t.setStyle("opacity", e)
                })
            }), e.eachEdge(function(t) {
                var e = n(t, h);
                t.getGraphicEl().traverse(function(t) {
                    t.trigger("normal"), "group" !== t.type && t.setStyle("opacity", e)
                })
            })
        },
        _startForceLayoutIteration: function(t, e) {
            var i = this;
            !function n() {
                t.step(function(t) {
                    i.updateLayout(i._model), (i._layouting = !t) && (e ? i._layoutTimeout = setTimeout(n, 16) : n())
                })
            }()
        },
        _updateController: function(t, e) {
            var i = this._controller,
                n = this.group;
            return i.setContainsPoint(function(t, e) {
                var i = n.getBoundingRect();
                return i.applyTransform(n.transform), i.contain(t, e)
            }), "view" !== t.coordinateSystem.type ? void i.disable() : (i.enable(t.get("roam")), i.zoomLimit = t.get("scaleLimit"), i.zoom = t.coordinateSystem.getZoom(), void i.off("pan").off("zoom").on("pan", function(i, n) {
                e.dispatchAction({
                    seriesId: t.id,
                    type: "graphRoam",
                    dx: i,
                    dy: n
                })
            }).on("zoom", function(i, n, r) {
                e.dispatchAction({
                    seriesId: t.id,
                    type: "graphRoam",
                    zoom: i,
                    originX: n,
                    originY: r
                }), this._updateNodeAndLinkScale(), l(t.getGraph(), this._getNodeGlobalScale(t)), this._lineDraw.updateLayout()
            }, this))
        },
        _updateNodeAndLinkScale: function() {
            var t = this._model,
                e = t.getData(),
                i = this._getNodeGlobalScale(t),
                n = [i, i];
            e.eachItemGraphicEl(function(t, e) {
                t.attr("scale", n)
            })
        },
        _getNodeGlobalScale: function(t) {
            var e = t.coordinateSystem;
            if ("view" !== e.type)
                return 1;
            var i = this._nodeScaleRatio,
                n = e.scale,
                r = n && n[0] || 1,
                a = e.getZoom(),
                o = (a - 1) * i + 1;
            return o / r
        },
        updateLayout: function(t) {
            l(t.getGraph(), this._getNodeGlobalScale(t)), this._symbolDraw.updateLayout(), this._lineDraw.updateLayout()
        },
        remove: function(t, e) {
            this._symbolDraw && this._symbolDraw.remove(), this._lineDraw && this._lineDraw.remove()
        }
    })
}, function(t, e, i) {
    function n(t) {
        return isNaN(t[0]) || isNaN(t[1])
    }
    function r(t) {
        return !n(t[0]) && !n(t[1])
    }
    function a(t) {
        this._ctor = t || s, this.group = new o.Group
    }
    var o = i(548),
        s = i(707),
        l = a.prototype;
    l.updateData = function(t) {
        var e = this._lineData,
            i = this.group,
            n = this._ctor,
            a = t.hostModel,
            o = {
                lineStyle: a.getModel("lineStyle.normal").getLineStyle(),
                hoverLineStyle: a.getModel("lineStyle.emphasis").getLineStyle(),
                labelModel: a.getModel("label.normal"),
                hoverLabelModel: a.getModel("label.emphasis")
            };
        t.diff(e).add(function(e) {
            if (r(t.getItemLayout(e))) {
                var a = new n(t, e, o);
                t.setItemGraphicEl(e, a), i.add(a)
            }
        }).update(function(a, s) {
            var l = e.getItemGraphicEl(s);
            return r(t.getItemLayout(a)) ? (l ? l.updateData(t, a, o) : l = new n(t, a, o), t.setItemGraphicEl(a, l), void i.add(l)) : void i.remove(l)
        }).remove(function(t) {
            i.remove(e.getItemGraphicEl(t))
        }).execute(), this._lineData = t
    }, l.updateLayout = function() {
        var t = this._lineData;
        t.eachItemGraphicEl(function(e, i) {
            e.updateLayout(t, i)
        }, this)
    }, l.remove = function() {
        this.group.removeAll()
    }, t.exports = a
}, function(t, e, i) {
    function n(t) {
        return "_" + t + "Type"
    }
    function r(t, e, i) {
        var n = e.getItemVisual(i, "color"),
            r = e.getItemVisual(i, t),
            a = e.getItemVisual(i, t + "Size");
        if (r && "none" !== r) {
            p.isArray(a) || (a = [a, a]);
            var o = c.createSymbol(r, -a[0] / 2, -a[1] / 2, a[0], a[1], n);
            return o.name = t, o
        }
    }
    function a(t) {
        var e = new h({
            name: "line"
        });
        return o(e.shape, t), e
    }
    function o(t, e) {
        var i = e[0],
            n = e[1],
            r = e[2];
        t.x1 = i[0], t.y1 = i[1], t.x2 = n[0], t.y2 = n[1], t.percent = 1, r ? (t.cpx1 = r[0], t.cpy1 = r[1]) : (t.cpx1 = NaN, t.cpy1 = NaN)
    }
    function s() {
        var t = this,
            e = t.childOfName("fromSymbol"),
            i = t.childOfName("toSymbol"),
            n = t.childOfName("label");
        if (e || i || !n.ignore) {
            for (var r = 1, a = this.parent; a;)
                a.scale && (r /= a.scale[0]), a = a.parent;
            var o = t.childOfName("line");
            if (this.__dirty || o.__dirty) {
                var s = o.shape.percent,
                    l = o.pointAt(0),
                    c = o.pointAt(s),
                    h = u.sub([], c, l);
                if (u.normalize(h, h), e) {
                    e.attr("position", l);
                    var d = o.tangentAt(0);
                    e.attr("rotation", Math.PI / 2 - Math.atan2(d[1], d[0])), e.attr("scale", [r * s, r * s])
                }
                if (i) {
                    i.attr("position", c);
                    var d = o.tangentAt(1);
                    i.attr("rotation", -Math.PI / 2 - Math.atan2(d[1], d[0])), i.attr("scale", [r * s, r * s])
                }
                if (!n.ignore) {
                    n.attr("position", c);
                    var p,
                        f,
                        g,
                        m = 5 * r;
                    if ("end" === n.__position)
                        p = [h[0] * m + c[0], h[1] * m + c[1]], f = h[0] > .8 ? "left" : h[0] < -.8 ? "right" : "center", g = h[1] > .8 ? "top" : h[1] < -.8 ? "bottom" : "middle";
                    else if ("middle" === n.__position) {
                        var v = s / 2,
                            d = o.tangentAt(v),
                            y = [d[1], -d[0]],
                            x = o.pointAt(v);
                        y[1] > 0 && (y[0] = -y[0], y[1] = -y[1]), p = [x[0] + y[0] * m, x[1] + y[1] * m], f = "center", g = "bottom";
                        var _ = -Math.atan2(d[1], d[0]);
                        c[0] < l[0] && (_ = Math.PI + _), n.attr("rotation", _)
                    } else
                        p = [-h[0] * m + l[0], -h[1] * m + l[1]], f = h[0] > .8 ? "right" : h[0] < -.8 ? "left" : "center", g = h[1] > .8 ? "bottom" : h[1] < -.8 ? "top" : "middle";
                    n.attr({
                        style: {
                            textVerticalAlign: n.__verticalAlign || g,
                            textAlign: n.__textAlign || f
                        },
                        position: p,
                        scale: [r, r]
                    })
                }
            }
        }
    }
    function l(t, e, i) {
        d.Group.call(this), this._createLine(t, e, i)
    }
    var c = i(612),
        u = i(515),
        h = i(708),
        d = i(548),
        p = i(509),
        f = i(512),
        g = ["fromSymbol", "toSymbol"],
        m = l.prototype;
    m.beforeUpdate = s, m._createLine = function(t, e, i) {
        var o = t.hostModel,
            s = t.getItemLayout(e),
            l = a(s);
        l.shape.percent = 0, d.initProps(l, {
            shape: {
                percent: 1
            }
        }, o, e), this.add(l);
        var c = new d.Text({
            name: "label"
        });
        this.add(c), p.each(g, function(i) {
            var a = r(i, t, e);
            this.add(a), this[n(i)] = t.getItemVisual(e, i)
        }, this), this._updateCommonStl(t, e, i)
    }, m.updateData = function(t, e, i) {
        var a = t.hostModel,
            s = this.childOfName("line"),
            l = t.getItemLayout(e),
            c = {
                shape: {}
            };
        o(c.shape, l), d.updateProps(s, c, a, e), p.each(g, function(i) {
            var a = t.getItemVisual(e, i),
                o = n(i);
            if (this[o] !== a) {
                this.remove(this.childOfName(i));
                var s = r(i, t, e);
                this.add(s)
            }
            this[o] = a
        }, this), this._updateCommonStl(t, e, i)
    }, m._updateCommonStl = function(t, e, i) {
        var n = t.hostModel,
            r = this.childOfName("line"),
            a = i && i.lineStyle,
            o = i && i.hoverLineStyle,
            s = i && i.labelModel,
            l = i && i.hoverLabelModel;
        if (!i || t.hasItemOption) {
            var c = t.getItemModel(e);
            a = c.getModel("lineStyle.normal").getLineStyle(), o = c.getModel("lineStyle.emphasis").getLineStyle(), s = c.getModel("label.normal"), l = c.getModel("label.emphasis")
        }
        var u = t.getItemVisual(e, "color"),
            h = p.retrieve(t.getItemVisual(e, "opacity"), a.opacity, 1);
        r.useStyle(p.defaults({
            strokeNoScale: !0,
            fill: "none",
            stroke: u,
            opacity: h
        }, a)), r.hoverStyle = o, p.each(g, function(t) {
            var e = this.childOfName(t);
            e && (e.setColor(u), e.setStyle({
                opacity: h
            }))
        }, this);
        var m,
            v,
            y = s.getShallow("show"),
            x = l.getShallow("show"),
            _ = this.childOfName("label");
        if (y || x) {
            var b = n.getRawValue(e);
            v = null == b ? v = t.getName(e) : isFinite(b) ? f.round(b) : b, m = u || "#000"
        }
        if (y) {
            var w = s.getModel("textStyle");
            _.setStyle({
                text: p.retrieve(n.getFormattedLabel(e, "normal", t.dataType), v),
                textFont: w.getFont(),
                fill: w.getTextColor() || m
            }), _.__textAlign = w.get("align"), _.__verticalAlign = w.get("baseline"), _.__position = s.get("position")
        } else
            _.setStyle("text", "");
        if (x) {
            var M = l.getModel("textStyle");
            _.hoverStyle = {
                text: p.retrieve(n.getFormattedLabel(e, "emphasis", t.dataType), v),
                textFont: M.getFont(),
                fill: M.getTextColor() || m
            }
        } else
            _.hoverStyle = {
                text: ""
            };
        _.ignore = !y && !x, d.setHoverStyle(this)
    }, m.updateLayout = function(t, e) {
        this.setLinePoints(t.getItemLayout(e))
    }, m.setLinePoints = function(t) {
        var e = this.childOfName("line");
        o(e.shape, t), e.dirty()
    }, p.inherits(l, d.Group), t.exports = l
}, function(t, e, i) {
    function n(t) {
        return isNaN(+t.cpx1) || isNaN(+t.cpy1)
    }
    var r = i(548),
        a = i(515),
        o = r.Line.prototype,
        s = r.BezierCurve.prototype;
    t.exports = r.extendShape({
        type: "ec-line",
        style: {
            stroke: "#000",
            fill: null
        },
        shape: {
            x1: 0,
            y1: 0,
            x2: 0,
            y2: 0,
            percent: 1,
            cpx1: null,
            cpy1: null
        },
        buildPath: function(t, e) {
            (n(e) ? o : s).buildPath(t, e)
        },
        pointAt: function(t) {
            return n(this.shape) ? o.pointAt.call(this, t) : s.pointAt.call(this, t)
        },
        tangentAt: function(t) {
            var e = this.shape,
                i = n(e) ? [e.x2 - e.x1, e.y2 - e.y1] : s.tangentAt.call(this, t);
            return a.normalize(i, i)
        }
    })
}, function(t, e, i) {
    function n(t, e, i) {
        for (var n, r = t[0], a = t[1], d = t[2], p = 1 / 0, f = i * i, g = .1, m = .1; m <= .9; m += .1) {
            o[0] = c(r[0], a[0], d[0], m), o[1] = c(r[1], a[1], d[1], m);
            var v = h(u(o, e) - f);
            v < p && (p = v, n = m)
        }
        for (var y = 0; y < 32; y++) {
            var x = n + g;
            s[0] = c(r[0], a[0], d[0], n), s[1] = c(r[1], a[1], d[1], n), l[0] = c(r[0], a[0], d[0], x), l[1] = c(r[1], a[1], d[1], x);
            var v = u(s, e) - f;
            if (h(v) < .01)
                break;
            var _ = u(l, e) - f;
            g /= 2, v < 0 ? _ >= 0 ? n += g : n -= g : _ >= 0 ? n -= g : n += g
        }
        return n
    }
    var r = i(555),
        a = i(515),
        o = [],
        s = [],
        l = [],
        c = r.quadraticAt,
        u = a.distSquare,
        h = Math.abs;
    t.exports = function(t, e) {
        function i(t) {
            var e = t.getVisual("symbolSize");
            return e instanceof Array && (e = (e[0] + e[1]) / 2), e
        }
        var o = [],
            s = r.quadraticSubdivide,
            l = [[], [], []],
            c = [[], []],
            u = [];
        e /= 2, t.eachEdge(function(t, r) {
            var h = t.getLayout(),
                d = t.getVisual("fromSymbol"),
                p = t.getVisual("toSymbol");
            h.__original || (h.__original = [a.clone(h[0]), a.clone(h[1])], h[2] && h.__original.push(a.clone(h[2])));
            var f = h.__original;
            if (null != h[2]) {
                if (a.copy(l[0], f[0]), a.copy(l[1], f[2]), a.copy(l[2], f[1]), d && "none" != d) {
                    var g = i(t.node1),
                        m = n(l, f[0], g * e);
                    s(l[0][0], l[1][0], l[2][0], m, o), l[0][0] = o[3], l[1][0] = o[4], s(l[0][1], l[1][1], l[2][1], m, o), l[0][1] = o[3], l[1][1] = o[4]
                }
                if (p && "none" != p) {
                    var g = i(t.node2),
                        m = n(l, f[1], g * e);
                    s(l[0][0], l[1][0], l[2][0], m, o), l[1][0] = o[1], l[2][0] = o[2], s(l[0][1], l[1][1], l[2][1], m, o), l[1][1] = o[1], l[2][1] = o[2]
                }
                a.copy(h[0], l[0]), a.copy(h[1], l[2]), a.copy(h[2], l[1])
            } else {
                if (a.copy(c[0], f[0]), a.copy(c[1], f[1]), a.sub(u, c[1], c[0]), a.normalize(u, u), d && "none" != d) {
                    var g = i(t.node1);
                    a.scaleAndAdd(c[0], c[0], u, g * e)
                }
                if (p && "none" != p) {
                    var g = i(t.node2);
                    a.scaleAndAdd(c[1], c[1], u, -g * e)
                }
                a.copy(h[0], c[0]), a.copy(h[1], c[1])
            }
        })
    }
}, function(t, e, i) {
    var n = i(506),
        r = i(684),
        a = {
            type: "graphRoam",
            event: "graphRoam",
            update: "none"
        };
    n.registerAction(a, function(t, e) {
        e.eachComponent({
            mainType: "series",
            query: t
        }, function(e) {
            var i = e.coordinateSystem,
                n = r.updateCenterAndZoom(i, t);
            e.setCenter && e.setCenter(n.center), e.setZoom && e.setZoom(n.zoom)
        })
    })
}, function(t, e) {
    t.exports = function(t) {
        var e = t.findComponents({
            mainType: "legend"
        });
        e && e.length && t.eachSeriesByType("graph", function(t) {
            var i = t.getCategoriesData(),
                n = t.getGraph(),
                r = n.data,
                a = i.mapArray(i.getName);
            r.filterSelf(function(t) {
                var i = r.getItemModel(t),
                    n = i.getShallow("category");
                if (null != n) {
                    "number" == typeof n && (n = a[n]);
                    for (var o = 0; o < e.length; o++)
                        if (!e[o].isSelected(n))
                            return !1
                }
                return !0
            })
        }, this)
    }
}, function(t, e) {
    t.exports = function(t) {
        var e = {};
        t.eachSeriesByType("graph", function(t) {
            var i = t.getCategoriesData(),
                n = t.getData(),
                r = {};
            i.each(function(n) {
                var a = i.getName(n);
                r[a] = n;
                var o = i.getItemModel(n),
                    s = o.get("itemStyle.normal.color") || t.getColorFromPalette(a, e);
                i.setItemVisual(n, "color", s)
            }), i.count() && n.each(function(t) {
                var e = n.getItemModel(t),
                    a = e.getShallow("category");
                null != a && ("string" == typeof a && (a = r[a]), n.getItemVisual(t, "color", !0) || n.setItemVisual(t, "color", i.getItemVisual(a, "color")))
            })
        })
    }
}, function(t, e) {
    function i(t) {
        return t instanceof Array || (t = [t, t]), t
    }
    t.exports = function(t) {
        t.eachSeriesByType("graph", function(t) {
            var e = t.getGraph(),
                n = t.getEdgeData(),
                r = i(t.get("edgeSymbol")),
                a = i(t.get("edgeSymbolSize")),
                o = "lineStyle.normal.color".split("."),
                s = "lineStyle.normal.opacity".split(".");
            n.setVisual("fromSymbol", r && r[0]), n.setVisual("toSymbol", r && r[1]), n.setVisual("fromSymbolSize", a && a[0]), n.setVisual("toSymbolSize", a && a[1]), n.setVisual("color", t.get(o)), n.setVisual("opacity", t.get(s)), n.each(function(t) {
                var r = n.getItemModel(t),
                    a = e.getEdgeByIndex(t),
                    l = i(r.getShallow("symbol", !0)),
                    c = i(r.getShallow("symbolSize", !0)),
                    u = r.get(o),
                    h = r.get(s);
                switch (u) {
                case "source":
                    u = a.node1.getVisual("color");
                    break;
                case "target":
                    u = a.node2.getVisual("color")
                }
                l[0] && a.setVisual("fromSymbol", l[0]), l[1] && a.setVisual("toSymbol", l[1]), c[0] && a.setVisual("fromSymbolSize", c[0]), c[1] && a.setVisual("toSymbolSize", c[1]), a.setVisual("color", u), a.setVisual("opacity", h)
            })
        })
    }
}, function(t, e, i) {
    var n = i(715),
        r = i(716);
    t.exports = function(t, e) {
        t.eachSeriesByType("graph", function(t) {
            var e = t.get("layout"),
                i = t.coordinateSystem;
            if (i && "view" !== i.type) {
                var a = t.getData();
                a.each(i.dimensions, function(t, e, n) {
                    isNaN(t) || isNaN(e) ? a.setItemLayout(n, [NaN, NaN]) : a.setItemLayout(n, i.dataToPoint([t, e]))
                }), r(a.graph)
            } else
                e && "none" !== e || n(t)
        })
    }
}, function(t, e, i) {
    var n = i(716);
    t.exports = function(t) {
        var e = t.coordinateSystem;
        if (!e || "view" === e.type) {
            var i = t.getGraph();
            i.eachNode(function(t) {
                var e = t.getModel();
                t.setLayout([+e.get("x"), +e.get("y")])
            }), n(i)
        }
    }
}, function(t, e, i) {
    var n = i(515);
    t.exports = function(t) {
        t.eachEdge(function(t) {
            var e = t.getModel().get("lineStyle.normal.curveness") || 0,
                i = n.clone(t.node1.getLayout()),
                r = n.clone(t.node2.getLayout()),
                a = [i, r];
            +e && a.push([(i[0] + r[0]) / 2 - (i[1] - r[1]) * e, (i[1] + r[1]) / 2 - (r[0] - i[0]) * e]), t.setLayout(a)
        })
    }
}, function(t, e, i) {
    var n = i(718);
    t.exports = function(t) {
        t.eachSeriesByType("graph", function(t) {
            "circular" === t.get("layout") && n(t)
        })
    }
}, function(t, e, i) {
    var n = i(515);
    t.exports = function(t) {
        var e = t.coordinateSystem;
        if (!e || "view" === e.type) {
            var i = e.getBoundingRect(),
                r = t.getData(),
                a = r.graph,
                o = 0,
                s = r.getSum("value"),
                l = 2 * Math.PI / (s || r.count()),
                c = i.width / 2 + i.x,
                u = i.height / 2 + i.y,
                h = Math.min(i.width, i.height) / 2;
            a.eachNode(function(t) {
                var e = t.getValue("value");
                o += l * (s ? e : 1) / 2, t.setLayout([h * Math.cos(o) + c, h * Math.sin(o) + u]), o += l * (s ? e : 1) / 2
            }), r.setLayout({
                cx: c,
                cy: u
            }), a.eachEdge(function(t) {
                var e,
                    i = t.getModel().get("lineStyle.normal.curveness") || 0,
                    r = n.clone(t.node1.getLayout()),
                    a = n.clone(t.node2.getLayout()),
                    o = (r[0] + a[0]) / 2,
                    s = (r[1] + a[1]) / 2;
                +i && (i *= 3, e = [c * i + o * (1 - i), u * i + s * (1 - i)]), t.setLayout([r, a, e])
            })
        }
    }
}, function(t, e, i) {
    var n = i(720),
        r = i(512),
        a = i(715),
        o = i(718),
        s = i(515),
        l = i(509);
    t.exports = function(t) {
        t.eachSeriesByType("graph", function(t) {
            var e = t.coordinateSystem;
            if (!e || "view" === e.type)
                if ("force" === t.get("layout")) {
                    var i = t.preservedPoints || {},
                        c = t.getGraph(),
                        u = c.data,
                        h = c.edgeData,
                        d = t.getModel("force"),
                        p = d.get("initLayout");
                    t.preservedPoints ? u.each(function(t) {
                        var e = u.getId(t);
                        u.setItemLayout(t, i[e] || [NaN, NaN])
                    }) : p && "none" !== p ? "circular" === p && o(t) : a(t);
                    var f = u.getDataExtent("value"),
                        g = h.getDataExtent("value"),
                        m = d.get("repulsion"),
                        v = d.get("edgeLength");
                    l.isArray(m) || (m = [m, m]), l.isArray(v) || (v = [v, v]), v = [v[1], v[0]];
                    var y = u.mapArray("value", function(t, e) {
                            var i = u.getItemLayout(e),
                                n = r.linearMap(t, f, m);
                            return isNaN(n) && (n = (m[0] + m[1]) / 2), {
                                w: n,
                                rep: n,
                                p: !i || isNaN(i[0]) || isNaN(i[1]) ? null : i
                            }
                        }),
                        x = h.mapArray("value", function(t, e) {
                            var i = c.getEdgeByIndex(e),
                                n = r.linearMap(t, g, v);
                            return isNaN(n) && (n = (v[0] + v[1]) / 2), {
                                n1: y[i.node1.dataIndex],
                                n2: y[i.node2.dataIndex],
                                d: n,
                                curveness: i.getModel().get("lineStyle.normal.curveness") || 0
                            }
                        }),
                        e = t.coordinateSystem,
                        _ = e.getBoundingRect(),
                        b = n(y, x, {
                            rect: _,
                            gravity: d.get("gravity")
                        }),
                        w = b.step;
                    b.step = function(t) {
                        for (var e = 0, n = y.length; e < n; e++)
                            y[e].fixed && s.copy(y[e].p, c.getNodeByIndex(e).getLayout());
                        w(function(e, n, r) {
                            for (var a = 0, o = e.length; a < o; a++)
                                e[a].fixed || c.getNodeByIndex(a).setLayout(e[a].p), i[u.getId(a)] = e[a].p;
                            for (var a = 0, o = n.length; a < o; a++) {
                                var l = n[a],
                                    h = c.getEdgeByIndex(a),
                                    d = l.n1.p,
                                    p = l.n2.p,
                                    f = h.getLayout();
                                f = f ? f.slice() : [], f[0] = f[0] || [], f[1] = f[1] || [], s.copy(f[0], d), s.copy(f[1], p), +l.curveness && (f[2] = [(d[0] + p[0]) / 2 - (d[1] - p[1]) * l.curveness, (d[1] + p[1]) / 2 - (p[0] - d[0]) * l.curveness]), h.setLayout(f)
                            }
                            t && t(r)
                        })
                    }, t.forceLayout = b, t.preservedPoints = i, b.step()
                } else
                    t.forceLayout = null
        })
    }
}, function(t, e, i) {
    var n = i(515),
        r = n.scaleAndAdd;
    t.exports = function(t, e, i) {
        for (var a = i.rect, o = a.width, s = a.height, l = [a.x + o / 2, a.y + s / 2], c = null == i.gravity ? .1 : i.gravity, u = 0; u < t.length; u++) {
            var h = t[u];
            h.p || (h.p = n.create(o * (Math.random() - .5) + l[0], s * (Math.random() - .5) + l[1])), h.pp = n.clone(h.p), h.edges = null
        }
        var d = .6;
        return {
            warmUp: function() {
                d = .5
            },
            setFixed: function(e) {
                t[e].fixed = !0
            },
            setUnfixed: function(e) {
                t[e].fixed = !1
            },
            step: function(i) {
                for (var a = [], o = t.length, s = 0; s < e.length; s++) {
                    var u = e[s],
                        h = u.n1,
                        p = u.n2;
                    n.sub(a, p.p, h.p);
                    var f = n.len(a) - u.d,
                        g = p.w / (h.w + p.w);
                    n.normalize(a, a), !h.fixed && r(h.p, h.p, a, g * f * d), !p.fixed && r(p.p, p.p, a, -(1 - g) * f * d)
                }
                for (var s = 0; s < o; s++) {
                    var m = t[s];
                    m.fixed || (n.sub(a, l, m.p), n.scaleAndAdd(m.p, m.p, a, c * d))
                }
                for (var s = 0; s < o; s++)
                    for (var h = t[s], v = s + 1; v < o; v++) {
                        var p = t[v];
                        n.sub(a, p.p, h.p);
                        var f = n.len(a);
                        0 === f && (n.set(a, Math.random() - .5, Math.random() - .5), f = 1);
                        var y = (h.rep + p.rep) / f / f;
                        !h.fixed && r(h.pp, h.pp, a, y), !p.fixed && r(p.pp, p.pp, a, -y)
                    }
                for (var x = [], s = 0; s < o; s++) {
                    var m = t[s];
                    m.fixed || (n.sub(x, m.p, m.pp), n.scaleAndAdd(m.p, m.p, x, d), n.copy(m.pp, m.p))
                }
                d *= .992, i && i(t, e, d < .01)
            }
        }
    }
}, function(t, e, i) {
    function n(t, e, i) {
        var n = t.getBoxLayoutParams();
        return n.aspect = i, a.getLayoutRect(n, {
            width: e.getWidth(),
            height: e.getHeight()
        })
    }
    var r = i(675),
        a = i(526),
        o = i(556);
    t.exports = function(t, e) {
        var i = [];
        return t.eachSeriesByType("graph", function(t) {
            var a = t.get("coordinateSystem");
            if (!a || "view" === a) {
                var s = t.getData(),
                    l = s.mapArray(function(t) {
                        var e = s.getItemModel(t);
                        return [+e.get("x"), +e.get("y")]
                    }),
                    c = [],
                    u = [];
                o.fromPoints(l, c, u), u[0] - c[0] === 0 && (u[0] += 1, c[0] -= 1), u[1] - c[1] === 0 && (u[1] += 1, c[1] -= 1);
                var h = (u[0] - c[0]) / (u[1] - c[1]),
                    d = n(t, e, h);
                isNaN(h) && (c = [d.x, d.y], u = [d.x + d.width, d.y + d.height]);
                var p = u[0] - c[0],
                    f = u[1] - c[1],
                    g = d.width,
                    m = d.height,
                    v = t.coordinateSystem = new r;
                v.zoomLimit = t.get("scaleLimit"), v.setBoundingRect(c[0], c[1], p, f), v.setViewRect(d.x, d.y, g, m), v.setCenter(t.get("center")), v.setZoom(t.get("zoom")), i.push(v)
            }
        }), i
    }
}, function(t, e, i) {
    i(723), i(724)
}, function(t, e, i) {
    var n = i(603),
        r = i(533),
        a = i(509),
        o = r.extend({
            type: "series.gauge",
            getInitialData: function(t, e) {
                var i = new n(["value"], this),
                    r = t.data || [];
                return a.isArray(r) || (r = [r]), i.initData(r), i
            },
            defaultOption: {
                zlevel: 0,
                z: 2,
                center: ["50%", "50%"],
                legendHoverLink: !0,
                radius: "75%",
                startAngle: 225,
                endAngle: -45,
                clockwise: !0,
                min: 0,
                max: 100,
                splitNumber: 10,
                axisLine: {
                    show: !0,
                    lineStyle: {
                        color: [[.2, "#91c7ae"], [.8, "#63869e"], [1, "#c23531"]],
                        width: 30
                    }
                },
                splitLine: {
                    show: !0,
                    length: 30,
                    lineStyle: {
                        color: "#eee",
                        width: 2,
                        type: "solid"
                    }
                },
                axisTick: {
                    show: !0,
                    splitNumber: 5,
                    length: 8,
                    lineStyle: {
                        color: "#eee",
                        width: 1,
                        type: "solid"
                    }
                },
                axisLabel: {
                    show: !0,
                    distance: 5,
                    textStyle: {
                        color: "auto"
                    }
                },
                pointer: {
                    show: !0,
                    length: "80%",
                    width: 8
                },
                itemStyle: {
                    normal: {
                        color: "auto"
                    }
                },
                title: {
                    show: !0,
                    offsetCenter: [0, "-40%"],
                    textStyle: {
                        color: "#333",
                        fontSize: 15
                    }
                },
                detail: {
                    show: !0,
                    backgroundColor: "rgba(0,0,0,0)",
                    borderWidth: 0,
                    borderColor: "#ccc",
                    width: 100,
                    height: 40,
                    offsetCenter: [0, "40%"],
                    textStyle: {
                        color: "auto",
                        fontSize: 30
                    }
                }
            }
        });
    t.exports = o
}, function(t, e, i) {
    function n(t, e) {
        var i = t.get("center"),
            n = e.getWidth(),
            r = e.getHeight(),
            a = Math.min(n, r),
            o = l(i[0], e.getWidth()),
            s = l(i[1], e.getHeight()),
            c = l(t.get("radius"), a / 2);
        return {
            cx: o,
            cy: s,
            r: c
        }
    }
    function r(t, e) {
        return e && ("string" == typeof e ? t = e.replace("{value}", null != t ? t : "") : "function" == typeof e && (t = e(t))), t
    }
    var a = i(725),
        o = i(548),
        s = i(512),
        l = s.parsePercent,
        c = 2 * Math.PI,
        u = i(547).extend({
            type: "gauge",
            render: function(t, e, i) {
                this.group.removeAll();
                var r = t.get("axisLine.lineStyle.color"),
                    a = n(t, i);
                this._renderMain(t, e, i, r, a)
            },
            dispose: function() {},
            _renderMain: function(t, e, i, n, r) {
                for (var a = this.group, s = t.getModel("axisLine"), l = s.getModel("lineStyle"), u = t.get("clockwise"), h = -t.get("startAngle") / 180 * Math.PI, d = -t.get("endAngle") / 180 * Math.PI, p = (d - h) % c, f = h, g = l.get("width"), m = 0; m < n.length; m++) {
                    var v = Math.min(Math.max(n[m][0], 0), 1),
                        d = h + p * v,
                        y = new o.Sector({
                            shape: {
                                startAngle: f,
                                endAngle: d,
                                cx: r.cx,
                                cy: r.cy,
                                clockwise: u,
                                r0: r.r - g,
                                r: r.r
                            },
                            silent: !0
                        });
                    y.setStyle({
                        fill: n[m][1]
                    }), y.setStyle(l.getLineStyle(["color", "borderWidth", "borderColor"])), a.add(y), f = d
                }
                var x = function(t) {
                    if (t <= 0)
                        return n[0][1];
                    for (var e = 0; e < n.length; e++)
                        if (n[e][0] >= t && (0 === e ? 0 : n[e - 1][0]) < t)
                            return n[e][1];
                    return n[e - 1][1]
                };
                if (!u) {
                    var _ = h;
                    h = d, d = _
                }
                this._renderTicks(t, e, i, x, r, h, d, u), this._renderPointer(t, e, i, x, r, h, d, u), this._renderTitle(t, e, i, x, r), this._renderDetail(t, e, i, x, r)
            },
            _renderTicks: function(t, e, i, n, a, c, u, h) {
                for (var d = this.group, p = a.cx, f = a.cy, g = a.r, m = t.get("min"), v = t.get("max"), y = t.getModel("splitLine"), x = t.getModel("axisTick"), _ = t.getModel("axisLabel"), b = t.get("splitNumber"), w = x.get("splitNumber"), M = l(y.get("length"), g), S = l(x.get("length"), g), A = c, I = (u - c) / b, D = I / w, k = y.getModel("lineStyle").getLineStyle(), T = x.getModel("lineStyle").getLineStyle(), C = _.getModel("textStyle"), L = 0; L <= b; L++) {
                    var P = Math.cos(A),
                        E = Math.sin(A);
                    if (y.get("show")) {
                        var O = new o.Line({
                            shape: {
                                x1: P * g + p,
                                y1: E * g + f,
                                x2: P * (g - M) + p,
                                y2: E * (g - M) + f
                            },
                            style: k,
                            silent: !0
                        });
                        "auto" === k.stroke && O.setStyle({
                            stroke: n(L / b)
                        }), d.add(O)
                    }
                    if (_.get("show")) {
                        var R = r(s.round(L / b * (v - m) + m), _.get("formatter")),
                            z = _.get("distance"),
                            V = new o.Text({
                                style: {
                                    text: R,
                                    x: P * (g - M - z) + p,
                                    y: E * (g - M - z) + f,
                                    fill: C.getTextColor(),
                                    textFont: C.getFont(),
                                    textVerticalAlign: E < -.4 ? "top" : E > .4 ? "bottom" : "middle",
                                    textAlign: P < -.4 ? "left" : P > .4 ? "right" : "center"
                                },
                                silent: !0
                            });
                        "auto" === V.style.fill && V.setStyle({
                            fill: n(L / b)
                        }), d.add(V)
                    }
                    if (x.get("show") && L !== b) {
                        for (var N = 0; N <= w; N++) {
                            var P = Math.cos(A),
                                E = Math.sin(A),
                                B = new o.Line({
                                    shape: {
                                        x1: P * g + p,
                                        y1: E * g + f,
                                        x2: P * (g - S) + p,
                                        y2: E * (g - S) + f
                                    },
                                    silent: !0,
                                    style: T
                                });
                            "auto" === T.stroke && B.setStyle({
                                stroke: n((L + N / w) / b)
                            }), d.add(B), A += D
                        }
                        A -= D
                    } else
                        A += I
                }
            },
            _renderPointer: function(t, e, i, n, r, c, u, h) {
                var d = [+t.get("min"), +t.get("max")],
                    p = [c, u],
                    f = t.getData(),
                    g = this._data,
                    m = this.group;
                f.diff(g).add(function(e) {
                    var i = new a({
                        shape: {
                            angle: c
                        }
                    });
                    o.updateProps(i, {
                        shape: {
                            angle: s.linearMap(f.get("value", e), d, p, !0)
                        }
                    }, t), m.add(i), f.setItemGraphicEl(e, i)
                }).update(function(e, i) {
                    var n = g.getItemGraphicEl(i);
                    o.updateProps(n, {
                        shape: {
                            angle: s.linearMap(f.get("value", e), d, p, !0)
                        }
                    }, t), m.add(n), f.setItemGraphicEl(e, n)
                }).remove(function(t) {
                    var e = g.getItemGraphicEl(t);
                    m.remove(e)
                }).execute(), f.eachItemGraphicEl(function(t, e) {
                    var i = f.getItemModel(e),
                        a = i.getModel("pointer");
                    t.setShape({
                        x: r.cx,
                        y: r.cy,
                        width: l(a.get("width"), r.r),
                        r: l(a.get("length"), r.r)
                    }), t.useStyle(i.getModel("itemStyle.normal").getItemStyle()), "auto" === t.style.fill && t.setStyle("fill", n((f.get("value", e) - d[0]) / (d[1] - d[0]))), o.setHoverStyle(t, i.getModel("itemStyle.emphasis").getItemStyle())
                }), this._data = f
            },
            _renderTitle: function(t, e, i, n, r) {
                var a = t.getModel("title");
                if (a.get("show")) {
                    var s = a.getModel("textStyle"),
                        c = a.get("offsetCenter"),
                        u = r.cx + l(c[0], r.r),
                        h = r.cy + l(c[1], r.r),
                        d = new o.Text({
                            style: {
                                x: u,
                                y: h,
                                text: t.getData().getName(0),
                                fill: s.getTextColor(),
                                textFont: s.getFont(),
                                textAlign: "center",
                                textVerticalAlign: "middle"
                            }
                        });
                    this.group.add(d)
                }
            },
            _renderDetail: function(t, e, i, n, a) {
                var c = t.getModel("detail"),
                    u = t.get("min"),
                    h = t.get("max");
                if (c.get("show")) {
                    var d = c.getModel("textStyle"),
                        p = c.get("offsetCenter"),
                        f = a.cx + l(p[0], a.r),
                        g = a.cy + l(p[1], a.r),
                        m = l(c.get("width"), a.r),
                        v = l(c.get("height"), a.r),
                        y = t.getData().get("value", 0),
                        x = new o.Rect({
                            shape: {
                                x: f - m / 2,
                                y: g - v / 2,
                                width: m,
                                height: v
                            },
                            style: {
                                text: r(y, c.get("formatter")),
                                fill: c.get("backgroundColor"),
                                textFill: d.getTextColor(),
                                textFont: d.getFont()
                            }
                        });
                    "auto" === x.style.textFill && x.setStyle("textFill", n(s.linearMap(y, [u, h], [0, 1], !0))), x.setStyle(c.getItemStyle(["color"])), this.group.add(x)
                }
            }
        });
    t.exports = u
}, function(t, e, i) {
    t.exports = i(550).extend({
        type: "echartsGaugePointer",
        shape: {
            angle: 0,
            width: 10,
            r: 10,
            x: 0,
            y: 0
        },
        buildPath: function(t, e) {
            var i = Math.cos,
                n = Math.sin,
                r = e.r,
                a = e.width,
                o = e.angle,
                s = e.x - i(o) * a * (a >= r / 3 ? 1 : 2),
                l = e.y - n(o) * a * (a >= r / 3 ? 1 : 2);
            o = e.angle - Math.PI / 2, t.moveTo(s, l), t.lineTo(e.x + i(o) * a, e.y + n(o) * a), t.lineTo(e.x + i(e.angle) * r, e.y + n(e.angle) * r), t.lineTo(e.x - i(o) * a, e.y - n(o) * a), t.lineTo(s, l)
        }
    })
}, function(t, e, i) {
    var n = i(509),
        r = i(506);
    i(727), i(728), r.registerVisual(n.curry(i(650), "funnel")), r.registerLayout(i(729)), r.registerProcessor(n.curry(i(653), "funnel"))
}, function(t, e, i) {
    "use strict";
    var n = i(603),
        r = i(510),
        a = i(608),
        o = i(506).extendSeriesModel({
            type: "series.funnel",
            init: function(t) {
                o.superApply(this, "init", arguments), this.legendDataProvider = function() {
                    return this._dataBeforeProcessed
                }, this._defaultLabelLine(t)
            },
            getInitialData: function(t, e) {
                var i = a(["value"], t.data),
                    r = new n(i, this);
                return r.initData(t.data), r
            },
            _defaultLabelLine: function(t) {
                r.defaultEmphasis(t.labelLine, ["show"]);
                var e = t.labelLine.normal,
                    i = t.labelLine.emphasis;
                e.show = e.show && t.label.normal.show, i.show = i.show && t.label.emphasis.show
            },
            defaultOption: {
                zlevel: 0,
                z: 2,
                legendHoverLink: !0,
                left: 80,
                top: 60,
                right: 80,
                bottom: 60,
                minSize: "0%",
                maxSize: "100%",
                sort: "descending",
                gap: 0,
                funnelAlign: "center",
                label: {
                    normal: {
                        show: !0,
                        position: "outer"
                    },
                    emphasis: {
                        show: !0
                    }
                },
                labelLine: {
                    normal: {
                        show: !0,
                        length: 20,
                        lineStyle: {
                            width: 1,
                            type: "solid"
                        }
                    },
                    emphasis: {}
                },
                itemStyle: {
                    normal: {
                        borderColor: "#fff",
                        borderWidth: 1
                    },
                    emphasis: {}
                }
            }
        });
    t.exports = o
}, function(t, e, i) {
    function n(t, e) {
        function i() {
            o.ignore = o.hoverIgnore, s.ignore = s.hoverIgnore
        }
        function n() {
            o.ignore = o.normalIgnore, s.ignore = s.normalIgnore
        }
        a.Group.call(this);
        var r = new a.Polygon,
            o = new a.Polyline,
            s = new a.Text;
        this.add(r), this.add(o), this.add(s), this.updateData(t, e, !0), this.on("emphasis", i).on("normal", n).on("mouseover", i).on("mouseout", n)
    }
    function r(t, e, i, n) {
        var r = n.getModel("textStyle"),
            a = n.get("position"),
            s = "inside" === a || "inner" === a || "center" === a;
        return {
            fill: r.getTextColor() || (s ? "#fff" : t.getItemVisual(e, "color")),
            textFont: r.getFont(),
            text: o.retrieve(t.hostModel.getFormattedLabel(e, i), t.getName(e))
        }
    }
    var a = i(548),
        o = i(509),
        s = n.prototype,
        l = ["itemStyle", "normal", "opacity"];
    s.updateData = function(t, e, i) {
        var n = this.childAt(0),
            r = t.hostModel,
            s = t.getItemModel(e),
            c = t.getItemLayout(e),
            u = t.getItemModel(e).get(l);
        u = null == u ? 1 : u, n.useStyle({}), i ? (n.setShape({
            points: c.points
        }), n.setStyle({
            opacity: 0
        }), a.initProps(n, {
            style: {
                opacity: u
            }
        }, r, e)) : a.updateProps(n, {
            style: {
                opacity: u
            },
            shape: {
                points: c.points
            }
        }, r, e);
        var h = s.getModel("itemStyle"),
            d = t.getItemVisual(e, "color");
        n.setStyle(o.defaults({
            lineJoin: "round",
            fill: d
        }, h.getModel("normal").getItemStyle(["opacity"]))), n.hoverStyle = h.getModel("emphasis").getItemStyle(), this._updateLabel(t, e), a.setHoverStyle(this)
    }, s._updateLabel = function(t, e) {
        var i = this.childAt(1),
            n = this.childAt(2),
            o = t.hostModel,
            s = t.getItemModel(e),
            l = t.getItemLayout(e),
            c = l.label,
            u = t.getItemVisual(e, "color");
        a.updateProps(i, {
            shape: {
                points: c.linePoints || c.linePoints
            }
        }, o, e), a.updateProps(n, {
            style: {
                x: c.x,
                y: c.y
            }
        }, o, e), n.attr({
            style: {
                textAlign: c.textAlign,
                textVerticalAlign: c.verticalAlign,
                textFont: c.font
            },
            rotation: c.rotation,
            origin: [c.x, c.y],
            z2: 10
        });
        var h = s.getModel("label.normal"),
            d = s.getModel("label.emphasis"),
            p = s.getModel("labelLine.normal"),
            f = s.getModel("labelLine.emphasis");
        n.setStyle(r(t, e, "normal", h)), n.ignore = n.normalIgnore = !h.get("show"), n.hoverIgnore = !d.get("show"), i.ignore = i.normalIgnore = !p.get("show"), i.hoverIgnore = !f.get("show"), i.setStyle({
            stroke: u
        }), i.setStyle(p.getModel("lineStyle").getLineStyle()), n.hoverStyle = r(t, e, "emphasis", d), i.hoverStyle = f.getModel("lineStyle").getLineStyle()
    }, o.inherits(n, a.Group);
    var c = i(547).extend({
        type: "funnel",
        render: function(t, e, i) {
            var r = t.getData(),
                a = this._data,
                o = this.group;
            r.diff(a).add(function(t) {
                var e = new n(r, t);
                r.setItemGraphicEl(t, e), o.add(e)
            }).update(function(t, e) {
                var i = a.getItemGraphicEl(e);
                i.updateData(r, t), o.add(i), r.setItemGraphicEl(t, i)
            }).remove(function(t) {
                var e = a.getItemGraphicEl(t);
                o.remove(e)
            }).execute(), this._data = r
        },
        remove: function() {
            this.group.removeAll(), this._data = null
        },
        dispose: function() {}
    });
    t.exports = c
}, function(t, e, i) {
    function n(t, e) {
        return o.getLayoutRect(t.getBoxLayoutParams(), {
            width: e.getWidth(),
            height: e.getHeight()
        })
    }
    function r(t, e) {
        for (var i = t.mapArray("value", function(t) {
                return t
            }), n = [], r = "ascending" === e, a = 0, o = t.count(); a < o; a++)
            n[a] = a;
        return n.sort(function(t, e) {
            return r ? i[t] - i[e] : i[e] - i[t]
        }), n
    }
    function a(t) {
        t.each(function(e) {
            var i,
                n,
                r,
                a,
                o = t.getItemModel(e),
                s = o.getModel("label.normal"),
                l = s.get("position"),
                c = o.getModel("labelLine.normal"),
                u = t.getItemLayout(e),
                h = u.points,
                d = "inner" === l || "inside" === l || "center" === l;
            if (d)
                n = (h[0][0] + h[1][0] + h[2][0] + h[3][0]) / 4, r = (h[0][1] + h[1][1] + h[2][1] + h[3][1]) / 4, i = "center", a = [[n, r], [n, r]];
            else {
                var p,
                    f,
                    g,
                    m = c.get("length");
                "left" === l ? (p = (h[3][0] + h[0][0]) / 2, f = (h[3][1] + h[0][1]) / 2, g = p - m, n = g - 5, i = "right") : (p = (h[1][0] + h[2][0]) / 2, f = (h[1][1] + h[2][1]) / 2, g = p + m, n = g + 5, i = "left");
                var v = f;
                a = [[p, f], [g, v]], r = v
            }
            u.label = {
                linePoints: a,
                x: n,
                y: r,
                verticalAlign: "middle",
                textAlign: i,
                inside: d
            }
        })
    }
    var o = i(526),
        s = i(512),
        l = s.parsePercent;
    t.exports = function(t, e, i) {
        t.eachSeriesByType("funnel", function(t) {
            var i = t.getData(),
                o = t.get("sort"),
                c = n(t, e),
                u = r(i, o),
                h = [l(t.get("minSize"), c.width), l(t.get("maxSize"), c.width)],
                d = i.getDataExtent("value"),
                p = t.get("min"),
                f = t.get("max");
            null == p && (p = Math.min(d[0], 0)), null == f && (f = d[1]);
            var g = t.get("funnelAlign"),
                m = t.get("gap"),
                v = (c.height - m * (i.count() - 1)) / i.count(),
                y = c.y,
                x = function(t, e) {
                    var n,
                        r = i.get("value", t) || 0,
                        a = s.linearMap(r, [p, f], h, !0);
                    switch (g) {
                    case "left":
                        n = c.x;
                        break;
                    case "center":
                        n = c.x + (c.width - a) / 2;
                        break;
                    case "right":
                        n = c.x + c.width - a
                    }
                    return [[n, e], [n + a, e]]
                };
            "ascending" === o && (v = -v, m = -m, y += c.height, u = u.reverse());
            for (var _ = 0; _ < u.length; _++) {
                var b = u[_],
                    w = u[_ + 1],
                    M = x(b, y),
                    S = x(w, y + v);
                y += v + m, i.setItemLayout(b, {
                    points: M.concat(S.slice().reverse())
                })
            }
            a(i)
        })
    }
}, function(t, e, i) {
    var n = i(506);
    i(731), i(742), i(743), n.registerVisual(i(744))
}, function(t, e, i) {
    i(732), i(735), i(737);
    var n = i(506),
        r = i(509),
        a = 5;
    n.extendComponentView({
        type: "parallel",
        render: function(t, e, i) {
            var n = i.getZr();
            if (!this.__onMouseDown) {
                var o;
                n.on("mousedown", this.__onMouseDown = function(t) {
                    o = [t.offsetX, t.offsetY]
                }), n.on("mouseup", this.__onMouseUp = function(e) {
                    var n = [e.offsetX, e.offsetY],
                        s = Math.pow(o[0] - n[0], 2) + Math.pow(o[1] - n[1], 2);
                    if (t.get("axisExpandable") && !(s > a)) {
                        var l = t.coordinateSystem,
                            c = l.findClosestAxisDim(n);
                        if (c) {
                            var u = r.indexOf(l.dimensions, c);
                            i.dispatchAction({
                                type: "parallelAxisExpand",
                                axisExpandCenter: u
                            })
                        }
                    }
                })
            }
        },
        dispose: function(t, e) {
            e.getZr().off(this.__onMouseDown), e.getZr().off(this.__onMouseUp)
        }
    }), n.registerPreprocessor(i(741))
}, function(t, e, i) {
    function n(t, e) {
        var i = [];
        return t.eachComponent("parallel", function(n, a) {
            var o = new r(n, t, e);
            o.name = "parallel_" + a, o.resize(n, e), n.coordinateSystem = o, o.model = n, i.push(o)
        }), t.eachSeries(function(e) {
            if ("parallel" === e.get("coordinateSystem")) {
                var i = t.queryComponents({
                    mainType: "parallel",
                    index: e.get("parallelIndex"),
                    id: e.get("parallelId")
                })[0];
                e.coordinateSystem = i.coordinateSystem
            }
        }), i
    }
    var r = i(733);
    i(531).register("parallel", {
        create: n
    })
}, function(t, e, i) {
    function n(t, e, i) {
        this._axesMap = {}, this._axesLayout = {}, this.dimensions = t.dimensions, this._rect, this._model = t, this._init(t, e, i)
    }
    var r = i(526),
        a = i(620),
        o = i(509),
        s = i(734),
        l = i(548),
        c = i(516),
        u = o.each,
        h = Math.PI;
    n.prototype = {
        type: "parallel",
        constructor: n,
        _init: function(t, e, i) {
            var n = t.dimensions,
                r = t.parallelAxisIndex;
            u(n, function(t, i) {
                var n = r[i],
                    o = e.getComponent("parallelAxis", n),
                    l = this._axesMap[t] = new s(t, a.createScaleByModel(o), [0, 0], o.get("type"), n),
                    c = "category" === l.type;
                l.onBand = c && o.get("boundaryGap"), l.inverse = o.get("inverse"), o.axis = l, l.model = o
            }, this)
        },
        update: function(t, e) {
            this._updateAxesFromSeries(this._model, t)
        },
        _updateAxesFromSeries: function(t, e) {
            e.eachSeries(function(i) {
                if (t.contains(i, e)) {
                    var n = i.getData();
                    u(this.dimensions, function(t) {
                        var e = this._axesMap[t];
                        e.scale.unionExtent(n.getDataExtent(t)), a.niceScaleExtent(e, e.model)
                    }, this)
                }
            }, this)
        },
        resize: function(t, e) {
            this._rect = r.getLayoutRect(t.getBoxLayoutParams(), {
                width: e.getWidth(),
                height: e.getHeight()
            }), this._layoutAxes(t)
        },
        getRect: function() {
            return this._rect
        },
        _layoutAxes: function(t) {
            var e = this._rect,
                i = t.get("layout"),
                n = this._axesMap,
                r = this.dimensions,
                a = [e.width, e.height],
                o = "horizontal" === i ? 0 : 1,
                s = a[o],
                l = a[1 - o],
                d = [0, l];
            u(n, function(t) {
                var e = t.inverse ? 1 : 0;
                t.setExtent(d[e], d[1 - e])
            });
            var p,
                f = t.get("axisExpandable"),
                g = t.get("axisExpandWidth"),
                m = t.get("axisExpandCenter"),
                v = t.get("axisExpandCount") || 0;
            if (null != m) {
                var y = Math.max(0, Math.floor(m - (v - 1) / 2)),
                    x = y + v - 1;
                x >= r.length && (x = r.length - 1, y = Math.max(0, Math.floor(x - v + 1))), p = [y, x]
            }
            var _ = f && p && g ? function(t, e, i) {
                var n,
                    r = p[1] - p[0],
                    a = (e - g * r) / (i - 1 - r);
                return n = t < p[0] ? (t - 1) * a : t <= p[1] ? p[0] * a + (t - p[0]) * g : t === i - 1 ? e : p[0] * a + r * g + (t - p[1]) * a, {
                    position: n,
                    axisNameAvailableWidth: p[0] < t && t < p[1] ? g : a
                }
            } : function(t, e, i) {
                var n = e / (i - 1);
                return {
                    position: n * t,
                    axisNameAvailableWidth: n
                }
            };
            u(r, function(t, n) {
                var a = _(n, s, r.length),
                    o = {
                        horizontal: {
                            x: a.position,
                            y: l
                        },
                        vertical: {
                            x: 0,
                            y: a.position
                        }
                    },
                    u = {
                        horizontal: h / 2,
                        vertical: 0
                    },
                    d = [o[i].x + e.x, o[i].y + e.y],
                    f = u[i],
                    g = c.create();
                c.rotate(g, g, f), c.translate(g, g, d), this._axesLayout[t] = {
                    position: d,
                    rotation: f,
                    transform: g,
                    axisNameAvailableWidth: a.axisNameAvailableWidth,
                    tickDirection: 1,
                    labelDirection: 1,
                    axisExpandWindow: p
                }
            }, this)
        },
        getAxis: function(t) {
            return this._axesMap[t]
        },
        dataToPoint: function(t, e) {
            return this.axisCoordToPoint(this._axesMap[e].dataToCoord(t), e)
        },
        eachActiveState: function(t, e, i) {
            for (var n = this.dimensions, r = this._axesMap, a = this.hasAxisbrushed(), o = 0, s = t.count(); o < s; o++) {
                var l,
                    c = t.getValues(n, o);
                if (a) {
                    l = "active";
                    for (var u = 0, h = n.length; u < h; u++) {
                        var d = n[u],
                            p = r[d].model.getActiveState(c[u], u);
                        if ("inactive" === p) {
                            l = "inactive";
                            break
                        }
                    }
                } else
                    l = "normal";
                e.call(i, l, o)
            }
        },
        hasAxisbrushed: function() {
            for (var t = this.dimensions, e = this._axesMap, i = !1, n = 0, r = t.length; n < r; n++)
                "normal" !== e[t[n]].model.getActiveState() && (i = !0);
            return i
        },
        axisCoordToPoint: function(t, e) {
            var i = this._axesLayout[e];
            return l.applyTransform([t, 0], i.transform)
        },
        getAxisLayout: function(t) {
            return o.clone(this._axesLayout[t])
        },
        findClosestAxisDim: function(t) {
            var e,
                i = 1 / 0;
            return o.each(this._axesLayout, function(n, r) {
                var a = l.applyTransform(t, n.transform, !0),
                    o = this._axesMap[r].getExtent();
                if (!(a[0] < o[0] || a[0] > o[1])) {
                    var s = Math.abs(a[1]);
                    s < i && (i = s, e = r)
                }
            }, this), e
        }
    }, t.exports = n
}, function(t, e, i) {
    var n = i(509),
        r = i(629),
        a = function(t, e, i, n, a) {
            r.call(this, t, e, i), this.type = n || "value", this.axisIndex = a
        };
    a.prototype = {
        constructor: a,
        model: null
    }, n.inherits(a, r), t.exports = a
}, function(t, e, i) {
    var n = i(509),
        r = i(524);
    i(736), r.extend({
        type: "parallel",
        dependencies: ["parallelAxis"],
        coordinateSystem: null,
        dimensions: null,
        parallelAxisIndex: null,
        layoutMode: "box",
        defaultOption: {
            zlevel: 0,
            z: 0,
            left: 80,
            top: 60,
            right: 80,
            bottom: 60,
            layout: "horizontal",
            axisExpandable: !1,
            axisExpandCenter: null,
            axisExpandCount: 0,
            axisExpandWidth: 50,
            parallelAxisDefault: null
        },
        init: function() {
            r.prototype.init.apply(this, arguments), this.mergeOption({})
        },
        mergeOption: function(t) {
            var e = this.option;
            t && n.merge(e, t, !0), this._initDimensions()
        },
        contains: function(t, e) {
            var i = t.get("parallelIndex");
            return null != i && e.getComponent("parallel", i) === this
        },
        setAxisExpand: function(t) {
            n.each(["axisExpandable", "axisExpandCenter", "axisExpandCount", "axisExpandWidth"], function(e) {
                t.hasOwnProperty(e) && (this.option[e] = t[e])
            }, this)
        },
        _initDimensions: function() {
            var t = this.dimensions = [],
                e = this.parallelAxisIndex = [],
                i = n.filter(this.dependentModels.parallelAxis, function(t) {
                    return t.get("parallelIndex") === this.componentIndex
                });
            n.each(i, function(i) {
                t.push("dim" + i.get("dim")), e.push(i.componentIndex)
            })
        }
    })
}, function(t, e, i) {
    function n(t, e) {
        return e.type || (e.data ? "category" : "value")
    }
    var r = i(524),
        a = i(509),
        o = i(520),
        s = i(633),
        l = i(512),
        c = r.extend({
            type: "baseParallelAxis",
            axis: null,
            activeIntervals: [],
            getAreaSelectStyle: function() {
                return o([["fill", "color"], ["lineWidth", "borderWidth"], ["stroke", "borderColor"], ["width", "width"], ["opacity", "opacity"]]).call(this.getModel("areaSelectStyle"))
            },
            setActiveIntervals: function(t) {
                var e = this.activeIntervals = a.clone(t);
                if (e)
                    for (var i = e.length - 1; i >= 0; i--)
                        l.asc(e[i])
            },
            getActiveState: function(t) {
                var e = this.activeIntervals;
                if (!e.length)
                    return "normal";
                if (null == t)
                    return "inactive";
                for (var i = 0, n = e.length; i < n; i++)
                    if (e[i][0] <= t && t <= e[i][1])
                        return "active";
                return "inactive"
            }
        }),
        u = {
            type: "value",
            dim: null,
            areaSelectStyle: {
                width: 20,
                borderWidth: 1,
                borderColor: "rgba(160,197,232)",
                color: "rgba(160,197,232)",
                opacity: .3
            },
            realtime: !0,
            z: 10
        };
    a.merge(c.prototype, i(635)), s("parallel", c, n, u), t.exports = c
}, function(t, e, i) {
    i(732), i(738), i(739)
}, function(t, e, i) {
    var n = i(506),
        r = {
            type: "axisAreaSelect",
            event: "axisAreaSelected",
            update: "updateVisual"
        };
    n.registerAction(r, function(t, e) {
        e.eachComponent({
            mainType: "parallelAxis",
            query: t
        }, function(e) {
            e.axis.model.setActiveIntervals(t.intervals)
        })
    }), n.registerAction("parallelAxisExpand", function(t, e) {
        e.eachComponent({
            mainType: "parallel",
            query: t
        }, function(e) {
            e.setAxisExpand(t)
        })
    })
}, function(t, e, i) {
    function n(t, e, i) {
        return i && "axisAreaSelect" === i.type && e.findComponents({
                mainType: "parallelAxis",
                query: i
            })[0] === t
    }
    var r = i(509),
        a = i(639),
        o = i(740),
        s = i(548),
        l = ["axisLine", "axisLabel", "axisTick", "axisName"],
        c = i(506).extendComponentView({
            type: "parallelAxis",
            init: function(t, e) {
                c.superApply(this, "init", arguments), (this._brushController = new o(e.getZr())).on("brush", r.bind(this._onBrush, this))
            },
            render: function(t, e, i, o) {
                if (!n(t, e, o)) {
                    this.axisModel = t, this.api = i, this.group.removeAll();
                    var c = this._axisGroup;
                    if (this._axisGroup = new s.Group, this.group.add(this._axisGroup), t.get("show")) {
                        var u,
                            h = e.getComponent("parallel", t.get("parallelIndex")).coordinateSystem,
                            d = t.getAreaSelectStyle(),
                            p = d.width,
                            f = t.axis.dim,
                            g = h.getAxisLayout(f),
                            m = r.indexOf(h.dimensions, f),
                            v = g.axisExpandWindow;
                        v && (m <= v[0] || m >= v[1]) && (u = !1);
                        var y = r.extend({
                                axisLabelShow: u,
                                strokeContainThreshold: p
                            }, g),
                            x = new a(t, y);
                        r.each(l, x.add, x), this._axisGroup.add(x.getGroup()), this._refreshBrushController(y, d, t, p), s.groupTransition(c, this._axisGroup, t)
                    }
                }
            },
            _refreshBrushController: function(t, e, i, n) {
                var a = i.axis,
                    o = r.map(i.activeIntervals, function(t) {
                        return {
                            brushType: "lineX",
                            panelId: "pl",
                            range: [a.dataToCoord(t[0], !0), a.dataToCoord(t[1], !0)]
                        }
                    }),
                    l = a.getExtent(),
                    c = l[1] - l[0],
                    u = Math.min(30, .1 * Math.abs(c)),
                    h = s.BoundingRect.create({
                        x: l[0],
                        y: -n / 2,
                        width: c,
                        height: n
                    });
                h.x -= u, h.width += 2 * u, this._brushController.mount({
                    enableGlobalPan: !0,
                    rotation: t.rotation,
                    position: t.position
                }).setPanels([{
                    panelId: "pl",
                    rect: h
                }]).enableBrush({
                    brushType: "lineX",
                    brushStyle: e,
                    removeOnClick: !0
                }).updateCovers(o)
            },
            _onBrush: function(t, e) {
                var i = this.axisModel,
                    n = i.axis,
                    a = r.map(t, function(t) {
                        return [n.coordToData(t.range[0], !0), n.coordToData(t.range[1], !0)]
                    });
                (!i.option.realtime === e.isEnd || e.removeOnClick) && this.api.dispatchAction({
                    type: "axisAreaSelect",
                    parallelAxisId: i.id,
                    intervals: a
                })
            },
            dispose: function() {
                this._brushController.dispose()
            }
        });
    t.exports = c
}, function(t, e, i) {
    function n(t) {
        __DEV__ && N.assert(t), V.call(this), this._zr = t, this.group = new F.Group, this._brushType, this._brushOption, this._panels, this._track = [], this._dragging, this._covers = [], this._creatingCover, this._creatingPanel, this._enableGlobalPan, __DEV__ && this._mounted, this._uid = "brushController_" + it++, this._handlers = {}, W(nt, function(t, e) {
            this._handlers[e] = N.bind(t, this)
        }, this)
    }
    function r(t, e) {
        var i = t._zr;
        t._enableGlobalPan || H.take(i, J, t._uid), W(t._handlers, function(t, e) {
            i.on(e, t)
        }), t._brushType = e.brushType, t._brushOption = N.merge(N.clone(et), e, !0)
    }
    function a(t) {
        var e = t._zr;
        H.release(e, J, t._uid), W(t._handlers, function(t, i) {
            e.off(i, t)
        }), t._brushType = t._brushOption = null
    }
    function o(t, e) {
        var i = rt[e.brushType].createCover(t, e);
        return c(i), i.__brushOption = e, t.group.add(i), i
    }
    function s(t, e) {
        var i = h(e);
        return i.endCreating && (i.endCreating(t, e), c(e)), e
    }
    function l(t, e) {
        var i = e.__brushOption;
        h(e).updateCoverShape(t, e, i.range, i)
    }
    function c(t) {
        t.traverse(function(t) {
            t.z = j, t.z2 = j
        })
    }
    function u(t, e) {
        h(e).updateCommon(t, e), l(t, e)
    }
    function h(t) {
        return rt[t.__brushOption.brushType]
    }
    function d(t, e, i) {
        var n = t._panels;
        if (!n)
            return !0;
        var r;
        return W(n, function(t) {
            t.contain(e, i) && (r = t)
        }), r
    }
    function p(t, e) {
        var i = t._panels;
        if (!i)
            return !0;
        var n = e.__brushOption.panelId;
        return null == n || i[n]
    }
    function f(t) {
        var e = t._covers,
            i = e.length;
        return W(e, function(e) {
            t.group.remove(e)
        }, t), e.length = 0, !!i
    }
    function g(t, e) {
        var i = Y(t._covers, function(t) {
            var e = t.__brushOption,
                i = N.clone(e.range);
            return {
                brushType: e.brushType,
                panelId: e.panelId,
                range: i
            }
        });
        t.trigger("brush", i, {
            isEnd: !!e.isEnd,
            removeOnClick: !!e.removeOnClick
        })
    }
    function m(t) {
        var e = t._track;
        if (!e.length)
            return !1;
        var i = e[e.length - 1],
            n = e[0],
            r = i[0] - n[0],
            a = i[1] - n[1],
            o = Z(r * r + a * a, .5);
        return o > X
    }
    function v(t) {
        var e = t.length - 1;
        return e < 0 && (e = 0), [t[0], t[e]]
    }
    function y(t, e, i, n) {
        var r = new F.Group;
        return r.add(new F.Rect({
            name: "main",
            style: w(i),
            silent: !0,
            draggable: !0,
            cursor: "move",
            drift: $(t, e, r, "nswe"),
            ondragend: $(g, e, {
                isEnd: !0
            })
        })), W(n, function(i) {
            r.add(new F.Rect({
                name: i,
                style: {
                    opacity: 0
                },
                draggable: !0,
                silent: !0,
                invisible: !0,
                drift: $(t, e, r, i),
                ondragend: $(g, e, {
                    isEnd: !0
                })
            }))
        }), r
    }
    function x(t, e, i, n) {
        var r = n.brushStyle.lineWidth || 0,
            a = U(r, K),
            o = i[0][0],
            s = i[1][0],
            l = o - r / 2,
            c = s - r / 2,
            u = i[0][1],
            h = i[1][1],
            d = u - a + r / 2,
            p = h - a + r / 2,
            f = u - o,
            g = h - s,
            m = f + r,
            v = g + r;
        b(t, e, "main", o, s, f, g), n.transformable && (b(t, e, "w", l, c, a, v), b(t, e, "e", d, c, a, v), b(t, e, "n", l, c, m, a), b(t, e, "s", l, p, m, a), b(t, e, "nw", l, c, a, a), b(t, e, "ne", d, c, a, a), b(t, e, "sw", l, p, a, a), b(t, e, "se", d, p, a, a))
    }
    function _(t, e) {
        var i = e.__brushOption,
            n = i.transformable,
            r = e.childAt(0);
        r.useStyle(w(i)), r.attr({
            silent: !n,
            cursor: n ? "move" : "default"
        }), W(["w", "e", "n", "s", "se", "sw", "ne", "nw"], function(i) {
            var r = e.childOfName(i),
                a = A(t, i);
            r && r.attr({
                silent: !n,
                invisible: !n,
                cursor: n ? tt[a] + "-resize" : null
            })
        })
    }
    function b(t, e, i, n, r, a, o) {
        var s = e.childOfName(i);
        s && s.setShape(C(T(t, e, [[n, r], [n + a, r + o]])))
    }
    function w(t) {
        return N.defaults({
            strokeNoScale: !0
        }, t.brushStyle)
    }
    function M(t, e, i, n) {
        var r = [q(t, i), q(e, n)],
            a = [U(t, i), U(e, n)];
        return [[r[0], a[0]], [r[1], a[1]]]
    }
    function S(t) {
        return F.getTransform(t.group)
    }
    function A(t, e) {
        if (e.length > 1) {
            e = e.split("");
            var i = [A(t, e[0]), A(t, e[1])];
            return ("e" === i[0] || "w" === i[0]) && i.reverse(), i.join("")
        }
        var n = {
                w: "left",
                e: "right",
                n: "top",
                s: "bottom"
            },
            r = {
                left: "w",
                right: "e",
                top: "n",
                bottom: "s"
            },
            i = F.transformDirection(n[e], S(t));
        return r[i]
    }
    function I(t, e, i, n, r, a, o, s) {
        var l = n.__brushOption,
            c = t(l.range),
            h = k(i, a, o);
        W(r.split(""), function(t) {
            var e = Q[t];
            c[e[0]][e[1]] += h[e[0]]
        }), l.range = e(M(c[0][0], c[1][0], c[0][1], c[1][1])), u(i, n), g(i, {
            isEnd: !1
        })
    }
    function D(t, e, i, n, r) {
        var a = e.__brushOption.range,
            o = k(t, i, n);
        W(a, function(t) {
            t[0] += o[0], t[1] += o[1]
        }), u(t, e), g(t, {
            isEnd: !1
        })
    }
    function k(t, e, i) {
        var n = t.group,
            r = n.transformCoordToLocal(e, i),
            a = n.transformCoordToLocal(0, 0);
        return [r[0] - a[0], r[1] - a[1]]
    }
    function T(t, e, i) {
        var n = p(t, e);
        if (n === !0)
            return N.clone(i);
        var r = n.getBoundingRect();
        return N.map(i, function(t) {
            var e = t[0];
            e = U(e, r.x), e = q(e, r.x + r.width);
            var i = t[1];
            return i = U(i, r.y), i = q(i, r.y + r.height), [e, i]
        })
    }
    function C(t) {
        var e = q(t[0][0], t[1][0]),
            i = q(t[0][1], t[1][1]),
            n = U(t[0][0], t[1][0]),
            r = U(t[0][1], t[1][1]);
        return {
            x: e,
            y: i,
            width: n - e,
            height: r - i
        }
    }
    function L(t, e) {
        var i = e.offsetX,
            n = e.offsetY,
            r = t._zr;
        if (t._brushType) {
            for (var a, o = t._panels, s = t._covers, l = 0; l < s.length; l++)
                if (rt[s[l].__brushOption.brushType].contain(s[l], i, n)) {
                    a = !0;
                    break
                }
            a || (o ? W(o, function(t) {
                t.contain(i, n) && r.setCursorStyle("crosshair")
            }) : r.setCursorStyle("crosshair"))
        }
    }
    function P(t) {
        var e = t.event;
        e.preventDefault && e.preventDefault()
    }
    function E(t, e, i) {
        return t.childOfName("main").contain(e, i)
    }
    function O(t, e, i) {
        var n,
            r = e.offsetX,
            a = e.offsetY,
            c = t._creatingCover,
            u = t._creatingPanel,
            h = t._brushOption;
        if (t._track.push(t.group.transformCoordToLocal(r, a)), m(t) || c) {
            if (u && !c) {
                "single" === h.brushMode && f(t);
                var p = N.clone(h);
                p.panelId = u === !0 ? null : u.__brushPanelId, c = t._creatingCover = o(t, p), t._covers.push(c)
            }
            if (c) {
                var g = rt[t._brushType],
                    v = c.__brushOption;
                v.range = g.getCreatingRange(T(t, c, t._track)), i && (s(t, c), g.updateCommon(t, c)), l(t, c), n = {
                    isEnd: i
                }
            }
        } else
            i && "single" === h.brushMode && h.removeOnClick && d(t, r, a) && f(t) && (n = {
                isEnd: i,
                removeOnClick: !0
            });
        return n
    }
    function R(t) {
        if (this._dragging) {
            P(t);
            var e = O(this, t, !0);
            this._dragging = !1, this._track = [], this._creatingCover = null, e && g(this, e)
        }
    }
    function z(t) {
        return {
            createCover: function(e, i) {
                return y($(I, function(e) {
                    var i = [e, [0, 100]];
                    return t && i.reverse(), i
                }, function(e) {
                    return e[t]
                }), e, i, [["w", "e"], ["n", "s"]][t])
            },
            getCreatingRange: function(e) {
                var i = v(e),
                    n = q(i[0][t], i[1][t]),
                    r = U(i[0][t], i[1][t]);
                return [n, r]
            },
            updateCoverShape: function(e, i, n, r) {
                var a,
                    o = r.brushStyle.width;
                if (null == o) {
                    var s = p(e, i),
                        l = 0;
                    if (s !== !0) {
                        var c = s.getBoundingRect();
                        o = t ? c.width : c.height, l = t ? c.x : c.y
                    }
                    a = [l, l + (o || 0)]
                } else
                    a = [-o / 2, o / 2];
                var u = [n, a];
                t && u.reverse(), x(e, i, u, r)
            },
            updateCommon: _,
            contain: E
        }
    }
    var V = i(538),
        N = i(509),
        B = i(514),
        F = i(548),
        H = i(682),
        G = i(604),
        $ = N.curry,
        W = N.each,
        Y = N.map,
        q = Math.min,
        U = Math.max,
        Z = Math.pow,
        j = 1e4,
        X = 6,
        K = 6,
        J = "globalPan",
        Q = {
            w: [0, 0],
            e: [0, 1],
            n: [1, 0],
            s: [1, 1]
        },
        tt = {
            w: "ew",
            e: "ew",
            n: "ns",
            s: "ns",
            ne: "nesw",
            sw: "nesw",
            nw: "nwse",
            se: "nwse"
        },
        et = {
            brushStyle: {
                lineWidth: 2,
                stroke: "rgba(0,0,0,0.3)",
                fill: "rgba(0,0,0,0.1)"
            },
            transformable: !0,
            brushMode: "single",
            removeOnClick: !1
        },
        it = 0;
    n.prototype = {
        constructor: n,
        enableBrush: function(t) {
            return __DEV__ && N.assert(this._mounted), this._brushType && a(this), t.brushType && r(this, t), this
        },
        setPanels: function(t) {
            var e = this._panels || {},
                i = this._panels = t && t.length && {},
                n = this.group;
            return i && W(t, function(t) {
                var r = t.panelId,
                    a = e[r];
                a || (a = new F.Rect({
                    silent: !0,
                    invisible: !0
                }), n.add(a));
                var o = t.rect;
                o instanceof B || (o = B.create(o)), a.attr("shape", o.plain()), a.__brushPanelId = r, i[r] = a, e[r] = null
            }), W(e, function(t) {
                t && n.remove(t)
            }), this
        },
        mount: function(t) {
            t = t || {}, __DEV__ && (this._mounted = !0), this._enableGlobalPan = t.enableGlobalPan;
            var e = this.group;
            return this._zr.add(e), e.attr({
                position: t.position || [0, 0],
                rotation: t.rotation || 0,
                scale: t.scale || [1, 1]
            }), this
        },
        eachCover: function(t, e) {
            W(this._covers, t, e)
        },
        updateCovers: function(t) {
            function e(t, e) {
                return (null != t.id ? t.id : a + e) + "-" + t.brushType
            }
            function i(t, i) {
                return e(t.__brushOption, i)
            }
            function n(e, i) {
                var n = t[e];
                if (null != i && l[i] === d)
                    c[e] = l[i];
                else {
                    var r = c[e] = null != i ? (l[i].__brushOption = n, l[i]) : s(h, o(h, n));
                    u(h, r)
                }
            }
            function r(t) {
                l[t] !== d && h.group.remove(l[t])
            }
            __DEV__ && N.assert(this._mounted), t = N.map(t, function(t) {
                return N.merge(N.clone(et), t, !0)
            });
            var a = "\0-brush-index-",
                l = this._covers,
                c = this._covers = [],
                h = this,
                d = this._creatingCover;
            return new G(l, t, i, e).add(n).update(n).remove(r).execute(), this
        },
        unmount: function() {
            return this.enableBrush(!1), f(this), this._zr.remove(this.group), __DEV__ && (this._mounted = !1), this
        },
        dispose: function() {
            this.unmount(), this.off()
        }
    }, N.mixin(n, V);
    var nt = {
            mousedown: function(t) {
                if (this._dragging)
                    R.call(this, t);
                else if (!t.target || !t.target.draggable) {
                    P(t);
                    var e = t.offsetX,
                        i = t.offsetY;
                    this._creatingCover = null;
                    var n = this._creatingPanel = d(this, e, i);
                    n && (this._dragging = !0, this._track = [this.group.transformCoordToLocal(e, i)])
                }
            },
            mousemove: function(t) {
                if (L(this, t), this._dragging) {
                    P(t);
                    var e = O(this, t, !1);
                    e && g(this, e)
                }
            },
            mouseup: R
        },
        rt = {
            lineX: z(0),
            lineY: z(1),
            rect: {
                createCover: function(t, e) {
                    return y($(I, function(t) {
                        return t
                    }, function(t) {
                        return t
                    }), t, e, ["w", "e", "n", "s", "se", "sw", "ne", "nw"])
                },
                getCreatingRange: function(t) {
                    var e = v(t);
                    return M(e[1][0], e[1][1], e[0][0], e[0][1])
                },
                updateCoverShape: function(t, e, i, n) {
                    x(t, e, i, n)
                },
                updateCommon: _,
                contain: E
            },
            polygon: {
                createCover: function(t, e) {
                    var i = new F.Group;
                    return i.add(new F.Polyline({
                        name: "main",
                        style: w(e),
                        silent: !0
                    })), i
                },
                getCreatingRange: function(t) {
                    return t
                },
                endCreating: function(t, e) {
                    e.remove(e.childAt(0)), e.add(new F.Polygon({
                        name: "main",
                        draggable: !0,
                        drift: $(D, t, e),
                        ondragend: $(g, t, {
                            isEnd: !0
                        })
                    }))
                },
                updateCoverShape: function(t, e, i, n) {
                    e.childAt(0).setShape({
                        points: T(t, e, i)
                    })
                },
                updateCommon: _,
                contain: E
            }
        };
    t.exports = n
}, function(t, e, i) {
    function n(t) {
        if (!t.parallel) {
            var e = !1;
            a.each(t.series, function(t) {
                t && "parallel" === t.type && (e = !0)
            }), e && (t.parallel = [{}])
        }
    }
    function r(t) {
        var e = o.normalizeToArray(t.parallelAxis);
        a.each(e, function(e) {
            if (a.isObject(e)) {
                var i = e.parallelIndex || 0,
                    n = o.normalizeToArray(t.parallel)[i];
                n && n.parallelAxisDefault && a.merge(e, n.parallelAxisDefault, !1)
            }
        })
    }
    var a = i(509),
        o = i(510);
    t.exports = function(t) {
        n(t), r(t)
    }
}, function(t, e, i) {
    function n(t, e, i) {
        var n = t.get("data"),
            a = r(e);
        n && n.length && s.each(i, function(t) {
            if (t) {
                var e = s.indexOf(n, t[a]);
                t[a] = e >= 0 ? e : NaN
            }
        })
    }
    function r(t) {
        return +t.replace("dim", "")
    }
    function a(t, e) {
        var i = 0;
        s.each(t, function(t) {
            var e = r(t);
            e > i && (i = e)
        });
        var n = e[0];
        n && n.length - 1 > i && (i = n.length - 1);
        for (var a = [], o = 0; o <= i; o++)
            a.push("dim" + o);
        return a
    }
    var o = i(603),
        s = i(509),
        l = i(533),
        c = i(608);
    t.exports = l.extend({
        type: "series.parallel",
        dependencies: ["parallel"],
        getInitialData: function(t, e) {
            var i = e.getComponent("parallel", this.get("parallelIndex")),
                r = i.parallelAxisIndex,
                l = t.data,
                u = i.dimensions,
                h = a(u, l),
                d = s.map(h, function(t, i) {
                    var a = s.indexOf(u, t),
                        o = a >= 0 && e.getComponent("parallelAxis", r[a]);
                    return o && "category" === o.get("type") ? (n(o, t, l), {
                        name: t,
                        type: "ordinal"
                    }) : a < 0 && c.guessOrdinal(l, i) ? {
                        name: t,
                        type: "ordinal"
                    } : t
                }),
                p = new o(d, this);
            return p.initData(l), this.option.progressive && (this.option.animation = !1), p
        },
        getRawIndicesByActiveState: function(t) {
            var e = this.coordinateSystem,
                i = this.getData(),
                n = [];
            return e.eachActiveState(i, function(e, r) {
                t === e && n.push(i.getRawIndex(r))
            }), n
        },
        defaultOption: {
            zlevel: 0,
            z: 2,
            coordinateSystem: "parallel",
            parallelIndex: 0,
            label: {
                normal: {
                    show: !1
                },
                emphasis: {
                    show: !1
                }
            },
            inactiveOpacity: .05,
            activeOpacity: 1,
            lineStyle: {
                normal: {
                    width: 1,
                    opacity: .45,
                    type: "solid"
                }
            },
            progressive: !1,
            smooth: !1,
            animationEasing: "linear"
        }
    })
}, function(t, e, i) {
    function n(t, e, i) {
        var n = t.model,
            r = t.getRect(),
            a = new l.Rect({
                shape: {
                    x: r.x,
                    y: r.y,
                    width: r.width,
                    height: r.height
                }
            }),
            o = "horizontal" === n.get("layout") ? "width" : "height";
        return a.setShape(o, 0), l.initProps(a, {
            shape: {
                width: r.width,
                height: r.height
            }
        }, e, i), a
    }
    function r(t, e, i, n) {
        for (var r = [], a = 0; a < i.length; a++) {
            var o = i[a],
                l = t.get(o, e);
            s(l, n.getAxis(o).type) || r.push(n.dataToPoint(l, o))
        }
        return r
    }
    function a(t, e, i, n, a) {
        var o = r(t, i, n, a),
            s = new l.Polyline({
                shape: {
                    points: o
                },
                silent: !0,
                z2: 10
            });
        e.add(s), t.setItemGraphicEl(i, s)
    }
    function o(t, e) {
        var i = t.hostModel.getModel("lineStyle.normal"),
            n = i.getLineStyle();
        t.eachItemGraphicEl(function(r, a) {
            if (t.hasItemOption) {
                var o = t.getItemModel(a),
                    s = o.getModel("lineStyle.normal", i);
                n = s.getLineStyle()
            }
            r.useStyle(c.extend(n, {
                fill: null,
                stroke: t.getItemVisual(a, "color"),
                opacity: t.getItemVisual(a, "opacity")
            })), r.shape.smooth = e
        })
    }
    function s(t, e) {
        return "category" === e ? null == t : null == t || isNaN(t)
    }
    var l = i(548),
        c = i(509),
        u = .3,
        h = i(547).extend({
            type: "parallel",
            init: function() {
                this._dataGroup = new l.Group, this.group.add(this._dataGroup), this._data
            },
            render: function(t, e, i, n) {
                this._renderForNormal(t)
            },
            dispose: function() {},
            _renderForNormal: function(t) {
                function e(t) {
                    a(h, c, t, f, p, null, m)
                }
                function i(e, i) {
                    var n = d.getItemGraphicEl(i),
                        a = r(h, e, f, p);
                    h.setItemGraphicEl(e, n), l.updateProps(n, {
                        shape: {
                            points: a
                        }
                    }, t, e)
                }
                function s(t) {
                    var e = d.getItemGraphicEl(t);
                    c.remove(e)
                }
                var c = this._dataGroup,
                    h = t.getData(),
                    d = this._data,
                    p = t.coordinateSystem,
                    f = p.dimensions,
                    g = t.option,
                    m = g.smooth ? u : null;
                if (h.diff(d).add(e).update(i).remove(s).execute(), o(h, m), !this._data) {
                    var v = n(p, t, function() {
                        setTimeout(function() {
                            c.removeClipPath()
                        })
                    });
                    c.setClipPath(v)
                }
                this._data = h
            },
            remove: function() {
                this._dataGroup && this._dataGroup.removeAll(), this._data = null
            }
        });
    t.exports = h
}, function(t, e) {
    t.exports = function(t) {
        t.eachSeriesByType("parallel", function(e) {
            var i = e.getModel("itemStyle.normal"),
                n = e.getModel("lineStyle.normal"),
                r = t.get("color"),
                a = n.get("color") || i.get("color") || r[e.seriesIndex % r.length],
                o = e.get("inactiveOpacity"),
                s = e.get("activeOpacity"),
                l = e.getModel("lineStyle.normal").getLineStyle(),
                c = e.coordinateSystem,
                u = e.getData(),
                h = {
                    normal: l.opacity,
                    active: s,
                    inactive: o
                };
            c.eachActiveState(u, function(t, e) {
                u.setItemVisual(e, "opacity", h[t])
            }), u.setVisual("color", a)
        })
    }
}, function(t, e, i) {
    var n = i(506);
    i(746), i(747), n.registerLayout(i(748)), n.registerVisual(i(750))
}, function(t, e, i) {
    var n = i(533),
        r = i(703),
        a = n.extend({
            type: "series.sankey",
            layoutInfo: null,
            getInitialData: function(t) {
                var e = t.edges || t.links,
                    i = t.data || t.nodes;
                if (i && e) {
                    var n = r(i, e, this, !0);
                    return n.data
                }
            },
            getGraph: function() {
                return this.getData().graph
            },
            getEdgeData: function() {
                return this.getGraph().edgeData
            },
            formatTooltip: function(t, e, i) {
                if ("edge" === i) {
                    var n = this.getDataParams(t, i),
                        r = n.data,
                        o = r.source + " -- " + r.target;
                    return n.value && (o += " : " + n.value), o
                }
                return a.superCall(this, "formatTooltip", t, e)
            },
            defaultOption: {
                zlevel: 0,
                z: 2,
                coordinateSystem: "view",
                layout: null,
                left: "5%",
                top: "5%",
                right: "20%",
                bottom: "5%",
                nodeWidth: 20,
                nodeGap: 8,
                layoutIterations: 32,
                label: {
                    normal: {
                        show: !0,
                        position: "right",
                        textStyle: {
                            color: "#000",
                            fontSize: 12
                        }
                    },
                    emphasis: {
                        show: !0
                    }
                },
                itemStyle: {
                    normal: {
                        borderWidth: 1,
                        borderColor: "#333"
                    }
                },
                lineStyle: {
                    normal: {
                        color: "#314656",
                        opacity: .2,
                        curveness: .5
                    },
                    emphasis: {
                        opacity: .6
                    }
                },
                animationEasing: "linear",
                animationDuration: 1e3
            }
        });
    t.exports = a
}, function(t, e, i) {
    function n(t, e, i) {
        var n = new r.Rect({
            shape: {
                x: t.x - 10,
                y: t.y - 10,
                width: 0,
                height: t.height + 20
            }
        });
        return r.initProps(n, {
            shape: {
                width: t.width + 20,
                height: t.height + 20
            }
        }, e, i), n
    }
    var r = i(548),
        a = i(509),
        o = r.extendShape({
            shape: {
                x1: 0,
                y1: 0,
                x2: 0,
                y2: 0,
                cpx1: 0,
                cpy1: 0,
                cpx2: 0,
                cpy2: 0,
                extent: 0
            },
            buildPath: function(t, e) {
                var i = e.extent / 2;
                t.moveTo(e.x1, e.y1 - i), t.bezierCurveTo(e.cpx1, e.cpy1 - i, e.cpx2, e.cpy2 - i, e.x2, e.y2 - i), t.lineTo(e.x2, e.y2 + i), t.bezierCurveTo(e.cpx2, e.cpy2 + i, e.cpx1, e.cpy1 + i, e.x1, e.y1 + i), t.closePath()
            }
        });
    t.exports = i(506).extendChartView({
        type: "sankey",
        _model: null,
        render: function(t, e, i) {
            var s = t.getGraph(),
                l = this.group,
                c = t.layoutInfo,
                u = t.getData(),
                h = t.getData("edge");
            this._model = t, l.removeAll(), l.position = [c.x, c.y], s.eachEdge(function(e) {
                var i = new o;
                i.dataIndex = e.dataIndex, i.seriesIndex = t.seriesIndex, i.dataType = "edge";
                var n = e.getModel("lineStyle.normal"),
                    a = n.get("curveness"),
                    s = e.node1.getLayout(),
                    c = e.node2.getLayout(),
                    u = e.getLayout();
                i.shape.extent = Math.max(1, u.dy);
                var d = s.x + s.dx,
                    p = s.y + u.sy + u.dy / 2,
                    f = c.x,
                    g = c.y + u.ty + u.dy / 2,
                    m = d * (1 - a) + f * a,
                    v = p,
                    y = d * a + f * (1 - a),
                    x = g;
                switch (i.setShape({
                    x1: d,
                    y1: p,
                    x2: f,
                    y2: g,
                    cpx1: m,
                    cpy1: v,
                    cpx2: y,
                    cpy2: x
                }), i.setStyle(n.getItemStyle()), i.style.fill) {
                case "source":
                    i.style.fill = e.node1.getVisual("color");
                    break;
                case "target":
                    i.style.fill = e.node2.getVisual("color")
                }
                r.setHoverStyle(i, e.getModel("lineStyle.emphasis").getItemStyle()), l.add(i), h.setItemGraphicEl(e.dataIndex, i)
            }), s.eachNode(function(e) {
                var i = e.getLayout(),
                    n = e.getModel(),
                    o = n.getModel("label.normal"),
                    s = o.getModel("textStyle"),
                    c = n.getModel("label.emphasis"),
                    h = c.getModel("textStyle"),
                    d = new r.Rect({
                        shape: {
                            x: i.x,
                            y: i.y,
                            width: e.getLayout().dx,
                            height: e.getLayout().dy
                        },
                        style: {
                            text: o.get("show") ? t.getFormattedLabel(e.dataIndex, "normal") || e.id : "",
                            textFont: s.getFont(),
                            textFill: s.getTextColor(),
                            textPosition: o.get("position")
                        }
                    });
                d.setStyle(a.defaults({
                    fill: e.getVisual("color")
                }, n.getModel("itemStyle.normal").getItemStyle())), r.setHoverStyle(d, a.extend(e.getModel("itemStyle.emphasis"), {
                    text: c.get("show") ? t.getFormattedLabel(e.dataIndex, "emphasis") || e.id : "",
                    textFont: h.getFont(),
                    textFill: h.getTextColor(),
                    textPosition: c.get("position")
                })), l.add(d), u.setItemGraphicEl(e.dataIndex, d), d.dataType = "node"
            }), !this._data && t.get("animation") && l.setClipPath(n(l.getBoundingRect(), t, function() {
                l.removeClipPath()
            })), this._data = t.getData()
        },
        dispose: function() {}
    })
}, function(t, e, i) {
    function n(t, e) {
        return S.getLayoutRect(t.getBoxLayoutParams(), {
            width: e.getWidth(),
            height: e.getHeight()
        })
    }
    function r(t, e, i, n, r, a, s) {
        o(t, i, r), c(t, e, a, n, s), m(t)
    }
    function a(t) {
        I.each(t, function(t) {
            var e = x(t.outEdges, M),
                i = x(t.inEdges, M),
                n = Math.max(e, i);
            t.setLayout({
                value: n
            }, !0)
        })
    }
    function o(t, e, i) {
        for (var n = t, r = null, a = 0, o = 0; n.length;) {
            r = [];
            for (var c = 0, u = n.length; c < u; c++) {
                var h = n[c];
                h.setLayout({
                    x: a
                }, !0), h.setLayout({
                    dx: e
                }, !0);
                for (var d = 0, p = h.outEdges.length; d < p; d++)
                    r.push(h.outEdges[d].node2)
            }
            n = r, ++a
        }
        s(t, a), o = (i - e) / (a - 1), l(t, o)
    }
    function s(t, e) {
        I.each(t, function(t) {
            t.outEdges.length || t.setLayout({
                x: e - 1
            }, !0)
        })
    }
    function l(t, e) {
        I.each(t, function(t) {
            var i = t.getLayout().x * e;
            t.setLayout({
                x: i
            }, !0)
        })
    }
    function c(t, e, i, n, r) {
        var a = A().key(function(t) {
            return t.getLayout().x
        }).sortKeys(w).entries(t).map(function(t) {
            return t.values
        });
        u(t, a, e, i, n), h(a, n, i);
        for (var o = 1; r > 0; r--)
            o *= .99, d(a, o), h(a, n, i), f(a, o), h(a, n, i)
    }
    function u(t, e, i, n, r) {
        var a = [];
        I.each(e, function(t) {
            var e = t.length,
                i = 0;
            I.each(t, function(t) {
                i += t.getLayout().value
            });
            var o = (n - (e - 1) * r) / i;
            a.push(o)
        }), a.sort(function(t, e) {
            return t - e
        });
        var o = a[0];
        I.each(e, function(t) {
            I.each(t, function(t, e) {
                t.setLayout({
                    y: e
                }, !0);
                var i = t.getLayout().value * o;
                t.setLayout({
                    dy: i
                }, !0)
            })
        }), I.each(i, function(t) {
            var e = +t.getValue() * o;
            t.setLayout({
                dy: e
            }, !0)
        })
    }
    function h(t, e, i) {
        I.each(t, function(t) {
            var n,
                r,
                a,
                o = 0,
                s = t.length;
            for (t.sort(b), a = 0; a < s; a++) {
                if (n = t[a], r = o - n.getLayout().y, r > 0) {
                    var l = n.getLayout().y + r;
                    n.setLayout({
                        y: l
                    }, !0)
                }
                o = n.getLayout().y + n.getLayout().dy + e
            }
            if (r = o - e - i, r > 0) {
                var l = n.getLayout().y - r;
                for (n.setLayout({
                    y: l
                }, !0), o = n.getLayout().y, a = s - 2; a >= 0; --a)
                    n = t[a], r = n.getLayout().y + n.getLayout().dy + e - o, r > 0 && (l = n.getLayout().y - r, n.setLayout({
                        y: l
                    }, !0)), o = n.getLayout().y
            }
        })
    }
    function d(t, e) {
        I.each(t.slice().reverse(), function(t) {
            I.each(t, function(t) {
                if (t.outEdges.length) {
                    var i = x(t.outEdges, p) / x(t.outEdges, M),
                        n = t.getLayout().y + (i - _(t)) * e;
                    t.setLayout({
                        y: n
                    }, !0)
                }
            })
        })
    }
    function p(t) {
        return _(t.node2) * t.getValue()
    }
    function f(t, e) {
        I.each(t, function(t) {
            I.each(t, function(t) {
                if (t.inEdges.length) {
                    var i = x(t.inEdges, g) / x(t.inEdges, M),
                        n = t.getLayout().y + (i - _(t)) * e;
                    t.setLayout({
                        y: n
                    }, !0)
                }
            })
        })
    }
    function g(t) {
        return _(t.node1) * t.getValue()
    }
    function m(t) {
        I.each(t, function(t) {
            t.outEdges.sort(v), t.inEdges.sort(y)
        }), I.each(t, function(t) {
            var e = 0,
                i = 0;
            I.each(t.outEdges, function(t) {
                t.setLayout({
                    sy: e
                }, !0), e += t.getLayout().dy
            }), I.each(t.inEdges, function(t) {
                t.setLayout({
                    ty: i
                }, !0), i += t.getLayout().dy
            })
        })
    }
    function v(t, e) {
        return t.node2.getLayout().y - e.node2.getLayout().y
    }
    function y(t, e) {
        return t.node1.getLayout().y - e.node1.getLayout().y
    }
    function x(t, e) {
        for (var i = 0, n = t.length, r = -1; ++r < n;) {
            var a = +e.call(t, t[r], r);
            isNaN(a) || (i += a)
        }
        return i
    }
    function _(t) {
        return t.getLayout().y + t.getLayout().dy / 2
    }
    function b(t, e) {
        return t.getLayout().y - e.getLayout().y
    }
    function w(t, e) {
        return t < e ? -1 : t > e ? 1 : t === e ? 0 : NaN
    }
    function M(t) {
        return t.getValue()
    }
    var S = i(526),
        A = i(749),
        I = i(509);
    t.exports = function(t, e, i) {
        t.eachSeriesByType("sankey", function(t) {
            var i = t.get("nodeWidth"),
                o = t.get("nodeGap"),
                s = n(t, e);
            t.layoutInfo = s;
            var l = s.width,
                c = s.height,
                u = t.getGraph(),
                h = u.nodes,
                d = u.edges;
            a(h);
            var p = h.filter(function(t) {
                    return 0 === t.getLayout().value
                }),
                f = 0 !== p.length ? 0 : t.get("layoutIterations");
            r(h, d, i, o, l, c, f)
        })
    }
}, function(t, e, i) {
    function n() {
        function t(e, n) {
            if (n >= i.length)
                return e;
            for (var a = -1, o = e.length, s = i[n++], l = {}, c = {}; ++a < o;) {
                var u = s(e[a]),
                    h = c[u];
                h ? h.push(e[a]) : c[u] = [e[a]]
            }
            return r.each(c, function(e, i) {
                l[i] = t(e, n)
            }), l
        }
        function e(t, a) {
            if (a >= i.length)
                return t;
            var o = [],
                s = n[a++];
            return r.each(t, function(t, i) {
                o.push({
                    key: i,
                    values: e(t, a)
                })
            }), s ? o.sort(function(t, e) {
                return s(t.key, e.key)
            }) : o
        }
        var i = [],
            n = [];
        return {
            key: function(t) {
                return i.push(t), this
            },
            sortKeys: function(t) {
                return n[i.length - 1] = t, this
            },
            entries: function(i) {
                return e(t(i, 0), 0)
            }
        }
    }
    var r = i(509);
    t.exports = n
}, function(t, e, i) {
    var n = i(699),
        r = i(509);
    t.exports = function(t, e) {
        t.eachSeriesByType("sankey", function(t) {
            var e = t.getGraph(),
                i = e.nodes;
            i.sort(function(t, e) {
                return t.getLayout().value - e.getLayout().value
            });
            var a = i[0].getLayout().value,
                o = i[i.length - 1].getLayout().value;
            r.each(i, function(e) {
                var i = new n({
                        type: "color",
                        mappingMethod: "linear",
                        dataExtent: [a, o],
                        visual: t.get("color")
                    }),
                    r = i.mapValueToVisual(e.getLayout().value);
                e.setVisual("color", r);
                var s = e.getModel(),
                    l = s.get("itemStyle.normal.color");
                null != l && e.setVisual("color", l)
            })
        })
    }
}, function(t, e, i) {
    var n = i(506);
    i(752), i(755), n.registerVisual(i(756)), n.registerLayout(i(757))
}, function(t, e, i) {
    "use strict";
    var n = i(509),
        r = i(533),
        a = i(753),
        o = r.extend({
            type: "series.boxplot",
            dependencies: ["xAxis", "yAxis", "grid"],
            valueDimensions: ["min", "Q1", "median", "Q3", "max"],
            dimensions: null,
            defaultOption: {
                zlevel: 0,
                z: 2,
                coordinateSystem: "cartesian2d",
                legendHoverLink: !0,
                hoverAnimation: !0,
                layout: null,
                boxWidth: [7, 50],
                itemStyle: {
                    normal: {
                        color: "#fff",
                        borderWidth: 1
                    },
                    emphasis: {
                        borderWidth: 2,
                        shadowBlur: 5,
                        shadowOffsetX: 2,
                        shadowOffsetY: 2,
                        shadowColor: "rgba(0,0,0,0.4)"
                    }
                },
                animationEasing: "elasticOut",
                animationDuration: 800
            }
        });
    n.mixin(o, a.seriesModelMixin, !0), t.exports = o
}, function(t, e, i) {
    "use strict";
    function n(t) {
        return null == t.value ? t : t.value
    }
    var r = i(603),
        a = i(608),
        o = i(754),
        s = i(509),
        l = {
            _baseAxisDim: null,
            getInitialData: function(t, e) {
                var i,
                    o,
                    s = e.getComponent("xAxis", this.get("xAxisIndex")),
                    l = e.getComponent("yAxis", this.get("yAxisIndex")),
                    c = s.get("type"),
                    u = l.get("type");
                "category" === c ? (t.layout = "horizontal", i = s.getCategories(), o = !0) : "category" === u ? (t.layout = "vertical", i = l.getCategories(), o = !0) : t.layout = t.layout || "horizontal", this._baseAxisDim = "horizontal" === t.layout ? "x" : "y";
                var h = t.data,
                    d = this.dimensions = ["base"].concat(this.valueDimensions);
                a(d, h);
                var p = new r(d, this);
                return p.initData(h, i ? i.slice() : null, function(t, e, i, r) {
                    var a = n(t);
                    return o ? "base" === e ? i : a[r - 1] : a[r]
                }), p
            },
            coordDimToDataDim: function(t) {
                var e = this.valueDimensions.slice(),
                    i = ["base"],
                    n = {
                        horizontal: {
                            x: i,
                            y: e
                        },
                        vertical: {
                            x: e,
                            y: i
                        }
                    };
                return n[this.get("layout")][t]
            },
            dataDimToCoordDim: function(t) {
                var e;
                return s.each(["x", "y"], function(i, n) {
                    var r = this.coordDimToDataDim(i);
                    s.indexOf(r, t) >= 0 && (e = i)
                }, this), e
            },
            getBaseAxis: function() {
                var t = this._baseAxisDim;
                return this.ecModel.getComponent(t + "Axis", this.get(t + "AxisIndex")).axis
            }
        },
        c = {
            init: function() {
                var t = this._whiskerBoxDraw = new o(this.getStyleUpdater());
                this.group.add(t.group)
            },
            render: function(t, e, i) {
                this._whiskerBoxDraw.updateData(t.getData())
            },
            remove: function(t) {
                this._whiskerBoxDraw.remove()
            }
        };
    t.exports = {
        seriesModelMixin: l,
        viewMixin: c
    }
}, function(t, e, i) {
    function n(t, e, i, n) {
        l.Group.call(this), this.bodyIndex, this.whiskerIndex, this.styleUpdater = i, this._createContent(t, e, n), this.updateData(t, e, n), this._seriesModel
    }
    function r(t, e, i) {
        return s.map(t, function(t) {
            return t = t.slice(), t[e] = i.initBaseline, t
        })
    }
    function a(t) {
        var e = {};
        return s.each(t, function(t, i) {
            e["ends" + i] = t
        }), e
    }
    function o(t) {
        this.group = new l.Group, this.styleUpdater = t
    }
    var s = i(509),
        l = i(548),
        c = i(550),
        u = c.extend({
            type: "whiskerInBox",
            shape: {},
            buildPath: function(t, e) {
                for (var i in e)
                    if (e.hasOwnProperty(i) && 0 === i.indexOf("ends")) {
                        var n = e[i];
                        t.moveTo(n[0][0], n[0][1]), t.lineTo(n[1][0], n[1][1])
                    }
            }
        }),
        h = n.prototype;
    h._createContent = function(t, e, i) {
        var n = t.getItemLayout(e),
            o = "horizontal" === n.chartLayout ? 1 : 0,
            c = 0;
        this.add(new l.Polygon({
            shape: {
                points: i ? r(n.bodyEnds, o, n) : n.bodyEnds
            },
            style: {
                strokeNoScale: !0
            },
            z2: 100
        })), this.bodyIndex = c++;
        var h = s.map(n.whiskerEnds, function(t) {
            return i ? r(t, o, n) : t
        });
        this.add(new u({
            shape: a(h),
            style: {
                strokeNoScale: !0
            },
            z2: 100
        })), this.whiskerIndex = c++
    }, h.updateData = function(t, e, i) {
        var n = this._seriesModel = t.hostModel,
            r = t.getItemLayout(e),
            o = l[i ? "initProps" : "updateProps"];
        o(this.childAt(this.bodyIndex), {
            shape: {
                points: r.bodyEnds
            }
        }, n, e), o(this.childAt(this.whiskerIndex), {
            shape: a(r.whiskerEnds)
        }, n, e), this.styleUpdater.call(null, this, t, e)
    }, s.inherits(n, l.Group);
    var d = o.prototype;
    d.updateData = function(t) {
        var e = this.group,
            i = this._data,
            r = this.styleUpdater;
        t.diff(i).add(function(i) {
            if (t.hasValue(i)) {
                var a = new n(t, i, r, !0);
                t.setItemGraphicEl(i, a), e.add(a)
            }
        }).update(function(a, o) {
            var s = i.getItemGraphicEl(o);
            return t.hasValue(a) ? (s ? s.updateData(t, a) : s = new n(t, a, r), e.add(s), void t.setItemGraphicEl(a, s)) : void e.remove(s)
        }).remove(function(t) {
            var n = i.getItemGraphicEl(t);
            n && e.remove(n)
        }).execute(), this._data = t
    }, d.remove = function() {
        var t = this.group,
            e = this._data;
        this._data = null, e && e.eachItemGraphicEl(function(e) {
            e && t.remove(e)
        })
    }, t.exports = o
}, function(t, e, i) {
    "use strict";
    function n(t, e, i) {
        var n = e.getItemModel(i),
            r = n.getModel(c),
            a = e.getItemVisual(i, "color"),
            s = r.getItemStyle(["borderColor"]),
            l = t.childAt(t.whiskerIndex);
        l.style.set(s), l.style.stroke = a, l.dirty();
        var h = t.childAt(t.bodyIndex);
        h.style.set(s), h.style.stroke = a, h.dirty();
        var d = n.getModel(u).getItemStyle();
        o.setHoverStyle(t, d)
    }
    var r = i(509),
        a = i(547),
        o = i(548),
        s = i(753),
        l = a.extend({
            type: "boxplot",
            getStyleUpdater: function() {
                return n
            },
            dispose: r.noop
        });
    r.mixin(l, s.viewMixin, !0);
    var c = ["itemStyle", "normal"],
        u = ["itemStyle", "emphasis"];
    t.exports = l
}, function(t, e) {
    var i = ["itemStyle", "normal", "borderColor"];
    t.exports = function(t, e) {
        var n = t.get("color");
        t.eachRawSeriesByType("boxplot", function(e) {
            var r = n[e.seriesIndex % n.length],
                a = e.getData();
            a.setVisual({
                legendSymbol: "roundRect",
                color: e.get(i) || r
            }), t.isSeriesFiltered(e) || a.each(function(t) {
                var e = a.getItemModel(t);
                a.setItemVisual(t, {
                    color: e.get(i, !0)
                })
            })
        })
    }
}, function(t, e, i) {
    function n(t) {
        var e = [],
            i = [];
        return t.eachSeriesByType("boxplot", function(t) {
            var n = t.getBaseAxis(),
                r = o.indexOf(i, n);
            r < 0 && (r = i.length, i[r] = n, e[r] = {
                axis: n,
                seriesModels: []
            }), e[r].seriesModels.push(t)
        }), e
    }
    function r(t) {
        var e,
            i,
            n = t.axis,
            r = t.seriesModels,
            a = r.length,
            s = t.boxWidthList = [],
            u = t.boxOffsetList = [],
            h = [];
        if ("category" === n.type)
            i = n.getBandWidth();
        else {
            var d = 0;
            c(r, function(t) {
                d = Math.max(d, t.getData().count())
            }), e = n.getExtent(), Math.abs(e[1] - e[0]) / d
        }
        c(r, function(t) {
            var e = t.get("boxWidth");
            o.isArray(e) || (e = [e, e]), h.push([l(e[0], i) || 0, l(e[1], i) || 0])
        });
        var p = .8 * i - 2,
            f = p / a * .3,
            g = (p - f * (a - 1)) / a,
            m = g / 2 - p / 2;
        c(r, function(t, e) {
            u.push(m), m += f + g, s.push(Math.min(Math.max(g, h[e][0]), h[e][1]))
        })
    }
    function a(t, e, i) {
        var n = t.coordinateSystem,
            r = t.getData(),
            a = t.dimensions,
            o = t.get("layout"),
            s = i / 2;
        r.each(a, function() {
            function t(t) {
                var i = [];
                i[p] = h, i[f] = t;
                var r;
                return isNaN(h) || isNaN(t) ? r = [NaN, NaN] : (r = n.dataToPoint(i), r[p] += e), r
            }
            function i(t, e) {
                var i = t.slice(),
                    n = t.slice();
                i[p] += s, n[p] -= s, e ? x.push(i, n) : x.push(n, i)
            }
            function l(t) {
                var e = [t.slice(), t.slice()];
                e[0][p] -= s, e[1][p] += s, y.push(e)
            }
            var c = arguments,
                u = a.length,
                h = c[0],
                d = c[u],
                p = "horizontal" === o ? 0 : 1,
                f = 1 - p,
                g = t(c[3]),
                m = t(c[1]),
                v = t(c[5]),
                y = [[m, t(c[2])], [v, t(c[4])]];
            l(m), l(v), l(g);
            var x = [];
            i(y[0][1], 0), i(y[1][1], 1), r.setItemLayout(d, {
                chartLayout: o,
                initBaseline: g[f],
                median: g,
                bodyEnds: x,
                whiskerEnds: y
            })
        })
    }
    var o = i(509),
        s = i(512),
        l = s.parsePercent,
        c = o.each;
    t.exports = function(t) {
        var e = n(t);
        c(e, function(t) {
            var e = t.seriesModels;
            e.length && (r(t), c(e, function(e, i) {
                a(e, t.boxOffsetList[i], t.boxWidthList[i])
            }))
        })
    }
}, function(t, e, i) {
    var n = i(506);
    i(759), i(760), n.registerPreprocessor(i(761)), n.registerVisual(i(762)), n.registerLayout(i(763))
}, function(t, e, i) {
    "use strict";
    var n = i(509),
        r = i(533),
        a = i(753),
        o = i(511),
        s = o.encodeHTML,
        l = o.addCommas,
        c = r.extend({
            type: "series.candlestick",
            dependencies: ["xAxis", "yAxis", "grid"],
            valueDimensions: ["open", "close", "lowest", "highest"],
            dimensions: null,
            defaultOption: {
                zlevel: 0,
                z: 2,
                coordinateSystem: "cartesian2d",
                legendHoverLink: !0,
                hoverAnimation: !0,
                layout: null,
                itemStyle: {
                    normal: {
                        color: "#c23531",
                        color0: "#314656",
                        borderWidth: 1,
                        borderColor: "#c23531",
                        borderColor0: "#314656"
                    },
                    emphasis: {
                        borderWidth: 2
                    }
                },
                animationUpdate: !1,
                animationEasing: "linear",
                animationDuration: 300
            },
            getShadowDim: function() {
                return "open"
            },
            formatTooltip: function(t, e) {
                var i = n.map(this.valueDimensions, function(e) {
                    return e + ": " + l(this._data.get(e, t))
                }, this);
                return s(this.name) + "<br />" + i.join("<br />")
            },
            brushSelector: function(t, e) {
                return e.rect(t.brushRect)
            }
        });
    n.mixin(c, a.seriesModelMixin, !0), t.exports = c
}, function(t, e, i) {
    "use strict";
    function n(t, e, i) {
        var n = e.getItemModel(i),
            r = n.getModel(c),
            a = e.getItemVisual(i, "color"),
            s = e.getItemVisual(i, "borderColor") || a,
            l = r.getItemStyle(["color", "color0", "borderColor", "borderColor0"]),
            h = t.childAt(t.whiskerIndex);
        h.useStyle(l), h.style.stroke = s;
        var d = t.childAt(t.bodyIndex);
        d.useStyle(l), d.style.fill = a, d.style.stroke = s;
        var p = n.getModel(u).getItemStyle();
        o.setHoverStyle(t, p)
    }
    var r = i(509),
        a = i(547),
        o = i(548),
        s = i(753),
        l = a.extend({
            type: "candlestick",
            getStyleUpdater: function() {
                return n
            },
            dispose: r.noop
        });
    r.mixin(l, s.viewMixin, !0);
    var c = ["itemStyle", "normal"],
        u = ["itemStyle", "emphasis"];
    t.exports = l
}, function(t, e, i) {
    var n = i(509);
    t.exports = function(t) {
        t && n.isArray(t.series) && n.each(t.series, function(t) {
            n.isObject(t) && "k" === t.type && (t.type = "candlestick")
        })
    }
}, function(t, e) {
    var i = ["itemStyle", "normal", "borderColor"],
        n = ["itemStyle", "normal", "borderColor0"],
        r = ["itemStyle", "normal", "color"],
        a = ["itemStyle", "normal", "color0"];
    t.exports = function(t, e) {
        t.eachRawSeriesByType("candlestick", function(e) {
            var o = e.getData();
            o.setVisual({
                legendSymbol: "roundRect"
            }), t.isSeriesFiltered(e) || o.each(function(t) {
                var e = o.getItemModel(t),
                    s = o.getItemLayout(t).sign;
                o.setItemVisual(t, {
                    color: e.get(s > 0 ? r : a),
                    borderColor: e.get(s > 0 ? i : n)
                })
            })
        })
    }
}, function(t, e) {
    function i(t, e) {
        var i,
            o = t.getBaseAxis(),
            s = "category" === o.type ? o.getBandWidth() : (i = o.getExtent(), Math.abs(i[1] - i[0]) / e.count());
        return s / 2 - 2 > r ? s / 2 - 2 : s - r > a ? r : Math.max(s - a, n)
    }
    var n = 2,
        r = 5,
        a = 4;
    t.exports = function(t) {
        t.eachSeriesByType("candlestick", function(t) {
            var e = t.coordinateSystem,
                n = t.getData(),
                r = t.dimensions,
                a = t.get("layout"),
                o = i(t, n);
            n.each(r, function() {
                function t(t) {
                    var i = [];
                    return i[d] = u, i[p] = t, isNaN(u) || isNaN(t) ? [NaN, NaN] : e.dataToPoint(i)
                }
                function i(t, e) {
                    var i = t.slice(),
                        n = t.slice();
                    i[d] += o / 2, n[d] -= o / 2, e ? A.push(i, n) : A.push(n, i)
                }
                function s() {
                    var e = t(Math.min(f, g, m, v)),
                        i = t(Math.max(f, g, m, v));
                    return e[d] -= o / 2, i[d] -= o / 2, {
                        x: e[0],
                        y: e[1],
                        width: p ? o : i[0] - e[0],
                        height: p ? i[1] - e[1] : o
                    }
                }
                var l = arguments,
                    c = r.length,
                    u = l[0],
                    h = l[c],
                    d = "horizontal" === a ? 0 : 1,
                    p = 1 - d,
                    f = l[1],
                    g = l[2],
                    m = l[3],
                    v = l[4],
                    y = Math.min(f, g),
                    x = Math.max(f, g),
                    _ = t(y),
                    b = t(x),
                    w = t(m),
                    M = t(v),
                    S = [[M, b], [w, _]],
                    A = [];
                i(b, 0), i(_, 1), n.setItemLayout(h, {
                    chartLayout: a,
                    sign: f > g ? -1 : f < g ? 1 : 0,
                    initBaseline: f > g ? b[p] : _[p],
                    bodyEnds: A,
                    whiskerEnds: S,
                    brushRect: s()
                })
            }, !0)
        })
    }
}, function(t, e, i) {
    var n = i(509),
        r = i(506);
    i(765), i(766), r.registerVisual(n.curry(i(615), "effectScatter", "circle", null)), r.registerLayout(n.curry(i(616), "effectScatter"))
}, function(t, e, i) {
    "use strict";
    var n = i(607),
        r = i(533);
    t.exports = r.extend({
        type: "series.effectScatter",
        dependencies: ["grid", "polar"],
        getInitialData: function(t, e) {
            var i = n(t.data, this, e);
            return i
        },
        brushSelector: "point",
        defaultOption: {
            coordinateSystem: "cartesian2d",
            zlevel: 0,
            z: 2,
            legendHoverLink: !0,
            effectType: "ripple",
            progressive: 0,
            showEffectOn: "render",
            rippleEffect: {
                period: 4,
                scale: 2.5,
                brushType: "fill"
            },
            symbolSize: 10
        }
    })
}, function(t, e, i) {
    var n = i(610),
        r = i(767);
    i(506).extendChartView({
        type: "effectScatter",
        init: function() {
            this._symbolDraw = new n(r)
        },
        render: function(t, e, i) {
            var n = t.getData(),
                r = this._symbolDraw;
            r.updateData(n), this.group.add(r.group)
        },
        updateLayout: function() {
            this._symbolDraw.updateLayout()
        },
        remove: function(t, e) {
            this._symbolDraw && this._symbolDraw.remove(e)
        },
        dispose: function() {}
    })
}, function(t, e, i) {
    function n(t) {
        return o.isArray(t) || (t = [+t, +t]), t
    }
    function r(t, e) {
        t.eachChild(function(t) {
            t.attr({
                z: e.z,
                zlevel: e.zlevel,
                style: {
                    stroke: "stroke" === e.brushType ? e.color : null,
                    fill: "fill" === e.brushType ? e.color : null
                }
            })
        })
    }
    function a(t, e) {
        h.call(this);
        var i = new u(t, e),
            n = new h;
        this.add(i), this.add(n), n.beforeUpdate = function() {
            this.attr(i.getScale())
        }, this.updateData(t, e)
    }
    var o = i(509),
        s = i(612),
        l = i(548),
        c = i(512),
        u = i(611),
        h = l.Group,
        d = 3,
        p = a.prototype;
    p.stopEffectAnimation = function() {
        this.childAt(1).removeAll()
    }, p.startEffectAnimation = function(t) {
        for (var e = t.symbolType, i = t.color, n = this.childAt(1), a = 0; a < d; a++) {
            var o = s.createSymbol(e, -1, -1, 2, 2, i);
            o.attr({
                style: {
                    strokeNoScale: !0
                },
                z2: 99,
                silent: !0,
                scale: [.5, .5]
            });
            var l = -a / d * t.period + t.effectOffset;
            o.animate("", !0).when(t.period, {
                scale: [t.rippleScale / 2, t.rippleScale / 2]
            }).delay(l).start(), o.animateStyle(!0).when(t.period, {
                opacity: 0
            }).delay(l).start(), n.add(o)
        }
        r(n, t)
    }, p.updateEffectAnimation = function(t) {
        for (var e = this._effectCfg, i = this.childAt(1), n = ["symbolType", "period", "rippleScale"], a = 0; a < n; a++) {
            var o = n[a];
            if (e[o] !== t[o])
                return this.stopEffectAnimation(), void this.startEffectAnimation(t)
        }
        r(i, t)
    }, p.highlight = function() {
        this.trigger("emphasis")
    }, p.downplay = function() {
        this.trigger("normal")
    }, p.updateData = function(t, e) {
        var i = t.hostModel;
        this.childAt(0).updateData(t, e);
        var r = this.childAt(1),
            a = t.getItemModel(e),
            o = t.getItemVisual(e, "symbol"),
            s = n(t.getItemVisual(e, "symbolSize")),
            l = t.getItemVisual(e, "color");
        r.attr("scale", s), r.traverse(function(t) {
            t.attr({
                fill: l
            })
        });
        var u = a.getShallow("symbolOffset");
        if (u) {
            var h = r.position;
            h[0] = c.parsePercent(u[0], s[0]), h[1] = c.parsePercent(u[1], s[1])
        }
        r.rotation = (a.getShallow("symbolRotate") || 0) * Math.PI / 180 || 0;
        var d = {};
        if (d.showEffectOn = i.get("showEffectOn"), d.rippleScale = a.get("rippleEffect.scale"), d.brushType = a.get("rippleEffect.brushType"), d.period = 1e3 * a.get("rippleEffect.period"), d.effectOffset = e / t.count(), d.z = a.getShallow("z") || 0, d.zlevel = a.getShallow("zlevel") || 0, d.symbolType = o, d.color = l, this.off("mouseover").off("mouseout").off("emphasis").off("normal"), "render" === d.showEffectOn)
            this._effectCfg ? this.updateEffectAnimation(d) : this.startEffectAnimation(d), this._effectCfg = d;
        else {
            this._effectCfg = null, this.stopEffectAnimation();
            var p = this.childAt(0),
                f = function() {
                    p.trigger("emphasis"), "render" !== d.showEffectOn && this.startEffectAnimation(d)
                },
                g = function() {
                    p.trigger("normal"), "render" !== d.showEffectOn && this.stopEffectAnimation()
                };
            this.on("mouseover", f, this).on("mouseout", g, this).on("emphasis", f, this).on("normal", g, this)
        }
        this._effectCfg = d
    }, p.fadeOut = function(t) {
        this.off("mouseover").off("mouseout").off("emphasis").off("normal"), t && t()
    }, o.inherits(a, h), t.exports = a
}, function(t, e, i) {
    i(769), i(770);
    var n = i(506);
    n.registerLayout(i(775))
}, function(t, e, i) {
    "use strict";
    function n(t) {
        var e = t.data;
        e && e[0] && e[0][0] && e[0][0].coord && (__DEV__ && console.warn("Lines data configuration has been changed to { coords:[[1,2],[2,3]] }"), t.data = o.map(e, function(t) {
            var e = [t[0].coord, t[1].coord],
                i = {
                    coords: e
                };
            return t[0].name && (i.fromName = t[0].name), t[1].name && (i.toName = t[1].name), o.mergeAll([i, t[0], t[1]])
        }))
    }
    var r = i(533),
        a = i(603),
        o = i(509),
        s = i(531),
        l = r.extend({
            type: "series.lines",
            dependencies: ["grid", "polar"],
            visualColorAccessPath: "lineStyle.normal.color",
            init: function(t) {
                n(t), l.superApply(this, "init", arguments)
            },
            mergeOption: function(t) {
                n(t), l.superApply(this, "mergeOption", arguments)
            },
            getInitialData: function(t, e) {
                if (__DEV__) {
                    var i = s.get(t.coordinateSystem);
                    if (!i)
                        throw new Error("Unkown coordinate system " + t.coordinateSystem)
                }
                var n = new a(["value"], this);
                return n.hasItemOption = !1, n.initData(t.data, [], function(t, e, i, r) {
                    if (t instanceof Array)
                        return NaN;
                    n.hasItemOption = !0;
                    var a = t.value;
                    return null != a ? a instanceof Array ? a[r] : a : void 0
                }), n
            },
            formatTooltip: function(t) {
                var e = this.getData(),
                    i = e.getItemModel(t),
                    n = i.get("name");
                if (n)
                    return n;
                var r = i.get("fromName"),
                    a = i.get("toName");
                return r + " > " + a
            },
            defaultOption: {
                coordinateSystem: "geo",
                zlevel: 0,
                z: 2,
                legendHoverLink: !0,
                hoverAnimation: !0,
                xAxisIndex: 0,
                yAxisIndex: 0,
                geoIndex: 0,
                effect: {
                    show: !1,
                    period: 4,
                    constantSpeed: 0,
                    symbol: "circle",
                    symbolSize: 3,
                    loop: !0,
                    trailLength: .2
                },
                large: !1,
                largeThreshold: 2e3,
                polyline: !1,
                label: {
                    normal: {
                        show: !1,
                        position: "end"
                    }
                },
                lineStyle: {
                    normal: {
                        opacity: .5
                    }
                }
            }
        })
}, function(t, e, i) {
    var n = i(706),
        r = i(771),
        a = i(707),
        o = i(772),
        s = i(773),
        l = i(774);
    i(506).extendChartView({
        type: "lines",
        init: function() {},
        render: function(t, e, i) {
            var c = t.getData(),
                u = this._lineDraw,
                h = t.get("effect.show"),
                d = t.get("polyline"),
                p = t.get("large") && c.count() >= t.get("largeThreshold");
            __DEV__ && h && p && console.warn("Large lines not support effect"), h === this._hasEffet && d === this._isPolyline && p === this._isLarge || (u && u.remove(), u = this._lineDraw = p ? new l : new n(d ? h ? s : o : h ? r : a), this._hasEffet = h, this._isPolyline = d, this._isLarge = p);
            var f = t.get("zlevel"),
                g = t.get("effect.trailLength"),
                m = i.getZr();
            if (m.painter.getLayer(f).clear(!0), null != this._lastZlevel && m.configLayer(this._lastZlevel, {
                motionBlur: !1
            }), h && g) {
                if (__DEV__) {
                    var v = !1;
                    e.eachSeries(function(e) {
                        e !== t && e.get("zlevel") === f && (v = !0)
                    }), v && console.warn("Lines with trail effect should have an individual zlevel")
                }
                m.configLayer(f, {
                    motionBlur: !0,
                    lastFrameAlpha: Math.max(Math.min(g / 10 + .9, 1), 0)
                })
            }
            this.group.add(u.group), u.updateData(c), this._lastZlevel = f
        },
        updateLayout: function(t, e, i) {
            this._lineDraw.updateLayout(t);
            var n = i.getZr();
            n.painter.getLayer(this._lastZlevel).clear(!0)
        },
        remove: function(t, e) {
            this._lineDraw && this._lineDraw.remove(e, !0)
        },
        dispose: function() {}
    })
}, function(t, e, i) {
    function n(t, e, i) {
        r.Group.call(this), this.add(this.createLine(t, e, i)), this._updateEffectSymbol(t, e)
    }
    var r = i(548),
        a = i(707),
        o = i(509),
        s = i(612),
        l = i(515),
        c = i(555),
        u = n.prototype;
    u.createLine = function(t, e, i) {
        return new a(t, e, i)
    }, u._updateEffectSymbol = function(t, e) {
        var i = t.getItemModel(e),
            n = i.getModel("effect"),
            r = n.get("symbolSize"),
            a = n.get("symbol");
        o.isArray(r) || (r = [r, r]);
        var l = n.get("color") || t.getItemVisual(e, "color"),
            c = this.childAt(1);
        this._symbolType !== a && (this.remove(c), c = s.createSymbol(a, -.5, -.5, 1, 1, l), c.z2 = 100, c.culling = !0, this.add(c)), c && (c.setStyle("shadowColor", l), c.setStyle(n.getItemStyle(["color"])), c.attr("scale", r), c.setColor(l), c.attr("scale", r), this._symbolType = a, this._updateEffectAnimation(t, n, e))
    }, u._updateEffectAnimation = function(t, e, i) {
        var n = this.childAt(1);
        if (n) {
            var r = this,
                a = t.getItemLayout(i),
                s = 1e3 * e.get("period"),
                l = e.get("loop"),
                c = e.get("constantSpeed"),
                u = o.retrieve(e.get("delay"), function(e) {
                    return e / t.count() * s / 3
                }),
                h = "function" == typeof u;
            if (n.ignore = !0, this.updateAnimationPoints(n, a), c > 0 && (s = this.getLineLength(n) / c * 1e3), s !== this._period || l !== this._loop) {
                n.stopAnimation();
                var d = u;
                h && (d = u(i)), n.__t > 0 && (d = -s * n.__t), n.__t = 0;
                var p = n.animate("", l).when(s, {
                    __t: 1
                }).delay(d).during(function() {
                    r.updateSymbolPosition(n)
                });
                l || p.done(function() {
                    r.remove(n)
                }), p.start()
            }
            this._period = s, this._loop = l
        }
    }, u.getLineLength = function(t) {
        return l.dist(t.__p1, t.__cp1) + l.dist(t.__cp1, t.__p2)
    }, u.updateAnimationPoints = function(t, e) {
        t.__p1 = e[0], t.__p2 = e[1], t.__cp1 = e[2] || [(e[0][0] + e[1][0]) / 2, (e[0][1] + e[1][1]) / 2]
    }, u.updateData = function(t, e, i) {
        this.childAt(0).updateData(t, e, i), this._updateEffectSymbol(t, e)
    }, u.updateSymbolPosition = function(t) {
        var e = t.__p1,
            i = t.__p2,
            n = t.__cp1,
            r = t.__t,
            a = t.position,
            o = c.quadraticAt,
            s = c.quadraticDerivativeAt;
        a[0] = o(e[0], n[0], i[0], r), a[1] = o(e[1], n[1], i[1], r);
        var l = s(e[0], n[0], i[0], r),
            u = s(e[1], n[1], i[1], r);
        t.rotation = -Math.atan2(u, l) - Math.PI / 2, t.ignore = !1
    }, u.updateLayout = function(t, e) {
        this.childAt(0).updateLayout(t, e);
        var i = t.getItemModel(e).getModel("effect");
        this._updateEffectAnimation(t, i, e)
    }, o.inherits(n, r.Group), t.exports = n
}, function(t, e, i) {
    function n(t, e, i) {
        r.Group.call(this), this._createPolyline(t, e, i)
    }
    var r = i(548),
        a = i(509),
        o = n.prototype;
    o._createPolyline = function(t, e, i) {
        var n = t.getItemLayout(e),
            a = new r.Polyline({
                shape: {
                    points: n
                }
            });
        this.add(a), this._updateCommonStl(t, e, i)
    }, o.updateData = function(t, e, i) {
        var n = t.hostModel,
            a = this.childAt(0),
            o = {
                shape: {
                    points: t.getItemLayout(e)
                }
            };
        r.updateProps(a, o, n, e), this._updateCommonStl(t, e, i)
    }, o._updateCommonStl = function(t, e, i) {
        var n = this.childAt(0),
            o = t.getItemModel(e),
            s = t.getItemVisual(e, "color"),
            l = i && i.lineStyle,
            c = i && i.hoverLineStyle;
        i && !t.hasItemOption || (l = o.getModel("lineStyle.normal").getLineStyle(), c = o.getModel("lineStyle.emphasis").getLineStyle()), n.useStyle(a.defaults({
            strokeNoScale: !0,
            fill: "none",
            stroke: s
        }, l)), n.hoverStyle = c, r.setHoverStyle(this)
    }, o.updateLayout = function(t, e) {
        var i = this.childAt(0);
        i.setShape("points", t.getItemLayout(e))
    }, a.inherits(n, r.Group), t.exports = n
}, function(t, e, i) {
    function n(t, e, i) {
        o.call(this, t, e, i), this._lastFrame = 0, this._lastFramePercent = 0
    }
    var r = i(772),
        a = i(509),
        o = i(771),
        s = i(515),
        l = n.prototype;
    l.createLine = function(t, e, i) {
        return new r(t, e, i)
    }, l.updateAnimationPoints = function(t, e) {
        this._points = e;
        for (var i = [0], n = 0, r = 1; r < e.length; r++) {
            var a = e[r - 1],
                o = e[r];
            n += s.dist(a, o), i.push(n)
        }
        if (0 !== n) {
            for (var r = 0; r < i.length; r++)
                i[r] /= n;
            this._offsets = i, this._length = n
        }
    }, l.getLineLength = function(t) {
        return this._length
    }, l.updateSymbolPosition = function(t) {
        var e = t.__t,
            i = this._points,
            n = this._offsets,
            r = i.length;
        if (n) {
            var a,
                o = this._lastFrame;
            if (e < this._lastFramePercent) {
                var l = Math.min(o + 1, r - 1);
                for (a = l; a >= 0 && !(n[a] <= e); a--)
                    ;
                a = Math.min(a, r - 2)
            } else {
                for (var a = o; a < r && !(n[a] > e); a++)
                    ;
                a = Math.min(a - 1, r - 2)
            }
            s.lerp(t.position, i[a], i[a + 1], (e - n[a]) / (n[a + 1] - n[a]));
            var c = i[a + 1][0] - i[a][0],
                u = i[a + 1][1] - i[a][1];
            t.rotation = -Math.atan2(u, c) - Math.PI / 2, this._lastFrame = a, this._lastFramePercent = e, t.ignore = !1
        }
    }, a.inherits(n, o), t.exports = n
}, function(t, e, i) {
    function n() {
        this.group = new r.Group, this._lineEl = new s
    }
    var r = i(548),
        a = i(560),
        o = i(558),
        s = r.extendShape({
            shape: {
                polyline: !1,
                segs: []
            },
            buildPath: function(t, e) {
                for (var i = e.segs, n = e.polyline, r = 0; r < i.length; r++) {
                    var a = i[r];
                    if (n) {
                        t.moveTo(a[0][0], a[0][1]);
                        for (var o = 1; o < a.length; o++)
                            t.lineTo(a[o][0], a[o][1])
                    } else
                        t.moveTo(a[0][0], a[0][1]), a.length > 2 ? t.quadraticCurveTo(a[2][0], a[2][1], a[1][0], a[1][1]) : t.lineTo(a[1][0], a[1][1])
                }
            },
            findDataIndex: function(t, e) {
                for (var i = this.shape, n = i.segs, r = i.polyline, s = Math.max(this.style.lineWidth, 1), l = 0; l < n.length; l++) {
                    var c = n[l];
                    if (r) {
                        for (var u = 1; u < c.length; u++)
                            if (o.containStroke(c[u - 1][0], c[u - 1][1], c[u][0], c[u][1], s, t, e))
                                return l
                    } else if (c.length > 2) {
                        if (a.containStroke(c[0][0], c[0][1], c[2][0], c[2][1], c[1][0], c[1][1], s, t, e))
                            return l
                    } else if (o.containStroke(c[0][0], c[0][1], c[1][0], c[1][1], s, t, e))
                        return l
                }
                return -1
            }
        }),
        l = n.prototype;
    l.updateData = function(t) {
        this.group.removeAll();
        var e = this._lineEl,
            i = t.hostModel;
        e.setShape({
            segs: t.mapArray(t.getItemLayout),
            polyline: i.get("polyline")
        }), e.useStyle(i.getModel("lineStyle.normal").getLineStyle());
        var n = t.getVisual("color");
        n && e.setStyle("stroke", n), e.setStyle("fill"), e.seriesIndex = i.seriesIndex, e.on("mousemove", function(t) {
            e.dataIndex = null;
            var i = e.findDataIndex(t.offsetX, t.offsetY);
            i > 0 && (e.dataIndex = i)
        }), this.group.add(e)
    }, l.updateLayout = function(t) {
        var e = t.getData();
        this._lineEl.setShape({
            segs: e.mapArray(e.getItemLayout)
        })
    }, l.remove = function() {
        this.group.removeAll()
    }, t.exports = n
}, function(t, e) {
    t.exports = function(t) {
        t.eachSeriesByType("lines", function(t) {
            var e = t.coordinateSystem,
                i = t.getData();
            i.each(function(n) {
                var r = i.getItemModel(n),
                    a = r.option instanceof Array ? r.option : r.get("coords");
                if (__DEV__ && !(a instanceof Array && a.length > 0 && a[0] instanceof Array))
                    throw new Error("Invalid coords " + JSON.stringify(a) + ". Lines must have 2d coords array in data item.");
                var o = [];
                if (t.get("polyline"))
                    for (var s = 0; s < a.length; s++)
                        o.push(e.dataToPoint(a[s]));
                else {
                    o[0] = e.dataToPoint(a[0]), o[1] = e.dataToPoint(a[1]);
                    var l = r.get("lineStyle.normal.curveness");
                    +l && (o[2] = [(o[0][0] + o[1][0]) / 2 - (o[0][1] - o[1][1]) * l, (o[0][1] + o[1][1]) / 2 - (o[1][0] - o[0][0]) * l])
                }
                i.setItemLayout(n, o)
            })
        })
    }
}, function(t, e, i) {
    i(777), i(778)
}, function(t, e, i) {
    var n = i(533),
        r = i(607);
    t.exports = n.extend({
        type: "series.heatmap",
        getInitialData: function(t, e) {
            return r(t.data, this, e)
        },
        defaultOption: {
            coordinateSystem: "cartesian2d",
            zlevel: 0,
            z: 2,
            geoIndex: 0,
            blurSize: 30,
            pointSize: 20,
            maxOpacity: 1,
            minOpacity: 0
        }
    })
}, function(t, e, i) {
    function n(t, e, i) {
        var n = t[1] - t[0];
        e = l.map(e, function(e) {
            return {
                interval: [(e.interval[0] - t[0]) / n, (e.interval[1] - t[0]) / n]
            }
        });
        var r = e.length,
            a = 0;
        return function(t) {
            for (var n = a; n < r; n++) {
                var o = e[n].interval;
                if (o[0] <= t && t <= o[1]) {
                    a = n;
                    break
                }
            }
            if (n === r)
                for (var n = a - 1; n >= 0; n--) {
                    var o = e[n].interval;
                    if (o[0] <= t && t <= o[1]) {
                        a = n;
                        break
                    }
                }
            return n >= 0 && n < r && i[n]
        }
    }
    function r(t, e) {
        var i = t[1] - t[0];
        return e = [(e[0] - t[0]) / i, (e[1] - t[0]) / i], function(t) {
            return t >= e[0] && t <= e[1]
        }
    }
    function a(t) {
        var e = t.dimensions;
        return "lng" === e[0] && "lat" === e[1]
    }
    var o = i(548),
        s = i(779),
        l = i(509);
    t.exports = i(506).extendChartView({
        type: "heatmap",
        render: function(t, e, i) {
            var n;
            if (e.eachComponent("visualMap", function(e) {
                e.eachTargetSeries(function(i) {
                    i === t && (n = e)
                })
            }), __DEV__ && !n)
                throw new Error("Heatmap must use with visualMap");
            this.group.removeAll();
            var r = t.coordinateSystem;
            "cartesian2d" === r.type ? this._renderOnCartesian(r, t, i) : a(r) && this._renderOnGeo(r, t, n, i)
        },
        dispose: function() {},
        _renderOnCartesian: function(t, e, i) {
            var n = t.getAxis("x"),
                r = t.getAxis("y"),
                a = this.group;
            if (__DEV__) {
                if ("category" !== n.type || "category" !== r.type)
                    throw new Error("Heatmap on cartesian must have two category axes");
                if (!n.onBand || !r.onBand)
                    throw new Error("Heatmap on cartesian must have two axes with boundaryGap true")
            }
            var s = n.getBandWidth(),
                c = r.getBandWidth(),
                u = e.getData(),
                h = "itemStyle.normal",
                d = "itemStyle.emphasis",
                p = "label.normal",
                f = "label.emphasis",
                g = e.getModel(h).getItemStyle(["color"]),
                m = e.getModel(d).getItemStyle(),
                v = e.getModel("label.normal"),
                y = e.getModel("label.emphasis");
            u.each(["x", "y", "z"], function(i, n, r, x) {
                var _ = u.getItemModel(x),
                    b = t.dataToPoint([i, n]);
                if (!isNaN(r)) {
                    var w = new o.Rect({
                        shape: {
                            x: b[0] - s / 2,
                            y: b[1] - c / 2,
                            width: s,
                            height: c
                        },
                        style: {
                            fill: u.getItemVisual(x, "color"),
                            opacity: u.getItemVisual(x, "opacity")
                        }
                    });
                    u.hasItemOption && (g = _.getModel(h).getItemStyle(["color"]), m = _.getModel(d).getItemStyle(), v = _.getModel(p), y = _.getModel(f));
                    var M = e.getRawValue(x),
                        S = "-";
                    M && null != M[2] && (S = M[2]), v.getShallow("show") && (o.setText(g, v), g.text = e.getFormattedLabel(x, "normal") || S), y.getShallow("show") && (o.setText(m, y), m.text = e.getFormattedLabel(x, "emphasis") || S), w.setStyle(g), o.setHoverStyle(w, u.hasItemOption ? m : l.extend({}, m)), a.add(w), u.setItemGraphicEl(x, w)
                }
            })
        },
        _renderOnGeo: function(t, e, i, a) {
            var l = i.targetVisuals.inRange,
                c = i.targetVisuals.outOfRange,
                u = e.getData(),
                h = this._hmLayer || this._hmLayer || new s;
            h.blurSize = e.get("blurSize"), h.pointSize = e.get("pointSize"), h.minOpacity = e.get("minOpacity"), h.maxOpacity = e.get("maxOpacity");
            var d = t.getViewRect().clone(),
                p = t.getRoamTransform().transform;
            d.applyTransform(p);
            var f = Math.max(d.x, 0),
                g = Math.max(d.y, 0),
                m = Math.min(d.width + d.x, a.getWidth()),
                v = Math.min(d.height + d.y, a.getHeight()),
                y = m - f,
                x = v - g,
                _ = u.mapArray(["lng", "lat", "value"], function(e, i, n) {
                    var r = t.dataToPoint([e, i]);
                    return r[0] -= f, r[1] -= g, r.push(n), r
                }),
                b = i.getExtent(),
                w = "visualMap.continuous" === i.type ? r(b, i.option.range) : n(b, i.getPieceList(), i.option.selected);
            h.update(_, y, x, l.color.getNormalizer(), {
                inRange: l.color.getColorMapper(),
                outOfRange: c.color.getColorMapper()
            }, w);
            var M = new o.Image({
                style: {
                    width: y,
                    height: x,
                    x: f,
                    y: g,
                    image: h.canvas
                },
                silent: !0
            });
            this.group.add(M)
        }
    })
}, function(t, e, i) {
    function n() {
        var t = a.createCanvas();
        this.canvas = t, this.blurSize = 30, this.pointSize = 20, this.maxOpacity = 1, this.minOpacity = 0, this._gradientPixels = {}
    }
    var r = 256,
        a = i(509);
    n.prototype = {
        update: function(t, e, i, n, a, o) {
            var s = this._getBrush(),
                l = this._getGradient(t, a, "inRange"),
                c = this._getGradient(t, a, "outOfRange"),
                u = this.pointSize + this.blurSize,
                h = this.canvas,
                d = h.getContext("2d"),
                p = t.length;
            h.width = e, h.height = i;
            for (var f = 0; f < p; ++f) {
                var g = t[f],
                    m = g[0],
                    v = g[1],
                    y = g[2],
                    x = n(y);
                d.globalAlpha = x, d.drawImage(s, m - u, v - u)
            }
            for (var _ = d.getImageData(0, 0, h.width, h.height), b = _.data, w = 0, M = b.length, S = this.minOpacity, A = this.maxOpacity, I = A - S; w < M;) {
                var x = b[w + 3] / 256,
                    D = 4 * Math.floor(x * (r - 1));
                if (x > 0) {
                    var k = o(x) ? l : c;
                    x > 0 && (x = x * I + S), b[w++] = k[D], b[w++] = k[D + 1], b[w++] = k[D + 2], b[w++] = k[D + 3] * x * 256
                } else
                    w += 4
            }
            return d.putImageData(_, 0, 0), h
        },
        _getBrush: function() {
            var t = this._brushCanvas || (this._brushCanvas = a.createCanvas()),
                e = this.pointSize + this.blurSize,
                i = 2 * e;
            t.width = i, t.height = i;
            var n = t.getContext("2d");
            return n.clearRect(0, 0, i, i), n.shadowOffsetX = i, n.shadowBlur = this.blurSize, n.shadowColor = "#000", n.beginPath(), n.arc(-e, e, this.pointSize, 0, 2 * Math.PI, !0), n.closePath(), n.fill(), t
        },
        _getGradient: function(t, e, i) {
            for (var n = this._gradientPixels, r = n[i] || (n[i] = new Uint8ClampedArray(1024)), a = [], o = 0, s = 0; s < 256; s++)
                e[i](s / 255, !0, a), r[o++] = a[0], r[o++] = a[1], r[o++] = a[2], r[o++] = a[3];
            return r
        }
    }, t.exports = n
}, function(t, e, i) {
    function n(t, e, i, n) {
        var r = i.type;
        __DEV__ && l.assert(r, "graphic type MUST be set");
        var a = u[r.charAt(0).toUpperCase() + r.slice(1)];
        __DEV__ && l.assert(a, "graphic type can not be found");
        var o = new a(i);
        e.add(o), n[t] = o, o.__ecGraphicId = t
    }
    function r(t, e) {
        var i = t && t.parent;
        i && ("group" === t.type && t.traverse(function(t) {
            r(t, e)
        }), delete e[t.__ecGraphicId], i.remove(t))
    }
    function a(t) {
        return t = l.extend({}, t), l.each(["id", "parentId", "$action", "hv", "bounding"].concat(h.LOCATION_PARAMS), function(e) {
            delete t[e]
        }), t
    }
    function o(t, e) {
        var i;
        return l.each(e, function(e) {
            null != t[e] && "auto" !== t[e] && (i = !0)
        }), i
    }
    var s = i(506),
        l = i(509),
        c = i(510),
        u = i(548),
        h = (i(511), i(526));
    s.registerPreprocessor(function(t) {
        var e = t && t.graphic;
        l.isArray(e) ? e[0] && e[0].elements ? t.graphic = [t.graphic[0]] : t.graphic = [{
            elements: e
        }] : e && !e.elements && (t.graphic = [{
            elements: [e]
        }])
    });
    var d = s.extendComponentModel({
        type: "graphic",
        defaultOption: {
            elements: [],
            parentId: null
        },
        _elOptionsToUpdate: null,
        mergeOption: function(t) {
            var e = this.option.elements;
            this.option.elements = null, d.superApply(this, "mergeOption", arguments), this.option.elements = e
        },
        optionUpdated: function(t, e) {
            var i = this.option,
                n = (e ? i : t).elements,
                r = i.elements = e ? [] : i.elements,
                a = [];
            this._flatten(n, a);
            var s = c.mappingToExists(r, a);
            c.makeIdAndName(s);
            var u = this._elOptionsToUpdate = [];
            l.each(s, function(t, e) {
                var i = t.exist,
                    n = t.option;
                if (__DEV__ && l.assert(l.isObject(n) || i, "Empty graphic option definition"), n) {
                    n.id = t.keyInfo.id;
                    var a = n.parentId,
                        s = n.parentOption,
                        c = i && i.parentId;
                    !n.type && i && (n.type = i.type), n.parentId = a ? a : s ? s.id : c ? c : null, n.parentOption = null, u.push(n);
                    var d = l.extend({}, n),
                        p = n.$action;
                    if (p && "merge" !== p)
                        "replace" === p ? r[e] = d : "remove" === p && i && (r[e] = null);
                    else if (i) {
                        if (__DEV__) {
                            var f = n.type;
                            l.assert(!f || i.type === f, 'Please set $action: "replace" to change `type`')
                        }
                        l.merge(i, d, !0), h.mergeLayoutParam(i, d, {
                            ignoreSize: !0
                        }), h.copyLayoutParams(n, i)
                    } else
                        r[e] = d;
                    r[e] && (r[e].hv = n.hv = [o(n, ["left", "right"]), o(n, ["top", "bottom"])], "group" === r[e].type && (null == r[e].width && (r[e].width = n.width = 0), null == r[e].height && (r[e].height = n.height = 0)))
                }
            }, this);
            for (var d = r.length - 1; d >= 0; d--)
                null == r[d] ? r.splice(d, 1) : delete r[d].$action
        },
        _flatten: function(t, e, i) {
            l.each(t, function(t) {
                if (t) {
                    i && (t.parentOption = i), e.push(t);
                    var n = t.children;
                    "group" === t.type && n && this._flatten(n, e, t), delete t.children
                }
            }, this)
        },
        useElOptionsToUpdate: function() {
            var t = this._elOptionsToUpdate;
            return this._elOptionsToUpdate = null, t
        }
    });
    s.extendComponentView({
        type: "graphic",
        init: function(t, e) {
            this._elMap = {}, this._lastGraphicModel
        },
        render: function(t, e, i) {
            t !== this._lastGraphicModel && this._clear(), this._lastGraphicModel = t, this._updateElements(t, i), this._relocate(t, i)
        },
        _updateElements: function(t, e) {
            var i = t.useElOptionsToUpdate();
            if (i) {
                var o = this._elMap,
                    s = this.group;
                l.each(i, function(t) {
                    var e = t.$action,
                        i = t.id,
                        c = o[i],
                        u = t.parentId,
                        h = null != u ? o[u] : s;
                    t.hv && t.hv[1] && "text" === t.type && (t.style = l.defaults({
                        textBaseline: "middle"
                    }, t.style), t.style.textVerticalAlign = null);
                    var d = a(t);
                    __DEV__ && c && l.assert(h === c.parent, "Changing parent is not supported."), e && "merge" !== e ? "replace" === e ? (r(c, o), n(i, h, d, o)) : "remove" === e && r(c, o) : c ? c.attr(d) : n(i, h, d, o), o[i] && (o[i].__ecGraphicWidth = t.width, o[i].__ecGraphicHeight = t.height)
                })
            }
        },
        _relocate: function(t, e) {
            for (var i = t.option.elements, n = this.group, r = this._elMap, a = i.length - 1; a >= 0; a--) {
                var o = i[a],
                    s = r[o.id];
                if (s) {
                    var l = s.parent,
                        c = l === n ? {
                            width: e.getWidth(),
                            height: e.getHeight()
                        } : {
                            width: l.__ecGraphicWidth || 0,
                            height: l.__ecGraphicHeight || 0
                        };
                    h.positionElement(s, o, c, null, {
                        hv: o.hv,
                        boundingMode: o.bounding
                    })
                }
            }
        },
        _clear: function() {
            var t = this._elMap;
            l.each(t, function(e) {
                r(e, t)
            }), this._elMap = {}
        },
        dispose: function() {
            this._clear()
        }
    })
}, function(t, e, i) {
    i(782), i(783), i(784);
    var n = i(506);
    n.registerProcessor(i(786))
}, function(t, e, i) {
    "use strict";
    var n = i(509),
        r = i(517),
        a = i(506).extendComponentModel({
            type: "legend",
            dependencies: ["series"],
            layoutMode: {
                type: "box",
                ignoreSize: !0
            },
            init: function(t, e, i) {
                this.mergeDefaultAndTheme(t, i), t.selected = t.selected || {}
            },
            mergeOption: function(t) {
                a.superCall(this, "mergeOption", t)
            },
            optionUpdated: function() {
                this._updateData(this.ecModel);
                var t = this._data;
                if (t[0] && "single" === this.get("selectedMode")) {
                    for (var e = !1, i = 0; i < t.length; i++) {
                        var n = t[i].get("name");
                        if (this.isSelected(n)) {
                            this.select(n), e = !0;
                            break
                        }
                    }
                    !e && this.select(t[0].get("name"))
                }
            },
            _updateData: function(t) {
                var e = n.map(this.get("data") || [], function(t) {
                    return "string" != typeof t && "number" != typeof t || (t = {
                        name: t
                    }), new r(t, this, this.ecModel)
                }, this);
                this._data = e;
                var i = n.map(t.getSeries(), function(t) {
                    return t.name
                });
                t.eachSeries(function(t) {
                    if (t.legendDataProvider) {
                        var e = t.legendDataProvider();
                        i = i.concat(e.mapArray(e.getName))
                    }
                }), this._availableNames = i
            },
            getData: function() {
                return this._data
            },
            select: function(t) {
                var e = this.option.selected,
                    i = this.get("selectedMode");
                if ("single" === i) {
                    var r = this._data;
                    n.each(r, function(t) {
                        e[t.get("name")] = !1
                    })
                }
                e[t] = !0
            },
            unSelect: function(t) {
                "single" !== this.get("selectedMode") && (this.option.selected[t] = !1)
            },
            toggleSelected: function(t) {
                var e = this.option.selected;
                e.hasOwnProperty(t) || (e[t] = !0), this[e[t] ? "unSelect" : "select"](t)
            },
            isSelected: function(t) {
                var e = this.option.selected;
                return !(e.hasOwnProperty(t) && !e[t]) && n.indexOf(this._availableNames, t) >= 0
            },
            defaultOption: {
                zlevel: 0,
                z: 4,
                show: !0,
                orient: "horizontal",
                left: "center",
                top: "top",
                align: "auto",
                backgroundColor: "rgba(0,0,0,0)",
                borderColor: "#ccc",
                borderWidth: 0,
                padding: 5,
                itemGap: 10,
                itemWidth: 25,
                itemHeight: 14,
                inactiveColor: "#ccc",
                textStyle: {
                    color: "#333"
                },
                selectedMode: !0,
                tooltip: {
                    show: !1
                }
            }
        });
    t.exports = a
}, function(t, e, i) {
    function n(t, e, i) {
        var n,
            r = {},
            o = "toggleSelected" === t;
        return i.eachComponent("legend", function(i) {
            o && null != n ? i[n ? "select" : "unSelect"](e.name) : (i[t](e.name), n = i.isSelected(e.name));
            var s = i.getData();
            a.each(s, function(t) {
                var e = t.get("name");
                if ("\n" !== e && "" !== e) {
                    var n = i.isSelected(e);
                    e in r ? r[e] = r[e] && n : r[e] = n
                }
            })
        }), {
            name: e.name,
            selected: r
        }
    }
    var r = i(506),
        a = i(509);
    r.registerAction("legendToggleSelect", "legendselectchanged", a.curry(n, "toggleSelected")), r.registerAction("legendSelect", "legendselected", a.curry(n, "select")), r.registerAction("legendUnSelect", "legendunselected", a.curry(n, "unSelect"))
}, function(t, e, i) {
    function n(t, e) {
        e.dispatchAction({
            type: "legendToggleSelect",
            name: t
        })
    }
    function r(t, e, i) {
        var n = i.getZr().storage.getDisplayList()[0];
        n && n.useHoverLayer || t.get("legendHoverLink") && i.dispatchAction({
            type: "highlight",
            seriesName: t.name,
            name: e
        })
    }
    function a(t, e, i) {
        var n = i.getZr().storage.getDisplayList()[0];
        n && n.useHoverLayer || t.get("legendHoverLink") && i.dispatchAction({
            type: "downplay",
            seriesName: t.name,
            name: e
        })
    }
    var o = i(509),
        s = i(612),
        l = i(548),
        c = i(785),
        u = o.curry;
    t.exports = i(506).extendComponentView({
        type: "legend",
        init: function() {
            this._symbolTypeStore = {}
        },
        render: function(t, e, i) {
            var s = this.group;
            if (s.removeAll(), t.get("show")) {
                var h = t.get("selectedMode"),
                    d = t.get("align");
                "auto" === d && (d = "right" === t.get("left") && "vertical" === t.get("orient") ? "right" : "left");
                var p = {};
                o.each(t.getData(), function(o) {
                    var c = o.get("name");
                    if ("" === c || "\n" === c)
                        return void s.add(new l.Group({
                            newline: !0
                        }));
                    var f = e.getSeriesByName(c)[0];
                    if (!p[c]) {
                        if (f) {
                            var g = f.getData(),
                                m = g.getVisual("color");
                            "function" == typeof m && (m = m(f.getDataParams(0)));
                            var v = g.getVisual("legendSymbol") || "roundRect",
                                y = g.getVisual("symbol"),
                                x = this._createItem(c, o, t, v, y, d, m, h);
                            x.on("click", u(n, c, i)).on("mouseover", u(r, f, null, i)).on("mouseout", u(a, f, null, i)), p[c] = !0
                        } else
                            e.eachRawSeries(function(e) {
                                if (!p[c] && e.legendDataProvider) {
                                    var s = e.legendDataProvider(),
                                        l = s.indexOfName(c);
                                    if (l < 0)
                                        return;
                                    var f = s.getItemVisual(l, "color"),
                                        g = "roundRect",
                                        m = this._createItem(c, o, t, g, null, d, f, h);
                                    m.on("click", u(n, c, i)).on("mouseover", u(r, e, c, i)).on("mouseout", u(a, e, c, i)), p[c] = !0
                                }
                            }, this);
                        __DEV__ && (p[c] || console.warn(c + " series not exists. Legend data should be same with series name or data name."))
                    }
                }, this), c.layout(s, t, i), c.addBackground(s, t)
            }
        },
        _createItem: function(t, e, i, n, r, a, c, u) {
            var h = i.get("itemWidth"),
                d = i.get("itemHeight"),
                p = i.get("inactiveColor"),
                f = i.isSelected(t),
                g = new l.Group,
                m = e.getModel("textStyle"),
                v = e.get("icon"),
                y = e.getModel("tooltip"),
                x = y.parentModel;
            if (n = v || n, g.add(s.createSymbol(n, 0, 0, h, d, f ? c : p)), !v && r && (r !== n || "none" == r)) {
                var _ = .8 * d;
                "none" === r && (r = "circle"), g.add(s.createSymbol(r, (h - _) / 2, (d - _) / 2, _, _, f ? c : p))
            }
            var b = "left" === a ? h + 5 : -5,
                w = a,
                M = i.get("formatter"),
                S = t;
            "string" == typeof M && M ? S = M.replace("{name}", null != t ? t : "") : "function" == typeof M && (S = M(t));
            var A = new l.Text({
                style: {
                    text: S,
                    x: b,
                    y: d / 2,
                    fill: f ? m.getTextColor() : p,
                    textFont: m.getFont(),
                    textAlign: w,
                    textVerticalAlign: "middle"
                }
            });
            g.add(A);
            var I = new l.Rect({
                shape: g.getBoundingRect(),
                invisible: !0,
                tooltip: y.get("show") ? o.extend({
                    content: t,
                    formatter: x.get("formatter", !0) || function() {
                        return t
                    },
                    formatterParams: {
                        componentType: "legend",
                        legendIndex: i.componentIndex,
                        name: t,
                        $vars: ["name"]
                    }
                }, y.option) : null
            });
            return g.add(I), g.eachChild(function(t) {
                t.silent = !0
            }), I.silent = !u, this.group.add(g), l.setHoverStyle(g), g
        }
    })
}, function(t, e, i) {
    function n(t, e, i) {
        r.positionElement(t, e.getBoxLayoutParams(), {
            width: i.getWidth(),
            height: i.getHeight()
        }, e.get("padding"))
    }
    var r = i(526),
        a = i(511),
        o = i(548);
    t.exports = {
        layout: function(t, e, i) {
            var a = r.getLayoutRect(e.getBoxLayoutParams(), {
                width: i.getWidth(),
                height: i.getHeight()
            }, e.get("padding"));
            r.box(e.get("orient"), t, e.get("itemGap"), a.width, a.height), n(t, e, i)
        },
        addBackground: function(t, e) {
            var i = a.normalizeCssArray(e.get("padding")),
                n = t.getBoundingRect(),
                r = e.getItemStyle(["color", "opacity"]);
            r.fill = e.get("backgroundColor");
            var s = new o.Rect({
                shape: {
                    x: n.x - i[3],
                    y: n.y - i[0],
                    width: n.width + i[1] + i[3],
                    height: n.height + i[0] + i[2]
                },
                style: r,
                silent: !0,
                z2: -1
            });
            o.subPixelOptimizeRect(s), t.add(s)
        }
    }
}, function(t, e) {
    t.exports = function(t) {
        var e = t.findComponents({
            mainType: "legend"
        });
        e && e.length && t.filterSeries(function(t) {
            for (var i = 0; i < e.length; i++)
                if (!e[i].isSelected(t.name))
                    return !1;
            return !0
        })
    }
}, function(t, e, i) {
    i(788), i(789), i(506).registerAction({
        type: "showTip",
        event: "showTip",
        update: "none"
    }, function() {}), i(506).registerAction({
        type: "hideTip",
        event: "hideTip",
        update: "none"
    }, function() {})
}, function(t, e, i) {
    i(506).extendComponentModel({
        type: "tooltip",
        defaultOption: {
            zlevel: 0,
            z: 8,
            show: !0,
            showContent: !0,
            trigger: "item",
            triggerOn: "mousemove",
            alwaysShowContent: !1,
            confine: !1,
            showDelay: 0,
            hideDelay: 100,
            transitionDuration: .4,
            enterable: !1,
            backgroundColor: "rgba(50,50,50,0.7)",
            borderColor: "#333",
            borderRadius: 4,
            borderWidth: 0,
            padding: 5,
            extraCssText: "",
            axisPointer: {
                type: "line",
                axis: "auto",
                animation: !0,
                animationDurationUpdate: 200,
                animationEasingUpdate: "exponentialOut",
                lineStyle: {
                    color: "#555",
                    width: 1,
                    type: "solid"
                },
                crossStyle: {
                    color: "#555",
                    width: 1,
                    type: "dashed",
                    textStyle: {}
                },
                shadowStyle: {
                    color: "rgba(150,150,150,0.3)"
                }
            },
            textStyle: {
                color: "#fff",
                fontSize: 14
            }
        }
    })
}, function(t, e, i) {
    function n(t, e) {
        if (!t || !e)
            return !1;
        var i = m.round;
        return i(t[0]) === i(e[0]) && i(t[1]) === i(e[1])
    }
    function r(t, e, i, n) {
        return {
            x1: t,
            y1: e,
            x2: i,
            y2: n
        }
    }
    function a(t, e, i, n) {
        return {
            x: t,
            y: e,
            width: i,
            height: n
        }
    }
    function o(t, e, i, n, r, a) {
        return {
            cx: t,
            cy: e,
            r0: i,
            r: n,
            startAngle: r,
            endAngle: a,
            clockwise: !0
        }
    }
    function s(t, e, i, n, r) {
        var a = i.clientWidth,
            o = i.clientHeight,
            s = 20;
        return t + a + s > n ? t -= a + s : t += s, e + o + s > r ? e -= o + s : e += s, [t, e]
    }
    function l(t, e, i, n, r) {
        var a = i.clientWidth,
            o = i.clientHeight;
        return t = Math.min(t + a, n) - a, e = Math.min(e + o, r) - o, t = Math.max(t, 0), e = Math.max(e, 0), [t, e]
    }
    function c(t, e, i) {
        var n = i.clientWidth,
            r = i.clientHeight,
            a = 5,
            o = 0,
            s = 0,
            l = e.width,
            c = e.height;
        switch (t) {
        case "inside":
            o = e.x + l / 2 - n / 2, s = e.y + c / 2 - r / 2;
            break;
        case "top":
            o = e.x + l / 2 - n / 2, s = e.y - r - a;
            break;
        case "bottom":
            o = e.x + l / 2 - n / 2, s = e.y + c + a;
            break;
        case "left":
            o = e.x - n - a, s = e.y + c / 2 - r / 2;
            break;
        case "right":
            o = e.x + l + a, s = e.y + c / 2 - r / 2
        }
        return [o, s]
    }
    function u(t, e, i, n, r, a, o, u) {
        var h = u.getWidth(),
            d = u.getHeight(),
            p = o && o.getBoundingRect().clone();
        if (o && p.applyTransform(o.transform), "function" == typeof t && (t = t([e, i], a, r.el, p)), f.isArray(t))
            e = y(t[0], h), i = y(t[1], d);
        else if ("string" == typeof t && o) {
            var g = c(t, p, r.el);
            e = g[0], i = g[1]
        } else {
            var g = s(e, i, r.el, h, d);
            e = g[0], i = g[1]
        }
        if (n) {
            var g = l(e, i, r.el, h, d);
            e = g[0], i = g[1]
        }
        r.moveTo(e, i)
    }
    function h(t) {
        var e = t.coordinateSystem,
            i = t.get("tooltip.trigger", !0);
        return !(!e || "cartesian2d" !== e.type && "polar" !== e.type && "singleAxis" !== e.type || "item" === i)
    }
    var d = i(790),
        p = i(548),
        f = i(509),
        g = i(511),
        m = i(512),
        v = i(510),
        y = m.parsePercent,
        x = i(507),
        _ = i(517);
    i(506).extendComponentView({
        type: "tooltip",
        _axisPointers: {},
        init: function(t, e) {
            if (!x.node) {
                var i = new d(e.getDom(), e);
                this._tooltipContent = i, e.on("showTip", this._manuallyShowTip, this), e.on("hideTip", this._manuallyHideTip, this)
            }
        },
        render: function(t, e, i) {
            if (!x.node) {
                this.group.removeAll(), this._axisPointers = {}, this._tooltipModel = t, this._ecModel = e, this._api = i, this._lastHover = {};
                var n = this._tooltipContent;
                n.update(), n.enterable = t.get("enterable"), this._alwaysShowContent = t.get("alwaysShowContent"), this._seriesGroupByAxis = this._prepareAxisTriggerData(t, e);
                var r = this._crossText;
                r && this.group.add(r);
                var a = t.get("triggerOn");
                if (null != this._lastX && null != this._lastY && "none" !== a) {
                    var o = this;
                    clearTimeout(this._refreshUpdateTimeout), this._refreshUpdateTimeout = setTimeout(function() {
                        o._manuallyShowTip({
                            x: o._lastX,
                            y: o._lastY
                        })
                    })
                }
                var s = this._api.getZr();
                s.off("click", this._tryShow), s.off("mousemove", this._mousemove), s.off("mouseout", this._hide), s.off("globalout", this._hide), "click" === a ? s.on("click", this._tryShow, this) : "mousemove" === a && (s.on("mousemove", this._mousemove, this), s.on("mouseout", this._hide, this), s.on("globalout", this._hide, this))
            }
        },
        _mousemove: function(t) {
            var e = this._tooltipModel.get("showDelay"),
                i = this;
            clearTimeout(this._showTimeout), e > 0 ? this._showTimeout = setTimeout(function() {
                i._tryShow(t)
            }, e) : this._tryShow(t)
        },
        _manuallyShowTip: function(t) {
            function e(e) {
                var i = e.getData(),
                    n = v.queryDataIndex(i, t);
                if (null != n && !f.isArray(n) && i.hasValue(n))
                    return !0
            }
            if (t.from !== this.uid) {
                var i = this._ecModel,
                    n = t.seriesIndex,
                    r = i.getSeriesByIndex(n),
                    a = this._api,
                    o = "axis" === this._tooltipModel.get("trigger");
                if (null == t.x || null == t.y) {
                    if (o ? (r && !e(r) && (r = null), r || i.eachSeries(function(t) {
                        h(t) && !r && e(t) && (r = t)
                    })) : r = r || i.getSeriesByIndex(0), r) {
                        var s = r.getData(),
                            l = v.queryDataIndex(s, t);
                        if (null == l || f.isArray(l))
                            return;
                        var c,
                            u,
                            d = s.getItemGraphicEl(l),
                            p = r.coordinateSystem;
                        if (r.getTooltipPosition) {
                            var g = r.getTooltipPosition(l) || [];
                            c = g[0], u = g[1]
                        } else if (p && p.dataToPoint) {
                            var g = p.dataToPoint(s.getValues(f.map(p.dimensions, function(t) {
                                return r.coordDimToDataDim(t)[0]
                            }), l, !0));
                            c = g && g[0], u = g && g[1]
                        } else if (d) {
                            var m = d.getBoundingRect().clone();
                            m.applyTransform(d.transform), c = m.x + m.width / 2, u = m.y + m.height / 2
                        }
                        null != c && null != u && this._tryShow({
                            offsetX: c,
                            offsetY: u,
                            position: t.position,
                            target: d,
                            event: {}
                        })
                    }
                } else {
                    var d = a.getZr().handler.findHover(t.x, t.y);
                    this._tryShow({
                        offsetX: t.x,
                        offsetY: t.y,
                        position: t.position,
                        target: d,
                        event: {}
                    })
                }
            }
        },
        _manuallyHideTip: function(t) {
            t.from !== this.uid && this._hide()
        },
        _prepareAxisTriggerData: function(t, e) {
            var i = {};
            return e.eachSeries(function(t) {
                if (h(t)) {
                    var e,
                        n,
                        r = t.coordinateSystem;
                    "cartesian2d" === r.type ? (e = r.getBaseAxis(), n = e.dim + e.index) : "singleAxis" === r.type ? (e = r.getAxis(), n = e.dim + e.type) : (e = r.getBaseAxis(), n = e.dim + r.name), i[n] = i[n] || {
                        coordSys: [],
                        series: []
                    }, i[n].coordSys.push(r), i[n].series.push(t)
                }
            }, this), i
        },
        _tryShow: function(t) {
            var e = t.target,
                i = this._tooltipModel,
                n = i.get("trigger"),
                r = this._ecModel,
                a = this._api;
            if (i)
                if (this._lastX = t.offsetX, this._lastY = t.offsetY, e && null != e.dataIndex) {
                    var o = e.dataModel || r.getSeriesByIndex(e.seriesIndex),
                        s = e.dataIndex,
                        l = o.getData().getItemModel(s);
                    "axis" === (l.get("tooltip.trigger") || n) ? this._showAxisTooltip(i, r, t) : (this._ticket = "", this._hideAxisPointer(), this._resetLastHover(), this._showItemTooltipContent(o, s, e.dataType, t)), a.dispatchAction({
                        type: "showTip",
                        from: this.uid,
                        dataIndexInside: e.dataIndex,
                        seriesIndex: e.seriesIndex
                    })
                } else if (e && e.tooltip) {
                    var c = e.tooltip;
                    if ("string" == typeof c) {
                        var u = c;
                        c = {
                            content: u,
                            formatter: u
                        }
                    }
                    var h = new _(c, i),
                        d = h.get("content"),
                        p = Math.random();
                    this._showTooltipContent(h, d, h.get("formatterParams") || {}, p, t.offsetX, t.offsetY, t.position, e, a)
                } else
                    "item" === n ? this._hide() : this._showAxisTooltip(i, r, t), "cross" === i.get("axisPointer.type") && a.dispatchAction({
                        type: "showTip",
                        from: this.uid,
                        x: t.offsetX,
                        y: t.offsetY
                    })
        },
        _showAxisTooltip: function(t, e, i) {
            var r = t.getModel("axisPointer"),
                a = r.get("type");
            if ("cross" === a) {
                var o = i.target;
                if (o && null != o.dataIndex) {
                    var s = e.getSeriesByIndex(o.seriesIndex),
                        l = o.dataIndex;
                    this._showItemTooltipContent(s, l, o.dataType, i)
                }
            }
            this._showAxisPointer();
            var c = !0;
            f.each(this._seriesGroupByAxis, function(e) {
                var o = e.coordSys,
                    s = o[0],
                    l = [i.offsetX, i.offsetY];
                if (!s.containPoint(l))
                    return void this._hideAxisPointer(s.name);
                c = !1;
                var u = s.dimensions,
                    h = s.pointToData(l, !0);
                l = s.dataToPoint(h);
                var d = s.getBaseAxis(),
                    p = r.get("axis");
                "auto" === p && (p = d.dim);
                var g = !1,
                    m = this._lastHover;
                if ("cross" === a)
                    n(m.data, h) && (g = !0), m.data = h;
                else {
                    var v = f.indexOf(u, p);
                    m.data === h[v] && (g = !0), m.data = h[v]
                }
                var y = t.get("animation");
                "cartesian2d" !== s.type || g ? "polar" !== s.type || g ? "singleAxis" !== s.type || g || this._showSinglePointer(r, s, p, l, y) : this._showPolarPointer(r, s, p, l, y) : this._showCartesianPointer(r, s, p, l, y), "cross" !== a && this._dispatchAndShowSeriesTooltipContent(s, e.series, l, h, g, i.position)
            }, this), this._tooltipModel.get("show") || this._hideAxisPointer(), c && this._hide()
        },
        _showCartesianPointer: function(t, e, i, n, o) {
            function s(i, n, a) {
                var o = "x" === i ? r(n[0], a[0], n[0], a[1]) : r(a[0], n[1], a[1], n[1]),
                    s = c._getPointerElement(e, t, i, o);
                p.subPixelOptimizeLine({
                    shape: o,
                    style: s.style
                }), d ? p.updateProps(s, {
                    shape: o
                }, t) : s.attr({
                    shape: o
                })
            }
            function l(i, n, r) {
                var o = e.getAxis(i),
                    s = o.getBandWidth(),
                    l = r[1] - r[0],
                    u = "x" === i ? a(n[0] - s / 2, r[0], s, l) : a(r[0], n[1] - s / 2, l, s),
                    h = c._getPointerElement(e, t, i, u);
                d ? p.updateProps(h, {
                    shape: u
                }, t) : h.attr({
                    shape: u
                })
            }
            var c = this,
                u = t.get("type"),
                h = e.getBaseAxis(),
                d = o && "cross" !== u && "category" === h.type && h.getBandWidth() > 20;
            if ("cross" === u)
                s("x", n, e.getAxis("y").getGlobalExtent()), s("y", n, e.getAxis("x").getGlobalExtent()), this._updateCrossText(e, n, t);
            else {
                var f = e.getAxis("x" === i ? "y" : "x"),
                    g = f.getGlobalExtent();
                "cartesian2d" === e.type && ("line" === u ? s : l)(i, n, g)
            }
        },
        _showSinglePointer: function(t, e, i, n, a) {
            function o(i, n, a) {
                var o = e.getAxis(),
                    l = o.orient,
                    u = "horizontal" === l ? r(n[0], a[0], n[0], a[1]) : r(a[0], n[1], a[1], n[1]),
                    h = s._getPointerElement(e, t, i, u);
                c ? p.updateProps(h, {
                    shape: u
                }, t) : h.attr({
                    shape: u
                })
            }
            var s = this,
                l = t.get("type"),
                c = a && "cross" !== l && "category" === e.getBaseAxis().type,
                u = e.getRect(),
                h = [u.y, u.y + u.height];
            o(i, n, h)
        },
        _showPolarPointer: function(t, e, i, n, a) {
            function s(i, n, a) {
                var o,
                    s = e.pointToCoord(n);
                if ("angle" === i) {
                    var l = e.coordToPoint([a[0], s[1]]),
                        u = e.coordToPoint([a[1], s[1]]);
                    o = r(l[0], l[1], u[0], u[1])
                } else
                    o = {
                        cx: e.cx,
                        cy: e.cy,
                        r: s[0]
                    };
                var h = c._getPointerElement(e, t, i, o);
                f ? p.updateProps(h, {
                    shape: o
                }, t) : h.attr({
                    shape: o
                })
            }
            function l(i, n, r) {
                var a,
                    s = e.getAxis(i),
                    l = s.getBandWidth(),
                    u = e.pointToCoord(n),
                    h = Math.PI / 180;
                a = "angle" === i ? o(e.cx, e.cy, r[0], r[1], (-u[1] - l / 2) * h, (-u[1] + l / 2) * h) : o(e.cx, e.cy, u[0] - l / 2, u[0] + l / 2, 0, 2 * Math.PI);
                var d = c._getPointerElement(e, t, i, a);
                f ? p.updateProps(d, {
                    shape: a
                }, t) : d.attr({
                    shape: a
                })
            }
            var c = this,
                u = t.get("type"),
                h = e.getAngleAxis(),
                d = e.getRadiusAxis(),
                f = a && "cross" !== u && "category" === e.getBaseAxis().type;
            if ("cross" === u)
                s("angle", n, d.getExtent()), s("radius", n, h.getExtent()), this._updateCrossText(e, n, t);
            else {
                var g = e.getAxis("radius" === i ? "angle" : "radius"),
                    m = g.getExtent();
                ("line" === u ? s : l)(i, n, m)
            }
        },
        _updateCrossText: function(t, e, i) {
            var n = i.getModel("crossStyle"),
                r = n.getModel("textStyle"),
                a = this._tooltipModel,
                o = this._crossText;
            o || (o = this._crossText = new p.Text({
                style: {
                    textAlign: "left",
                    textVerticalAlign: "bottom"
                }
            }), this.group.add(o));
            var s = t.pointToData(e),
                l = t.dimensions;
            s = f.map(s, function(e, i) {
                var n = t.getAxis(l[i]);
                return e = "category" === n.type || "time" === n.type ? n.scale.getLabel(e) : g.addCommas(e.toFixed(n.getPixelPrecision()))
            }), o.setStyle({
                fill: r.getTextColor() || n.get("color"),
                textFont: r.getFont(),
                text: s.join(", "),
                x: e[0] + 5,
                y: e[1] - 5
            }), o.z = a.get("z"), o.zlevel = a.get("zlevel")
        },
        _getPointerElement: function(t, e, i, n) {
            var r = this._tooltipModel,
                a = r.get("z"),
                o = r.get("zlevel"),
                s = this._axisPointers,
                l = t.name;
            if (s[l] = s[l] || {}, s[l][i])
                return s[l][i];
            var c = e.get("type"),
                u = e.getModel(c + "Style"),
                h = "shadow" === c,
                d = u[h ? "getAreaStyle" : "getLineStyle"](),
                f = "polar" === t.type ? h ? "Sector" : "radius" === i ? "Circle" : "Line" : h ? "Rect" : "Line";
            h ? d.stroke = null : d.fill = null;
            var g = s[l][i] = new p[f]({
                style: d,
                z: a,
                zlevel: o,
                silent: !0,
                shape: n
            });
            return this.group.add(g), g
        },
        _dispatchAndShowSeriesTooltipContent: function(t, e, i, n, r, a) {
            var o,
                s = this._tooltipModel,
                l = t.getBaseAxis(),
                c = "x" === l.dim || "radius" === l.dim ? 0 : 1,
                h = f.map(e, function(t) {
                    return {
                        seriesIndex: t.seriesIndex,
                        dataIndexInside: t.getAxisTooltipDataIndex ? t.getAxisTooltipDataIndex(t.coordDimToDataDim(l.dim), n, l) : t.getData().indexOfNearest(t.coordDimToDataDim(l.dim)[0], n[c], !1, "category" === l.type ? .5 : null)
                    }
                });
            f.each(h, function(t, i) {
                e[i].getData().hasValue(t.dataIndexInside) && (o = i)
            }), o = o || 0;
            var d = this._lastHover,
                p = this._api;
            if (d.payloadBatch && !r && p.dispatchAction({
                type: "downplay",
                batch: d.payloadBatch
            }), r || (p.dispatchAction({
                type: "highlight",
                batch: h
            }), d.payloadBatch = h), p.dispatchAction({
                type: "showTip",
                dataIndexInside: h[o].dataIndexInside,
                seriesIndex: h[o].seriesIndex,
                from: this.uid
            }), l && s.get("showContent") && s.get("show")) {
                var g = f.map(e, function(t, e) {
                    return t.getDataParams(h[e].dataIndexInside)
                });
                if (r)
                    u(a || s.get("position"), i[0], i[1], s.get("confine"), this._tooltipContent, g, null, p);
                else {
                    var m = h[o].dataIndexInside,
                        v = "time" === l.type ? l.scale.getLabel(n[c]) : e[o].getData().getName(m),
                        y = (v ? v + "<br />" : "") + f.map(e, function(t, e) {
                            return t.formatTooltip(h[e].dataIndexInside, !0)
                        }).join("<br />"),
                        x = "axis_" + t.name + "_" + m;
                    this._showTooltipContent(s, y, g, x, i[0], i[1], a, null, p)
                }
            }
        },
        _showItemTooltipContent: function(t, e, i, n) {
            var r = this._api,
                a = t.getData(i),
                o = a.getItemModel(e),
                s = o.get("tooltip", !0);
            if ("string" == typeof s) {
                var l = s;
                s = {
                    formatter: l
                }
            }
            var c = this._tooltipModel,
                u = t.getModel("tooltip", c),
                h = new _(s, u, u.ecModel),
                d = t.getDataParams(e, i),
                p = t.formatTooltip(e, !1, i),
                f = "item_" + t.name + "_" + e;
            this._showTooltipContent(h, p, d, f, n.offsetX, n.offsetY, n.position, n.target, r)
        },
        _showTooltipContent: function(t, e, i, n, r, a, o, s, l) {
            if (this._ticket = "", t.get("showContent") && t.get("show")) {
                var c = this._tooltipContent,
                    h = t.get("confine"),
                    d = t.get("formatter");
                o = o || t.get("position");
                var p = e;
                if (d)
                    if ("string" == typeof d)
                        p = g.formatTpl(d, i);
                    else if ("function" == typeof d) {
                        var f = this,
                            m = n,
                            v = function(t, e) {
                                t === f._ticket && (c.setContent(e), u(o, r, a, h, c, i, s, l))
                            };
                        f._ticket = m, p = d(i, m, v)
                    }
                c.show(t), c.setContent(p), u(o, r, a, h, c, i, s, l)
            }
        },
        _showAxisPointer: function(t) {
            if (t) {
                var e = this._axisPointers[t];
                e && f.each(e, function(t) {
                    t.show()
                })
            } else
                this.group.eachChild(function(t) {
                    t.show()
                }), this.group.show()
        },
        _resetLastHover: function() {
            var t = this._lastHover;
            t.payloadBatch && this._api.dispatchAction({
                type: "downplay",
                batch: t.payloadBatch
            }), this._lastHover = {}
        },
        _hideAxisPointer: function(t) {
            if (t) {
                var e = this._axisPointers[t];
                e && f.each(e, function(t) {
                    t.hide()
                })
            } else
                this.group.children().length && this.group.hide()
        },
        _hide: function() {
            clearTimeout(this._showTimeout), this._hideAxisPointer(), this._resetLastHover(), this._alwaysShowContent || this._tooltipContent.hideLater(this._tooltipModel.get("hideDelay")), this._api.dispatchAction({
                type: "hideTip",
                from: this.uid
            }), this._lastX = this._lastY = null
        },
        dispose: function(t, e) {
            if (!x.node) {
                var i = e.getZr();
                this._tooltipContent.hide(), i.off("click", this._tryShow), i.off("mousemove", this._mousemove), i.off("mouseout", this._hide), i.off("globalout", this._hide), e.off("showTip", this._manuallyShowTip), e.off("hideTip", this._manuallyHideTip)
            }
        }
    })
}, function(t, e, i) {
    function n(t) {
        var e = "cubic-bezier(0.23, 1, 0.32, 1)",
            i = "left " + t + "s " + e + ",top " + t + "s " + e;
        return s.map(f, function(t) {
            return t + "transition:" + i
        }).join(";")
    }
    function r(t) {
        var e = [],
            i = t.get("fontSize"),
            n = t.getTextColor();
        return n && e.push("color:" + n), e.push("font:" + t.getFont()), i && e.push("line-height:" + Math.round(3 * i / 2) + "px"), h(["decoration", "align"], function(i) {
            var n = t.get(i);
            n && e.push("text-" + i + ":" + n)
        }), e.join(";")
    }
    function a(t) {
        t = t;
        var e = [],
            i = t.get("transitionDuration"),
            a = t.get("backgroundColor"),
            o = t.getModel("textStyle"),
            s = t.get("padding");
        return i && e.push(n(i)), a && (p.canvasSupported ? e.push("background-Color:" + a) : (e.push("background-Color:#" + l.toHex(a)), e.push("filter:alpha(opacity=70)"))), h(["width", "color", "radius"], function(i) {
            var n = "border-" + i,
                r = d(n),
                a = t.get(r);
            null != a && e.push(n + ":" + a + ("color" === i ? "" : "px"))
        }), e.push(r(o)), null != s && e.push("padding:" + u.normalizeCssArray(s).join("px ") + "px"), e.join(";") + ";"
    }
    function o(t, e) {
        var i = document.createElement("div"),
            n = e.getZr();
        this.el = i, this._x = e.getWidth() / 2, this._y = e.getHeight() / 2, t.appendChild(i), this._container = t, this._show = !1, this._hideTimeout;
        var r = this;
        i.onmouseenter = function() {
            r.enterable && (clearTimeout(r._hideTimeout), r._show = !0), r._inContent = !0
        }, i.onmousemove = function(e) {
            if (e = e || window.event, !r.enterable) {
                var i = n.handler;
                c.normalizeEvent(t, e, !0), i.dispatch("mousemove", e)
            }
        }, i.onmouseleave = function() {
            r.enterable && r._show && r.hideLater(r._hideDelay), r._inContent = !1
        }
    }
    var s = i(509),
        l = i(544),
        c = i(593),
        u = i(511),
        h = s.each,
        d = u.toCamelCase,
        p = i(507),
        f = ["", "-webkit-", "-moz-", "-o-"],
        g = "position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:9999999;";
    o.prototype = {
        constructor: o,
        enterable: !0,
        update: function() {
            var t = this._container,
                e = t.currentStyle || document.defaultView.getComputedStyle(t),
                i = t.style;
            "absolute" !== i.position && "absolute" !== e.position && (i.position = "relative")
        },
        show: function(t) {
            clearTimeout(this._hideTimeout);
            var e = this.el;
            e.style.cssText = g + a(t) + ";left:" + this._x + "px;top:" + this._y + "px;" + (t.get("extraCssText") || ""), e.style.display = e.innerHTML ? "block" : "none", this._show = !0
        },
        setContent: function(t) {
            var e = this.el;
            e.innerHTML = t, e.style.display = t ? "block" : "none"
        },
        moveTo: function(t, e) {
            var i = this.el.style;
            i.left = t + "px", i.top = e + "px", this._x = t, this._y = e
        },
        hide: function() {
            this.el.style.display = "none", this._show = !1
        },
        hideLater: function(t) {
            !this._show || this._inContent && this.enterable || (t ? (this._hideDelay = t, this._show = !1, this._hideTimeout = setTimeout(s.bind(this.hide, this), t)) : this.hide())
        },
        isShow: function() {
            return this._show
        }
    }, t.exports = o
}, function(t, e, i) {
    "use strict";
    i(792), i(798), i(800), i(506).extendComponentView({
        type: "polar"
    })
}, function(t, e, i) {
    function n(t, e) {
        var i = t.get("center"),
            n = t.get("radius"),
            r = e.getWidth(),
            a = e.getHeight(),
            o = s.parsePercent;
        this.cx = o(i[0], r), this.cy = o(i[1], a);
        var l = this.getRadiusAxis(),
            c = Math.min(r, a) / 2;
        l.setExtent(0, o(n, c))
    }
    function r(t, e) {
        var i = this,
            n = i.getAngleAxis(),
            r = i.getRadiusAxis();
        if (n.scale.setExtent(1 / 0, -(1 / 0)), r.scale.setExtent(1 / 0, -(1 / 0)), t.eachSeries(function(t) {
            if (t.coordinateSystem === i) {
                var e = t.getData();
                r.scale.unionExtent(e.getDataExtent("radius", "category" !== r.type)), n.scale.unionExtent(e.getDataExtent("angle", "category" !== n.type))
            }
        }), u(n, n.model), u(r, r.model), "category" === n.type && !n.onBand) {
            var a = n.getExtent(),
                o = 360 / n.scale.count();
            n.inverse ? a[1] += o : a[1] -= o, n.setExtent(a[0], a[1])
        }
    }
    function a(t, e) {
        if (t.type = e.get("type"), t.scale = c.createScaleByModel(e), t.onBand = e.get("boundaryGap") && "category" === t.type, "angleAxis" === e.mainType) {
            var i = e.get("startAngle");
            t.inverse = e.get("inverse") ^ e.get("clockwise"), t.setExtent(i, i + (t.inverse ? -360 : 360))
        }
        e.axis = t, t.model = e
    }
    var o = i(793),
        s = i(512),
        l = i(509),
        c = i(620),
        u = c.niceScaleExtent;
    i(796);
    var h = {
        dimensions: o.prototype.dimensions,
        create: function(t, e) {
            var i = [];
            return t.eachComponent("polar", function(t, s) {
                var l = new o(s);
                l.resize = n, l.update = r;
                var c = l.getRadiusAxis(),
                    u = l.getAngleAxis(),
                    h = t.findAxisModel("radiusAxis"),
                    d = t.findAxisModel("angleAxis");
                a(c, h), a(u, d), l.resize(t, e), i.push(l), t.coordinateSystem = l
            }), t.eachSeries(function(e) {
                if ("polar" === e.get("coordinateSystem")) {
                    var i = t.queryComponents({
                        mainType: "polar",
                        index: e.get("polarIndex"),
                        id: e.get("polarId")
                    })[0];
                    if (__DEV__ && !i)
                        throw new Error('Polar "' + l.retrieve(e.get("polarIndex"), e.get("polarId"), 0) + '" not found');
                    e.coordinateSystem = i.coordinateSystem
                }
            }), i
        }
    };
    i(531).register("polar", h)
}, function(t, e, i) {
    "use strict";
    var n = i(794),
        r = i(795),
        a = function(t) {
            this.name = t || "", this.cx = 0, this.cy = 0, this._radiusAxis = new n, this._angleAxis = new r
        };
    a.prototype = {
        constructor: a,
        type: "polar",
        dimensions: ["radius", "angle"],
        containPoint: function(t) {
            var e = this.pointToCoord(t);
            return this._radiusAxis.contain(e[0]) && this._angleAxis.contain(e[1])
        },
        containData: function(t) {
            return this._radiusAxis.containData(t[0]) && this._angleAxis.containData(t[1])
        },
        getAxis: function(t) {
            return this["_" + t + "Axis"]
        },
        getAxesByScale: function(t) {
            var e = [],
                i = this._angleAxis,
                n = this._radiusAxis;
            return i.scale.type === t && e.push(i), n.scale.type === t && e.push(n), e
        },
        getAngleAxis: function() {
            return this._angleAxis
        },
        getRadiusAxis: function() {
            return this._radiusAxis
        },
        getOtherAxis: function(t) {
            var e = this._angleAxis;
            return t === e ? this._radiusAxis : e
        },
        getBaseAxis: function() {
            return this.getAxesByScale("ordinal")[0] || this.getAxesByScale("time")[0] || this.getAngleAxis()
        },
        dataToPoints: function(t) {
            return t.mapArray(this.dimensions, function(t, e) {
                return this.dataToPoint([t, e])
            }, this)
        },
        dataToPoint: function(t, e) {
            return this.coordToPoint([this._radiusAxis.dataToRadius(t[0], e), this._angleAxis.dataToAngle(t[1], e)])
        },
        pointToData: function(t, e) {
            var i = this.pointToCoord(t);
            return [this._radiusAxis.radiusToData(i[0], e), this._angleAxis.angleToData(i[1], e)]
        },
        pointToCoord: function(t) {
            var e = t[0] - this.cx,
                i = t[1] - this.cy,
                n = this.getAngleAxis(),
                r = n.getExtent(),
                a = Math.min(r[0], r[1]),
                o = Math.max(r[0], r[1]);
            n.inverse ? a = o - 360 : o = a + 360;
            var s = Math.sqrt(e * e + i * i);
            e /= s, i /= s;
            for (var l = Math.atan2(-i, e) / Math.PI * 180, c = l < a ? 1 : -1; l < a || l > o;)
                l += 360 * c;
            return [s, l]
        },
        coordToPoint: function(t) {
            var e = t[0],
                i = t[1] / 180 * Math.PI,
                n = Math.cos(i) * e + this.cx,
                r = -Math.sin(i) * e + this.cy;
            return [n, r]
        }
    }, t.exports = a
}, function(t, e, i) {
    "use strict";
    function n(t, e) {
        a.call(this, "radius", t, e), this.type = "category"
    }
    var r = i(509),
        a = i(629);
    n.prototype = {
        constructor: n,
        dataToRadius: a.prototype.dataToCoord,
        radiusToData: a.prototype.coordToData
    }, r.inherits(n, a), t.exports = n
}, function(t, e, i) {
    "use strict";
    function n(t, e) {
        e = e || [0, 360], a.call(this, "angle", t, e), this.type = "category"
    }
    var r = i(509),
        a = i(629);
    n.prototype = {
        constructor: n,
        dataToAngle: a.prototype.dataToCoord,
        angleToData: a.prototype.coordToData
    }, r.inherits(n, a), t.exports = n
}, function(t, e, i) {
    "use strict";
    i(797), i(506).extendComponentModel({
        type: "polar",
        dependencies: ["polarAxis", "angleAxis"],
        coordinateSystem: null,
        findAxisModel: function(t) {
            var e,
                i = this.ecModel;
            return i.eachComponent(t, function(t) {
                var n = i.queryComponents({
                    mainType: "polar",
                    index: t.getShallow("polarIndex"),
                    id: t.getShallow("polarId")
                })[0];
                n === this && (e = t)
            }, this), e
        },
        defaultOption: {
            zlevel: 0,
            z: 0,
            center: ["50%", "50%"],
            radius: "80%"
        }
    })
}, function(t, e, i) {
    "use strict";
    function n(t, e) {
        return e.type || (e.data ? "category" : "value")
    }
    var r = i(509),
        a = i(524),
        o = i(633),
        s = a.extend({
            type: "polarAxis",
            axis: null
        });
    r.merge(s.prototype, i(635)), r.merge(s.prototype, i(636));
    var l = {
        angle: {
            startAngle: 90,
            clockwise: !0,
            splitNumber: 12,
            axisLabel: {
                rotate: !1
            }
        },
        radius: {
            splitNumber: 5
        }
    };
    o("angle", s, n, l.angle), o("radius", s, n, l.radius)
}, function(t, e, i) {
    "use strict";
    i(792), i(799)
}, function(t, e, i) {
    "use strict";
    function n(t, e, i, n) {
        var r = t.coordToPoint([e, n]),
            a = t.coordToPoint([i, n]);
        return {
            x1: r[0],
            y1: r[1],
            x2: a[0],
            y2: a[1]
        }
    }
    var r = i(509),
        a = i(548),
        o = i(517),
        s = ["axisLine", "axisLabel", "axisTick", "splitLine", "splitArea"];
    i(506).extendComponentView({
        type: "angleAxis",
        render: function(t, e) {
            if (this.group.removeAll(), t.get("show")) {
                var i = e.getComponent("polar", t.get("polarIndex")),
                    n = t.axis,
                    a = i.coordinateSystem,
                    o = a.getRadiusAxis().getExtent(),
                    l = n.getTicksCoords();
                "category" !== n.type && l.pop(), r.each(s, function(e) {
                    t.get(e + ".show") && this["_" + e](t, a, l, o)
                }, this)
            }
        },
        _axisLine: function(t, e, i, n) {
            var r = t.getModel("axisLine.lineStyle"),
                o = new a.Circle({
                    shape: {
                        cx: e.cx,
                        cy: e.cy,
                        r: n[1]
                    },
                    style: r.getLineStyle(),
                    z2: 1,
                    silent: !0
                });
            o.style.fill = null, this.group.add(o)
        },
        _axisTick: function(t, e, i, o) {
            var s = t.getModel("axisTick"),
                l = (s.get("inside") ? -1 : 1) * s.get("length"),
                c = r.map(i, function(t) {
                    return new a.Line({
                        shape: n(e, o[1], o[1] + l, t)
                    })
                });
            this.group.add(a.mergePath(c, {
                style: r.defaults(s.getModel("lineStyle").getLineStyle(), {
                    stroke: t.get("axisLine.lineStyle.color")
                })
            }))
        },
        _axisLabel: function(t, e, i, n) {
            for (var r = t.axis, s = t.get("data"), l = t.getModel("axisLabel"), c = l.getModel("textStyle"), u = t.getFormattedLabels(), h = l.get("margin"), d = r.getLabelsCoords(), p = 0; p < i.length; p++) {
                var f = n[1],
                    g = e.coordToPoint([f + h, d[p]]),
                    m = e.cx,
                    v = e.cy,
                    y = Math.abs(g[0] - m) / f < .3 ? "center" : g[0] > m ? "left" : "right",
                    x = Math.abs(g[1] - v) / f < .3 ? "middle" : g[1] > v ? "top" : "bottom",
                    _ = c;
                s && s[p] && s[p].textStyle && (_ = new o(s[p].textStyle, c)), this.group.add(new a.Text({
                    style: {
                        x: g[0],
                        y: g[1],
                        fill: _.getTextColor() || t.get("axisLine.lineStyle.color"),
                        text: u[p],
                        textAlign: y,
                        textVerticalAlign: x,
                        textFont: _.getFont()
                    },
                    silent: !0
                }))
            }
        },
        _splitLine: function(t, e, i, o) {
            var s = t.getModel("splitLine"),
                l = s.getModel("lineStyle"),
                c = l.get("color"),
                u = 0;
            c = c instanceof Array ? c : [c];
            for (var h = [], d = 0; d < i.length; d++) {
                var p = u++ % c.length;
                h[p] = h[p] || [], h[p].push(new a.Line({
                    shape: n(e, o[0], o[1], i[d])
                }))
            }
            for (var d = 0; d < h.length; d++)
                this.group.add(a.mergePath(h[d], {
                    style: r.defaults({
                        stroke: c[d % c.length]
                    }, l.getLineStyle()),
                    silent: !0,
                    z: t.get("z")
                }))
        },
        _splitArea: function(t, e, i, n) {
            var o = t.getModel("splitArea"),
                s = o.getModel("areaStyle"),
                l = s.get("color"),
                c = 0;
            l = l instanceof Array ? l : [l];
            for (var u = [], h = Math.PI / 180, d = -i[0] * h, p = Math.min(n[0], n[1]), f = Math.max(n[0], n[1]), g = t.get("clockwise"), m = 1; m < i.length; m++) {
                var v = c++ % l.length;
                u[v] = u[v] || [], u[v].push(new a.Sector({
                    shape: {
                        cx: e.cx,
                        cy: e.cy,
                        r0: p,
                        r: f,
                        startAngle: d,
                        endAngle: -i[m] * h,
                        clockwise: g
                    },
                    silent: !0
                })), d = -i[m] * h
            }
            for (var m = 0; m < u.length; m++)
                this.group.add(a.mergePath(u[m], {
                    style: r.defaults({
                        fill: l[m % l.length]
                    }, s.getAreaStyle()),
                    silent: !0
                }))
        }
    })
}, function(t, e, i) {
    i(792), i(801)
}, function(t, e, i) {
    "use strict";
    function n(t, e, i) {
        return {
            position: [t.cx, t.cy],
            rotation: i / 180 * Math.PI,
            labelDirection: -1,
            tickDirection: -1,
            nameDirection: 1,
            labelRotation: e.getModel("axisLabel").get("rotate"),
            z2: 1
        }
    }
    var r = i(509),
        a = i(548),
        o = i(639),
        s = ["axisLine", "axisLabel", "axisTick", "axisName"],
        l = ["splitLine", "splitArea"];
    i(506).extendComponentView({
        type: "radiusAxis",
        render: function(t, e) {
            if (this.group.removeAll(), t.get("show")) {
                var i = e.getComponent("polar", t.get("polarIndex")),
                    a = i.coordinateSystem.getAngleAxis(),
                    c = t.axis,
                    u = i.coordinateSystem,
                    h = c.getTicksCoords(),
                    d = a.getExtent()[0],
                    p = c.getExtent(),
                    f = n(u, t, d),
                    g = new o(t, f);
                r.each(s, g.add, g), this.group.add(g.getGroup()), r.each(l, function(e) {
                    t.get(e + ".show") && this["_" + e](t, u, d, p, h)
                }, this)
            }
        },
        _splitLine: function(t, e, i, n, o) {
            var s = t.getModel("splitLine"),
                l = s.getModel("lineStyle"),
                c = l.get("color"),
                u = 0;
            c = c instanceof Array ? c : [c];
            for (var h = [], d = 0; d < o.length; d++) {
                var p = u++ % c.length;
                h[p] = h[p] || [], h[p].push(new a.Circle({
                    shape: {
                        cx: e.cx,
                        cy: e.cy,
                        r: o[d]
                    },
                    silent: !0
                }))
            }
            for (var d = 0; d < h.length; d++)
                this.group.add(a.mergePath(h[d], {
                    style: r.defaults({
                        stroke: c[d % c.length],
                        fill: null
                    }, l.getLineStyle()),
                    silent: !0
                }))
        },
        _splitArea: function(t, e, i, n, o) {
            var s = t.getModel("splitArea"),
                l = s.getModel("areaStyle"),
                c = l.get("color"),
                u = 0;
            c = c instanceof Array ? c : [c];
            for (var h = [], d = o[0], p = 1; p < o.length; p++) {
                var f = u++ % c.length;
                h[f] = h[f] || [], h[f].push(new a.Sector({
                    shape: {
                        cx: e.cx,
                        cy: e.cy,
                        r0: d,
                        r: o[p],
                        startAngle: 0,
                        endAngle: 2 * Math.PI
                    },
                    silent: !0
                })), d = o[p]
            }
            for (var p = 0; p < h.length; p++)
                this.group.add(a.mergePath(h[p], {
                    style: r.defaults({
                        fill: c[p % c.length]
                    }, l.getAreaStyle()),
                    silent: !0
                }))
        }
    })
}, function(t, e, i) {
    function n(t, e) {
        e.update = "updateView", r.registerAction(e, function(e, i) {
            var n = {};
            return i.eachComponent({
                mainType: "geo",
                query: e
            }, function(i) {
                i[t](e.name);
                var r = i.coordinateSystem;
                a.each(r.regions, function(t) {
                    n[t.name] = i.isSelected(t.name) || !1
                })
            }), {
                selected: n,
                name: e.name
            }
        })
    }
    i(803), i(670), i(804), i(683);
    var r = i(506),
        a = i(509);
    n("toggleSelected", {
        type: "geoToggleSelect",
        event: "geoselectchanged"
    }), n("select", {
        type: "geoSelect",
        event: "geoselected"
    }), n("unSelect", {
        type: "geoUnSelect",
        event: "geounselected"
    })
}, function(t, e, i) {
    "use strict";
    var n = i(510),
        r = i(524),
        a = i(517),
        o = i(509),
        s = i(647),
        l = i(670),
        c = r.extend({
            type: "geo",
            coordinateSystem: null,
            layoutMode: "box",
            init: function(t) {
                r.prototype.init.apply(this, arguments), n.defaultEmphasis(t.label, ["position", "show", "textStyle", "distance", "formatter"])
            },
            optionUpdated: function() {
                var t = this.option,
                    e = this;
                t.regions = l.getFilledRegions(t.regions, t.map), this._optionModelMap = o.reduce(t.regions || [], function(t, i) {
                    return i.name && (t[i.name] = new a(i, e)), t
                }, {}), this.updateSelectedMap(t.regions)
            },
            defaultOption: {
                zlevel: 0,
                z: 0,
                show: !0,
                left: "center",
                top: "center",
                aspectScale: .75,
                silent: !1,
                map: "",
                center: null,
                zoom: 1,
                scaleLimit: null,
                label: {
                    normal: {
                        show: !1,
                        textStyle: {
                            color: "#000"
                        }
                    },
                    emphasis: {
                        show: !0,
                        textStyle: {
                            color: "rgb(100,0,0)"
                        }
                    }
                },
                itemStyle: {
                    normal: {
                        borderWidth: .5,
                        borderColor: "#444",
                        color: "#eee"
                    },
                    emphasis: {
                        color: "rgba(255,215,0,0.8)"
                    }
                },
                regions: []
            },
            getRegionModel: function(t) {
                return this._optionModelMap[t]
            },
            getFormattedLabel: function(t, e) {
                var i = this.get("label." + e + ".formatter"),
                    n = {
                        name: t
                    };
                if ("function" == typeof i)
                    return n.status = e, i(n);
                if ("string" == typeof i) {
                    var r = n.seriesName;
                    return i.replace("{a}", null != r ? r : "")
                }
            },
            setZoom: function(t) {
                this.option.zoom = t
            },
            setCenter: function(t) {
                this.option.center = t
            }
        });
    o.mixin(c, s), t.exports = c
}, function(t, e, i) {
    "use strict";
    var n = i(680);
    t.exports = i(506).extendComponentView({
        type: "geo",
        init: function(t, e) {
            var i = new n(e, !0);
            this._mapDraw = i, this.group.add(i.group)
        },
        render: function(t, e, i, n) {
            if (!n || "geoToggleSelect" !== n.type || n.from !== this.uid) {
                var r = this._mapDraw;
                t.get("show") ? r.draw(t, e, i, this, n) : this._mapDraw.group.removeAll(), this.group.silent = t.get("silent")
            }
        },
        dispose: function() {
            this._mapDraw && this._mapDraw.remove()
        }
    })
}, function(t, e, i) {
    i(806), i(809), i(810);
    var n = i(506);
    n.extendComponentView({
        type: "single"
    })
}, function(t, e, i) {
    function n(t, e) {
        var i = [];
        return t.eachComponent("singleAxis", function(n, a) {
            var o = new r(n, t, e);
            o.name = "single_" + a, o.resize(n, e), n.coordinateSystem = o, i.push(o)
        }), t.eachSeries(function(e) {
            if ("singleAxis" === e.get("coordinateSystem")) {
                var i = t.queryComponents({
                    mainType: "singleAxis",
                    index: e.get("singleAxisIndex"),
                    id: e.get("singleAxisId")
                })[0];
                e.coordinateSystem = i.coordinateSystem
            }
        }), i
    }
    var r = i(807);
    i(531).register("single", {
        create: n,
        dimensions: r.prototype.dimensions
    })
}, function(t, e, i) {
    function n(t, e, i) {
        this.dimension = "x", this.dimensions = ["x"], this._axis = null, this._rect, this._init(t, e, i), this._model = t
    }
    var r = i(808),
        a = i(620),
        o = i(526);
    n.prototype = {
        type: "singleAxis",
        constructor: n,
        _init: function(t, e, i) {
            var n = this.dimension,
                o = new r(n, a.createScaleByModel(t), [0, 0], t.get("type"), t.get("position")),
                s = "category" === o.type;
            o.onBand = s && t.get("boundaryGap"), o.inverse = t.get("inverse"), o.orient = t.get("orient"), t.axis = o, o.model = t, this._axis = o
        },
        update: function(t, e) {
            this._updateAxisFromSeries(t)
        },
        _updateAxisFromSeries: function(t) {
            t.eachSeries(function(t) {
                var e = t.getData(),
                    i = this.dimension;
                this._axis.scale.unionExtent(e.getDataExtent(t.coordDimToDataDim(i))), a.niceScaleExtent(this._axis, this._axis.model)
            }, this)
        },
        resize: function(t, e) {
            this._rect = o.getLayoutRect({
                left: t.get("left"),
                top: t.get("top"),
                right: t.get("right"),
                bottom: t.get("bottom"),
                width: t.get("width"),
                height: t.get("height")
            }, {
                width: e.getWidth(),
                height: e.getHeight()
            }), this._adjustAxis()
        },
        getRect: function() {
            return this._rect
        },
        _adjustAxis: function() {
            var t = this._rect,
                e = this._axis,
                i = e.isHorizontal(),
                n = i ? [0, t.width] : [0, t.height],
                r = e.reverse ? 1 : 0;
            e.setExtent(n[r], n[1 - r]), this._updateAxisTransform(e, i ? t.x : t.y)
        },
        _updateAxisTransform: function(t, e) {
            var i = t.getExtent(),
                n = i[0] + i[1],
                r = t.isHorizontal();
            t.toGlobalCoord = r ? function(t) {
                return t + e
            } : function(t) {
                return n - t + e
            }, t.toLocalCoord = r ? function(t) {
                return t - e
            } : function(t) {
                return n - t + e
            }
        },
        getAxis: function() {
            return this._axis
        },
        getBaseAxis: function() {
            return this._axis
        },
        containPoint: function(t) {
            var e = this.getRect(),
                i = this.getAxis(),
                n = i.orient;
            return "horizontal" === n ? i.contain(i.toLocalCoord(t[0])) && t[1] >= e.y && t[1] <= e.y + e.height : i.contain(i.toLocalCoord(t[1])) && t[0] >= e.y && t[0] <= e.y + e.height
        },
        pointToData: function(t) {
            var e = this.getAxis();
            return [e.coordToData(e.toLocalCoord(t["horizontal" === e.orient ? 0 : 1]))]
        },
        dataToPoint: function(t) {
            var e = this.getAxis(),
                i = this.getRect(),
                n = [],
                r = "horizontal" === e.orient ? 0 : 1;
            return n[r] = e.toGlobalCoord(e.dataToCoord(+t)), n[1 - r] = 0 === r ? i.y + i.height / 2 : i.x + i.width / 2, n
        }
    }, t.exports = n
}, function(t, e, i) {
    var n = i(509),
        r = i(629),
        a = i(620),
        o = function(t, e, i, n, a) {
            r.call(this, t, e, i), this.type = n || "value", this.position = a || "bottom", this.orient = null, this._labelInterval = null
        };
    o.prototype = {
        constructor: o,
        model: null,
        isHorizontal: function() {
            var t = this.position;
            return "top" === t || "bottom" === t
        },
        getLabelInterval: function() {
            var t = this._labelInterval;
            if (!t) {
                var e = this.model,
                    i = e.getModel("axisLabel"),
                    r = i.get("interval");
                if ("category" !== this.type || "auto" !== r)
                    return t = this._labelInterval = "auto" === r ? 0 : r;
                t = this._labelInterval = a.getAxisLabelInterval(n.map(this.scale.getTicks(), this.dataToCoord, this), e.getFormattedLabels(), i.getModel("textStyle").getFont(), this.isHorizontal())
            }
            return t
        },
        toGlobalCoord: null,
        toLocalCoord: null
    }, n.inherits(o, r), t.exports = o
}, function(t, e, i) {
    function n(t) {
        var e = t.coordinateSystem,
            i = t.axis,
            n = {},
            r = i.position,
            a = i.orient,
            o = e.getRect(),
            s = [o.x, o.x + o.width, o.y, o.y + o.height],
            l = {
                horizontal: {
                    top: s[2],
                    bottom: s[3]
                },
                vertical: {
                    left: s[0],
                    right: s[1]
                }
            };
        n.position = ["vertical" === a ? l.vertical[r] : s[0], "horizontal" === a ? l.horizontal[r] : s[3]];
        var c = {
            horizontal: 0,
            vertical: 1
        };
        n.rotation = Math.PI / 2 * c[a];
        var u = {
            top: -1,
            bottom: 1,
            right: 1,
            left: -1
        };
        n.labelDirection = n.tickDirection = n.nameDirection = u[r], t.getModel("axisTick").get("inside") && (n.tickDirection = -n.tickDirection), t.getModel("axisLabel").get("inside") && (n.labelDirection = -n.labelDirection);
        var h = t.getModel("axisLabel").get("rotate");
        return n.labelRotation = "top" === r ? -h : h, n.labelInterval = i.getLabelInterval(), n.z2 = 1, n
    }
    var r = i(639),
        a = i(509),
        o = i(548),
        s = r.getInterval,
        l = r.ifIgnoreOnTick,
        c = ["axisLine", "axisLabel", "axisTick", "axisName"],
        u = "splitLine",
        h = i(506).extendComponentView({
            type: "singleAxis",
            render: function(t, e) {
                var i = this.group;
                i.removeAll();
                var o = n(t),
                    s = new r(t, o);
                a.each(c, s.add, s), i.add(s.getGroup()), t.get(u + ".show") && this["_" + u](t, o.labelInterval)
            },
            _splitLine: function(t, e) {
                var i = t.axis,
                    n = t.getModel("splitLine"),
                    r = n.getModel("lineStyle"),
                    a = r.get("width"),
                    c = r.get("color"),
                    u = s(n, e);
                c = c instanceof Array ? c : [c];
                for (var h = t.coordinateSystem.getRect(), d = i.isHorizontal(), p = [], f = 0, g = i.getTicksCoords(), m = [], v = [], y = 0; y < g.length; ++y)
                    if (!l(i, y, u)) {
                        var x = i.toGlobalCoord(g[y]);
                        d ? (m[0] = x, m[1] = h.y, v[0] = x, v[1] = h.y + h.height) : (m[0] = h.x, m[1] = x, v[0] = h.x + h.width, v[1] = x);
                        var _ = f++ % c.length;
                        p[_] = p[_] || [], p[_].push(new o.Line(o.subPixelOptimizeLine({
                            shape: {
                                x1: m[0],
                                y1: m[1],
                                x2: v[0],
                                y2: v[1]
                            },
                            style: {
                                lineWidth: a
                            },
                            silent: !0
                        })))
                    }
                for (var y = 0; y < p.length; ++y)
                    this.group.add(o.mergePath(p[y], {
                        style: {
                            stroke: c[y % c.length],
                            lineDash: r.getLineDash(a),
                            lineWidth: a
                        },
                        silent: !0
                    }))
            }
        });
    t.exports = h
}, function(t, e, i) {
    function n(t, e) {
        return e.type || (e.data ? "category" : "value")
    }
    var r = i(524),
        a = i(633),
        o = i(509),
        s = r.extend({
            type: "singleAxis",
            layoutMode: "box",
            axis: null,
            coordinateSystem: null
        }),
        l = {
            left: "5%",
            top: "5%",
            right: "5%",
            bottom: "5%",
            type: "value",
            position: "bottom",
            orient: "horizontal",
            axisLine: {
                show: !0,
                lineStyle: {
                    width: 2,
                    type: "solid"
                }
            },
            axisTick: {
                show: !0,
                length: 6,
                lineStyle: {
                    width: 2
                }
            },
            axisLabel: {
                show: !0,
                interval: "auto"
            },
            splitLine: {
                show: !0,
                lineStyle: {
                    type: "dashed",
                    opacity: .2
                }
            }
        };
    o.merge(s.prototype, i(635)), a("single", s, n, l), t.exports = s
}, function(t, e, i) {
    i(506).registerPreprocessor(i(812)), i(813), i(817), i(818), i(819), i(820)
}, function(t, e, i) {
    function n(t) {
        var e = {};
        r.each(t, function(t) {
            e[t] = 1
        }), t.length = 0, r.each(e, function(e, i) {
            t.push(i)
        })
    }
    var r = i(509),
        a = ["rect", "polygon", "keep", "clear"];
    t.exports = function(t, e) {
        var i = t && t.brush;
        if (r.isArray(i) || (i = i ? [i] : []), i.length) {
            var o = [];
            r.each(i, function(t) {
                var e = t.hasOwnProperty("toolbox") ? t.toolbox : [];
                e instanceof Array && (o = o.concat(e))
            });
            var s = t && t.toolbox;
            r.isArray(s) && (s = s[0]), s || (s = {
                feature: {}
            }, t.toolbox = [s]);
            var l = s.feature || (s.feature = {}),
                c = l.brush || (l.brush = {}),
                u = c.type || (c.type = []);
            u.push.apply(u, o), n(u), e && !u.length && u.push.apply(u, a)
        }
    }
}, function(t, e, i) {
    function n(t, e, i, n, a) {
        if (a) {
            var o = t.getZr();
            if (!o[x]) {
                o[y] || (o[y] = r);
                var s = g.createOrUpdate(o, y, i, e);
                s(t, n)
            }
        }
    }
    function r(t, e) {
        if (!t.isDisposed()) {
            var i = t.getZr();
            i[x] = !0, t.dispatchAction({
                type: "brushSelect",
                batch: e
            }), i[x] = !1
        }
    }
    function a(t, e, i, n) {
        for (var r = i.getItemLayout(n), a = 0, o = e.length; a < o; a++) {
            var s = e[a];
            if (t[s.brushType](r, s.selectors, s))
                return !0
        }
    }
    function o(t) {
        var e = t.brushSelector;
        if (d.isString(e)) {
            var i = [];
            return d.each(f, function(t, n) {
                i[n] = t[e]
            }), i
        }
        if (d.isFunction(e)) {
            var n = {};
            return d.each(f, function(t, i) {
                n[i] = e
            }), n
        }
        return e
    }
    function s(t, e) {
        var i = t.option.seriesIndex;
        return null != i && "all" !== i && (d.isArray(i) ? d.indexOf(i, e) < 0 : e !== i)
    }
    function l(t) {
        var e = t.selectors = {};
        return d.each(f[t.brushType], function(i, n) {
            e[n] = function(n) {
                return i(n, e, t)
            }
        }), t
    }
    function c(t) {
        return new p(t[0][0], t[1][0], t[0][1] - t[0][0], t[1][1] - t[1][0])
    }
    var u = i(506),
        h = i(814),
        d = i(509),
        p = i(514),
        f = i(815),
        g = i(586),
        m = i(816),
        v = ["inBrush", "outOfBrush"],
        y = "__ecBrushSelect",
        x = "__ecInBrushSelectEvent",
        _ = u.PRIORITY.VISUAL.BRUSH;
    u.registerLayout(_, function(t, e, i) {
        t.eachComponent({
            mainType: "brush"
        }, function(e) {
            i && "takeGlobalCursor" === i.type && e.setBrushOption("brush" === i.key ? i.brushOption : {
                brushType: !1
            }), e.coordInfoList = m.makeCoordInfoList(e.option, t), m.parseInputRanges(e, t)
        })
    }), u.registerVisual(_, function(t, e, i) {
        var r,
            c,
            u = [];
        t.eachComponent({
            mainType: "brush"
        }, function(e, i) {
            function n(t) {
                return "all" === _ || w[t]
            }
            function p(t) {
                return !!t.length
            }
            function f(t, e) {
                var i = t.coordinateSystem;
                A |= i.hasAxisbrushed(), n(e) && i.eachActiveState(t.getData(), function(t, e) {
                    "active" === t && (M[e] = 1)
                })
            }
            function g(t, i, r) {
                var l = o(t);
                if (l && !s(e, i) && (d.each(I, function(i) {
                    l[i.brushType] && m.controlSeries(i, e, t) && r.push(i), A |= p(r)
                }), n(i) && p(r))) {
                    var c = t.getData();
                    c.each(function(t) {
                        a(l, r, c, t) && (M[t] = 1)
                    })
                }
            }
            var y = {
                brushId: e.id,
                brushIndex: i,
                brushName: e.name,
                areas: d.clone(e.areas),
                selected: []
            };
            u.push(y);
            var x = e.option,
                _ = x.brushLink,
                w = [],
                M = [],
                S = [],
                A = 0;
            i || (r = x.throttleType, c = x.throttleDelay);
            var I = d.map(e.areas, function(t) {
                    return l(d.defaults({
                        boundingRect: b[t.brushType](t)
                    }, t))
                }),
                D = h.createVisualMappings(e.option, v, function(t) {
                    t.mappingMethod = "fixed"
                });
            d.isArray(_) && d.each(_, function(t) {
                w[t] = 1
            }), t.eachSeries(function(t, e) {
                var i = S[e] = [];
                "parallel" === t.subType ? f(t, e, i) : g(t, e, i)
            }), t.eachSeries(function(t, e) {
                var i = {
                    seriesId: t.id,
                    seriesIndex: e,
                    seriesName: t.name,
                    dataIndex: []
                };
                y.selected.push(i);
                var r = o(t),
                    s = S[e],
                    l = t.getData(),
                    c = n(e) ? function(t) {
                        return M[t] ? (i.dataIndex.push(l.getRawIndex(t)), "inBrush") : "outOfBrush"
                    } : function(t) {
                        return a(r, s, l, t) ? (i.dataIndex.push(l.getRawIndex(t)), "inBrush") : "outOfBrush"
                    };
                (n(e) ? A : p(s)) && h.applyVisual(v, D, l, c)
            })
        }), n(e, r, c, u, i)
    });
    var b = {
        lineX: d.noop,
        lineY: d.noop,
        rect: function(t) {
            return c(t.range)
        },
        polygon: function(t) {
            for (var e, i = t.range, n = 0, r = i.length; n < r; n++) {
                e = e || [[1 / 0, -(1 / 0)], [1 / 0, -(1 / 0)]];
                var a = i[n];
                a[0] < e[0][0] && (e[0][0] = a[0]), a[0] > e[0][1] && (e[0][1] = a[0]), a[1] < e[1][0] && (e[1][0] = a[1]), a[1] > e[1][1] && (e[1][1] = a[1])
            }
            return e && c(e)
        }
    }
}, function(t, e, i) {
    function n(t) {
        if (t)
            for (var e in t)
                if (t.hasOwnProperty(e))
                    return !0
    }
    var r = i(509),
        a = i(699),
        o = r.each,
        s = {
            createVisualMappings: function(t, e, i) {
                function n() {
                    var t = function() {};
                    t.prototype.__hidden = t.prototype;
                    var e = new t;
                    return e
                }
                var s = {};
                return o(e, function(e) {
                    var l = s[e] = n();
                    o(t[e], function(t, n) {
                        if (a.isValidType(n)) {
                            var o = {
                                type: n,
                                visual: t
                            };
                            i && i(o, e), l[n] = new a(o), "opacity" === n && (o = r.clone(o), o.type = "colorAlpha", l.__hidden.__alphaForOpacity = new a(o))
                        }
                    })
                }), s
            },
            replaceVisualOption: function(t, e, i) {
                var a;
                r.each(i, function(t) {
                    e.hasOwnProperty(t) && n(e[t]) && (a = !0)
                }), a && r.each(i, function(i) {
                    e.hasOwnProperty(i) && n(e[i]) ? t[i] = r.clone(e[i]) : delete t[i]
                })
            },
            applyVisual: function(t, e, i, n, o, s) {
                function l(t) {
                    return i.getItemVisual(d, t)
                }
                function c(t, e) {
                    i.setItemVisual(d, t, e)
                }
                function u(t, i) {
                    d = null == s ? t : i;
                    for (var r = n.call(o, t), a = e[r], u = h[r], p = 0, f = u.length; p < f; p++) {
                        var g = u[p];
                        a[g] && a[g].applyVisual(t, l, c)
                    }
                }
                var h = {};
                r.each(t, function(t) {
                    var i = a.prepareVisualTypes(e[t]);
                    h[t] = i
                });
                var d;
                null == s ? i.each(u, !0) : i.each([s], u, !0)
            }
        };
    t.exports = s
}, function(t, e, i) {
    function n(t) {
        var e = ["x", "y"],
            i = ["width", "height"];
        return {
            point: function(e, i, n) {
                var a = n.range,
                    o = e[t];
                return r(o, a)
            },
            rect: function(n, a, o) {
                var s = o.range;
                return r(n[e[t]], s) || r(n[e[t]] + n[i[t]], s)
            }
        }
    }
    function r(t, e) {
        return e[0] <= t && t <= e[1]
    }
    function a(t, e, i, n, r) {
        for (var a = 0, s = r[r.length - 1]; a < r.length; a++) {
            var l = r[a];
            if (o(t, e, i, n, l[0], l[1], s[0], s[1]))
                return !0;
            s = l
        }
    }
    function o(t, e, i, n, r, a, o, c) {
        var u = l(i - t, r - o, n - e, a - c);
        if (s(u))
            return !1;
        var h = l(r - t, r - o, a - e, a - c) / u;
        if (h < 0 || h > 1)
            return !1;
        var d = l(i - t, r - t, n - e, a - e) / u;
        return !(d < 0 || d > 1)
    }
    function s(t) {
        return t <= 1e-6 && t >= -1e-6
    }
    function l(t, e, i, n) {
        return t * n - e * i
    }
    var c = i(674).contain,
        u = i(514),
        h = {
            lineX: n(0),
            lineY: n(1),
            rect: {
                point: function(t, e, i) {
                    return i.boundingRect.contain(t[0], t[1])
                },
                rect: function(t, e, i) {
                    return i.boundingRect.intersect(t)
                }
            },
            polygon: {
                point: function(t, e, i) {
                    return i.boundingRect.contain(t[0], t[1]) && c(i.range, t[0], t[1])
                },
                rect: function(t, e, i) {
                    var n = i.range;
                    if (n.length <= 1)
                        return !1;
                    var r = t.x,
                        o = t.y,
                        s = t.width,
                        l = t.height,
                        h = n[0];
                    return !!(c(n, r, o) || c(n, r + s, o) || c(n, r, o + l) || c(n, r + s, o + l) || u.create(t).contain(h[0], h[1]) || a(r, o, r + s, o, n) || a(r, o, r, o + l, n) || a(r + s, o, r + s, o + l, n) || a(r, o + l, r + s, o + l, n)) || void 0
                }
            }
        };
    t.exports = h
}, function(t, e, i) {
    function n(t) {
        return t[0] > t[1] && t.reverse(),
        t
    }
    function r(t, e) {
        for (var i = !0, n = 0; n < u.length; n++) {
            var r = u[n] + "Index";
            if (t[r] >= 0) {
                i = !1;
                for (var a = 0; a < e.length; a++)
                    if (e[a][r] === t[r])
                        return e[a]
            }
        }
        return i
    }
    function a(t, e, i, r) {
        var a = i.coordSys.getAxis(t);
        return __DEV__ && o.assert(a, "line brush is only available in cartesian (grid)."), n(o.map([0, 1], function(t) {
            return e ? a.coordToData(a.toLocalCoord(r[t])) : a.toGlobalCoord(a.dataToCoord(r[t]))
        }))
    }
    var o = i(509),
        s = i(548),
        l = o.each,
        c = {},
        u = ["geo", "xAxis", "yAxis"],
        h = "--",
        d = ["dataToPoint", "pointToData"];
    c.parseOutputRanges = function(t, e, i, n) {
        l(t, function(t, i) {
            var a = t.panelId;
            if (a) {
                a = a.split(h), t[a[0] + "Index"] = +a[1];
                var o = r(t, e);
                t.coordRange = p[t.brushType](1, o, t.range), n && (n[i] = o)
            }
        })
    }, c.parseInputRanges = function(t, e) {
        l(t.areas, function(e) {
            var i = r(e, t.coordInfoList);
            __DEV__ && (o.assert(!i || i === !0 || e.coordRange, "coordRange must be specified when coord index specified."), o.assert(!i || i !== !0 || e.range, "range must be specified.")), e.range = e.range || [], i && i !== !0 && (e.range = p[e.brushType](0, i, e.coordRange), e.panelId = i.panelId)
        })
    }, c.makePanelOpts = function(t) {
        var e = [];
        return l(t, function(t) {
            var i,
                n = t.coordSys;
            t.geoIndex >= 0 ? (i = n.getBoundingRect().clone(), i.applyTransform(s.getTransform(n))) : i = n.grid.getRect().clone(), e.push({
                panelId: t.panelId,
                rect: i
            })
        }), e
    }, c.makeCoordInfoList = function(t, e) {
        var i = [];
        return l(u, function(n) {
            var r = t[n + "Index"];
            null != r && "none" !== r && ("all" === r || o.isArray(r) || (r = [r]), e.eachComponent({
                mainType: n
            }, function(t, e) {
                if (!("all" !== r && o.indexOf(r, e) < 0)) {
                    var a,
                        s;
                    "xAxis" === n || "yAxis" === n ? a = t.axis.grid : s = t.coordinateSystem;
                    for (var l, c = 0, u = i.length; c < u; c++) {
                        var d = i[c];
                        if (__DEV__ && o.assert(d[n + "Index"] != e, "Coord should not be defined duplicately: " + n + e), "yAxis" === n && !d.yAxis && d.xAxis) {
                            var p = a.getCartesian(d.xAxisIndex, e);
                            if (p) {
                                s = p, l = d;
                                break
                            }
                        }
                    }
                    !l && i.push(l = {}), l[n] = t, l[n + "Index"] = e, l.panelId = n + h + e, l.coordSys = s || a.getCartesian(l.xAxisIndex, l.yAxisIndex), l.coordSys ? i[n + "Has"] = !0 : i.pop()
                }
            }))
        }), i
    }, c.controlSeries = function(t, e, i) {
        var n = r(t, e.coordInfoList);
        return n === !0 || n && n.coordSys === i.coordinateSystem
    };
    var p = {
        lineX: o.curry(a, "x"),
        lineY: o.curry(a, "y"),
        rect: function(t, e, i) {
            var r = e.coordSys,
                a = r[d[t]]([i[0][0], i[1][0]]),
                o = r[d[t]]([i[0][1], i[1][1]]);
            return [n([a[0], o[0]]), n([a[1], o[1]])]
        },
        polygon: function(t, e, i) {
            var n = e.coordSys;
            return o.map(i, n[d[t]], n)
        }
    };
    t.exports = c
}, function(t, e, i) {
    var n = i(506),
        r = i(509),
        a = i(814),
        o = i(517),
        s = ["#ddd"],
        l = n.extendComponentModel({
            type: "brush",
            dependencies: ["geo", "grid", "xAxis", "yAxis", "parallel", "series"],
            defaultOption: {
                toolbox: null,
                brushLink: null,
                seriesIndex: "all",
                geoIndex: null,
                xAxisIndex: null,
                yAxisIndex: null,
                brushType: "rect",
                brushMode: "single",
                transformable: !0,
                brushStyle: {
                    borderWidth: 1,
                    color: "rgba(120,140,180,0.3)",
                    borderColor: "rgba(120,140,180,0.8)",
                    width: null
                },
                throttleType: "fixRate",
                throttleDelay: 0,
                removeOnClick: !0
            },
            areas: [],
            brushType: null,
            brushOption: {},
            coordInfoList: [],
            optionUpdated: function(t, e) {
                var i = this.option;
                !e && a.replaceVisualOption(i, t, ["inBrush", "outOfBrush"]), i.inBrush = i.inBrush || {}, i.outOfBrush = i.outOfBrush || {
                    color: s
                }
            },
            setAreas: function(t) {
                __DEV__ && (r.assert(r.isArray(t)), r.each(t, function(t) {
                    r.assert(t.brushType, "Illegal areas")
                })), t && (this.areas = r.map(t, function(t) {
                    return this._mergeBrushOption(t)
                }, this))
            },
            setBrushOption: function(t) {
                this.brushOption = this._mergeBrushOption(t), this.brushType = this.brushOption.brushType
            },
            _mergeBrushOption: function(t) {
                var e = this.option;
                return r.merge({
                    brushType: e.brushType,
                    brushMode: e.brushMode,
                    transformable: e.transformable,
                    brushStyle: new o(e.brushStyle).getItemStyle(),
                    removeOnClick: e.removeOnClick
                }, t, !0)
            }
        });
    t.exports = l
}, function(t, e, i) {
    function n(t, e, i, n) {
        (!n || n.$from !== t.id) && this._brushController.setPanels(s.makePanelOpts(t.coordInfoList)).enableBrush(t.brushOption).updateCovers(t.areas.slice())
    }
    var r = i(509),
        a = i(740),
        o = i(506),
        s = i(816);
    t.exports = o.extendComponentView({
        type: "brush",
        init: function(t, e) {
            this.ecModel = t, this.api = e, this.model, (this._brushController = new a(e.getZr())).on("brush", r.bind(this._onBrush, this)).mount()
        },
        render: function(t) {
            return this.model = t, n.apply(this, arguments)
        },
        updateView: n,
        updateLayout: n,
        updateVisual: n,
        dispose: function() {
            this._brushController.dispose()
        },
        _onBrush: function(t, e) {
            var i = this.model.id;
            s.parseOutputRanges(t, this.model.coordInfoList, this.ecModel), (!e.isEnd || e.removeOnClick) && this.api.dispatchAction({
                type: "brush",
                brushId: i,
                areas: r.clone(t),
                $from: i
            })
        }
    })
}, function(t, e, i) {
    var n = i(506);
    n.registerAction({
        type: "brush",
        event: "brush",
        update: "updateView"
    }, function(t, e) {
        e.eachComponent({
            mainType: "brush",
            query: t
        }, function(e) {
            e.setAreas(t.areas)
        })
    }), n.registerAction({
        type: "brushSelect",
        event: "brushSelected",
        update: "none"
    }, function() {})
}, function(t, e, i) {
    "use strict";
    function n(t, e, i) {
        this.model = t, this.ecModel = e, this.api = i, this._brushType, this._brushMode
    }
    var r = i(821),
        a = i(509);
    n.defaultOption = {
        show: !0,
        type: ["rect", "polygon", "lineX", "lineY", "keep", "clear"],
        icon: {
            rect: "M7.3,34.7 M0.4,10V-0.2h9.8 M89.6,10V-0.2h-9.8 M0.4,60v10.2h9.8 M89.6,60v10.2h-9.8 M12.3,22.4V10.5h13.1 M33.6,10.5h7.8 M49.1,10.5h7.8 M77.5,22.4V10.5h-13 M12.3,31.1v8.2 M77.7,31.1v8.2 M12.3,47.6v11.9h13.1 M33.6,59.5h7.6 M49.1,59.5 h7.7 M77.5,47.6v11.9h-13",
            polygon: "M55.2,34.9c1.7,0,3.1,1.4,3.1,3.1s-1.4,3.1-3.1,3.1 s-3.1-1.4-3.1-3.1S53.5,34.9,55.2,34.9z M50.4,51c1.7,0,3.1,1.4,3.1,3.1c0,1.7-1.4,3.1-3.1,3.1c-1.7,0-3.1-1.4-3.1-3.1 C47.3,52.4,48.7,51,50.4,51z M55.6,37.1l1.5-7.8 M60.1,13.5l1.6-8.7l-7.8,4 M59,19l-1,5.3 M24,16.1l6.4,4.9l6.4-3.3 M48.5,11.6 l-5.9,3.1 M19.1,12.8L9.7,5.1l1.1,7.7 M13.4,29.8l1,7.3l6.6,1.6 M11.6,18.4l1,6.1 M32.8,41.9 M26.6,40.4 M27.3,40.2l6.1,1.6 M49.9,52.1l-5.6-7.6l-4.9-1.2",
            lineX: "M15.2,30 M19.7,15.6V1.9H29 M34.8,1.9H40.4 M55.3,15.6V1.9H45.9 M19.7,44.4V58.1H29 M34.8,58.1H40.4 M55.3,44.4 V58.1H45.9 M12.5,20.3l-9.4,9.6l9.6,9.8 M3.1,29.9h16.5 M62.5,20.3l9.4,9.6L62.3,39.7 M71.9,29.9H55.4",
            lineY: "M38.8,7.7 M52.7,12h13.2v9 M65.9,26.6V32 M52.7,46.3h13.2v-9 M24.9,12H11.8v9 M11.8,26.6V32 M24.9,46.3H11.8v-9 M48.2,5.1l-9.3-9l-9.4,9.2 M38.9-3.9V12 M48.2,53.3l-9.3,9l-9.4-9.2 M38.9,62.3V46.4",
            keep: "M4,10.5V1h10.3 M20.7,1h6.1 M33,1h6.1 M55.4,10.5V1H45.2 M4,17.3v6.6 M55.6,17.3v6.6 M4,30.5V40h10.3 M20.7,40 h6.1 M33,40h6.1 M55.4,30.5V40H45.2 M21,18.9h62.9v48.6H21V18.9z",
            clear: "M22,14.7l30.9,31 M52.9,14.7L22,45.7 M4.7,16.8V4.2h13.1 M26,4.2h7.8 M41.6,4.2h7.8 M70.3,16.8V4.2H57.2 M4.7,25.9v8.6 M70.3,25.9v8.6 M4.7,43.2v12.6h13.1 M26,55.8h7.8 M41.6,55.8h7.8 M70.3,43.2v12.6H57.2"
        },
        title: {
            rect: "矩形选择",
            polygon: "圈选",
            lineX: "横向选择",
            lineY: "纵向选择",
            keep: "保持选择",
            clear: "清除选择"
        }
    };
    var o = n.prototype;
    o.render = o.updateView = o.updateLayout = function(t, e, i) {
        var n,
            r,
            o;
        e.eachComponent({
            mainType: "brush"
        }, function(t) {
            n = t.brushType, r = t.brushOption.brushMode || "single", o |= t.areas.length
        }), this._brushType = n, this._brushMode = r, a.each(t.get("type", !0), function(e) {
            t.setIconStatus(e, ("keep" === e ? "multiple" === r : "clear" === e ? o : e === n) ? "emphasis" : "normal")
        })
    }, o.getIcons = function() {
        var t = this.model,
            e = t.get("icon", !0),
            i = {};
        return a.each(t.get("type", !0), function(t) {
            e[t] && (i[t] = e[t])
        }), i
    }, o.onclick = function(t, e, i) {
        var e = this.api,
            n = this._brushType,
            r = this._brushMode;
        "clear" === i ? e.dispatchAction({
            type: "brush",
            areas: []
        }) : e.dispatchAction({
            type: "takeGlobalCursor",
            key: "brush",
            brushOption: {
                brushType: "keep" === i ? n : n !== i && i,
                brushMode: "keep" === i ? "multiple" === r ? "single" : "multiple" : r
            }
        })
    }, r.register("brush", n), t.exports = n
}, function(t, e) {
    "use strict";
    var i = {};
    t.exports = {
        register: function(t, e) {
            i[t] = e
        },
        get: function(t) {
            return i[t]
        }
    }
}, function(t, e, i) {
    "use strict";
    var n = i(506),
        r = i(548),
        a = i(526);
    n.extendComponentModel({
        type: "title",
        layoutMode: {
            type: "box",
            ignoreSize: !0
        },
        defaultOption: {
            zlevel: 0,
            z: 6,
            show: !0,
            text: "",
            target: "blank",
            subtext: "",
            subtarget: "blank",
            left: 0,
            top: 0,
            backgroundColor: "rgba(0,0,0,0)",
            borderColor: "#ccc",
            borderWidth: 0,
            padding: 5,
            itemGap: 10,
            textStyle: {
                fontSize: 18,
                fontWeight: "bolder",
                color: "#333"
            },
            subtextStyle: {
                color: "#aaa"
            }
        }
    }), n.extendComponentView({
        type: "title",
        render: function(t, e, i) {
            if (this.group.removeAll(), t.get("show")) {
                var n = this.group,
                    o = t.getModel("textStyle"),
                    s = t.getModel("subtextStyle"),
                    l = t.get("textAlign"),
                    c = t.get("textBaseline"),
                    u = new r.Text({
                        style: {
                            text: t.get("text"),
                            textFont: o.getFont(),
                            fill: o.getTextColor()
                        },
                        z2: 10
                    }),
                    h = u.getBoundingRect(),
                    d = t.get("subtext"),
                    p = new r.Text({
                        style: {
                            text: d,
                            textFont: s.getFont(),
                            fill: s.getTextColor(),
                            y: h.height + t.get("itemGap"),
                            textBaseline: "top"
                        },
                        z2: 10
                    }),
                    f = t.get("link"),
                    g = t.get("sublink");
                u.silent = !f, p.silent = !g, f && u.on("click", function() {
                    window.open(f, "_" + t.get("target"))
                }), g && p.on("click", function() {
                    window.open(g, "_" + t.get("subtarget"))
                }), n.add(u), d && n.add(p);
                var m = n.getBoundingRect(),
                    v = t.getBoxLayoutParams();
                v.width = m.width, v.height = m.height;
                var y = a.getLayoutRect(v, {
                    width: i.getWidth(),
                    height: i.getHeight()
                }, t.get("padding"));
                l || (l = t.get("left") || t.get("right"), "middle" === l && (l = "center"), "right" === l ? y.x += y.width : "center" === l && (y.x += y.width / 2)), c || (c = t.get("top") || t.get("bottom"), "center" === c && (c = "middle"), "bottom" === c ? y.y += y.height : "middle" === c && (y.y += y.height / 2), c = c || "top"), n.attr("position", [y.x, y.y]);
                var x = {
                    textAlign: l,
                    textVerticalAlign: c
                };
                u.setStyle(x), p.setStyle(x), m = n.getBoundingRect();
                var _ = y.margin,
                    b = t.getItemStyle(["color", "opacity"]);
                b.fill = t.get("backgroundColor");
                var w = new r.Rect({
                    shape: {
                        x: m.x - _[3],
                        y: m.y - _[0],
                        width: m.width + _[1] + _[3],
                        height: m.height + _[0] + _[2]
                    },
                    style: b,
                    silent: !0
                });
                r.subPixelOptimizeRect(w), n.add(w)
            }
        }
    })
}, function(t, e, i) {
    i(824), i(825), i(828), i(829), i(830), i(832), i(833), i(835), i(836)
}, function(t, e, i) {
    i(524).registerSubTypeDefaulter("dataZoom", function(t) {
        return "slider"
    })
}, function(t, e, i) {
    function n(t) {
        var e = {};
        return h(["start", "end", "startValue", "endValue", "throttle"], function(i) {
            t.hasOwnProperty(i) && (e[i] = t[i])
        }), e
    }
    function r(t, e, i, n) {
        null != i[e] && null == i[t] && (n[t] = null)
    }
    var a = i(509),
        o = i(507),
        s = i(506),
        l = i(510),
        c = i(826),
        u = i(827),
        h = a.each,
        d = c.eachAxisDim,
        p = s.extendComponentModel({
            type: "dataZoom",
            dependencies: ["xAxis", "yAxis", "zAxis", "radiusAxis", "angleAxis", "series"],
            defaultOption: {
                zlevel: 0,
                z: 4,
                orient: null,
                xAxisIndex: null,
                yAxisIndex: null,
                filterMode: "filter",
                throttle: null,
                start: 0,
                end: 100,
                startValue: null,
                endValue: null
            },
            init: function(t, e, i) {
                this._dataIntervalByAxis = {}, this._dataInfo = {}, this._axisProxies = {}, this.textStyleModel, this._autoThrottle = !0;
                var r = n(t);
                this.mergeDefaultAndTheme(t, i), this.doInit(r)
            },
            mergeOption: function(t) {
                var e = n(t);
                a.merge(this.option, t, !0), this.doInit(e)
            },
            doInit: function(t) {
                var e = this.option;
                o.canvasSupported || (e.realtime = !1), this._setDefaultThrottle(t), r("start", "startValue", t, e), r("end", "endValue", t, e), this.textStyleModel = this.getModel("textStyle"), this._resetTarget(), this._giveAxisProxies()
            },
            _giveAxisProxies: function() {
                var t = this._axisProxies;
                this.eachTargetAxis(function(e, i, n, r) {
                    var a = this.dependentModels[e.axis][i],
                        o = a.__dzAxisProxy || (a.__dzAxisProxy = new u(e.name, i, this, r));
                    t[e.name + "_" + i] = o
                }, this)
            },
            _resetTarget: function() {
                var t = this.option,
                    e = this._judgeAutoMode();
                d(function(e) {
                    var i = e.axisIndex;
                    t[i] = l.normalizeToArray(t[i])
                }, this), "axisIndex" === e ? this._autoSetAxisIndex() : "orient" === e && this._autoSetOrient()
            },
            _judgeAutoMode: function() {
                var t = this.option,
                    e = !1;
                d(function(i) {
                    null != t[i.axisIndex] && (e = !0)
                }, this);
                var i = t.orient;
                return null == i && e ? "orient" : e ? void 0 : (null == i && (t.orient = "horizontal"), "axisIndex")
            },
            _autoSetAxisIndex: function() {
                var t = !0,
                    e = this.get("orient", !0),
                    i = this.option;
                if (t) {
                    var n = "vertical" === e ? {
                        dim: "y",
                        axisIndex: "yAxisIndex",
                        axis: "yAxis"
                    } : {
                        dim: "x",
                        axisIndex: "xAxisIndex",
                        axis: "xAxis"
                    };
                    this.dependentModels[n.axis].length && (i[n.axisIndex] = [0], t = !1)
                }
                t && d(function(e) {
                    if (t) {
                        var n = [],
                            r = this.dependentModels[e.axis];
                        if (r.length && !n.length)
                            for (var a = 0, o = r.length; a < o; a++)
                                "category" === r[a].get("type") && n.push(a);
                        i[e.axisIndex] = n, n.length && (t = !1)
                    }
                }, this), t && this.ecModel.eachSeries(function(t) {
                    this._isSeriesHasAllAxesTypeOf(t, "value") && d(function(e) {
                        var n = i[e.axisIndex],
                            r = t.get(e.axisIndex),
                            o = t.get(e.axisId),
                            s = t.ecModel.queryComponents({
                                mainType: e.axis,
                                index: r,
                                id: o
                            })[0];
                        if (__DEV__ && !s)
                            throw new Error(e.axis + ' "' + a.retrieve(r, o, 0) + '" not found');
                        r = s.componentIndex, a.indexOf(n, r) < 0 && n.push(r)
                    })
                }, this)
            },
            _autoSetOrient: function() {
                var t;
                this.eachTargetAxis(function(e) {
                    !t && (t = e.name)
                }, this), this.option.orient = "y" === t ? "vertical" : "horizontal"
            },
            _isSeriesHasAllAxesTypeOf: function(t, e) {
                var i = !0;
                return d(function(n) {
                    var r = t.get(n.axisIndex),
                        a = this.dependentModels[n.axis][r];
                    a && a.get("type") === e || (i = !1)
                }, this), i
            },
            _setDefaultThrottle: function(t) {
                if (t.hasOwnProperty("throttle") && (this._autoThrottle = !1), this._autoThrottle) {
                    var e = this.ecModel.option;
                    this.option.throttle = e.animation && e.animationDurationUpdate > 0 ? 100 : 20
                }
            },
            getFirstTargetAxisModel: function() {
                var t;
                return d(function(e) {
                    if (null == t) {
                        var i = this.get(e.axisIndex);
                        i.length && (t = this.dependentModels[e.axis][i[0]])
                    }
                }, this), t
            },
            eachTargetAxis: function(t, e) {
                var i = this.ecModel;
                d(function(n) {
                    h(this.get(n.axisIndex), function(r) {
                        t.call(e, n, r, this, i)
                    }, this)
                }, this)
            },
            getAxisProxy: function(t, e) {
                return this._axisProxies[t + "_" + e]
            },
            setRawRange: function(t) {
                h(["start", "end", "startValue", "endValue"], function(e) {
                    this.option[e] = t[e]
                }, this)
            },
            getPercentRange: function() {
                var t = this.findRepresentativeAxisProxy();
                if (t)
                    return t.getDataPercentWindow()
            },
            getValueRange: function(t, e) {
                if (null != t || null != e)
                    return this.getAxisProxy(t, e).getDataValueWindow();
                var i = this.findRepresentativeAxisProxy();
                return i ? i.getDataValueWindow() : void 0
            },
            findRepresentativeAxisProxy: function() {
                var t = this._axisProxies;
                for (var e in t)
                    if (t.hasOwnProperty(e) && t[e].hostedBy(this))
                        return t[e];
                for (var e in t)
                    if (t.hasOwnProperty(e) && !t[e].hostedBy(this))
                        return t[e]
            }
        });
    t.exports = p
}, function(t, e, i) {
    var n = i(511),
        r = i(509),
        a = {},
        o = ["x", "y", "z", "radius", "angle"];
    a.createNameEach = function(t, e) {
        t = t.slice();
        var i = r.map(t, n.capitalFirst);
        e = (e || []).slice();
        var a = r.map(e, n.capitalFirst);
        return function(n, o) {
            r.each(t, function(t, r) {
                for (var s = {
                        name: t,
                        capital: i[r]
                    }, l = 0; l < e.length; l++)
                    s[e[l]] = t + a[l];
                n.call(o, s)
            })
        }
    }, a.eachAxisDim = a.createNameEach(o, ["axisIndex", "axis", "index", "id"]), a.createLinkedNodesFinder = function(t, e, i) {
        function n(t, e) {
            return r.indexOf(e.nodes, t) >= 0
        }
        function a(t, n) {
            var a = !1;
            return e(function(e) {
                r.each(i(t, e) || [], function(t) {
                    n.records[e.name][t] && (a = !0)
                })
            }), a
        }
        function o(t, n) {
            n.nodes.push(t), e(function(e) {
                r.each(i(t, e) || [], function(t) {
                    n.records[e.name][t] = !0
                })
            })
        }
        return function(i) {
            function r(t) {
                !n(t, s) && a(t, s) && (o(t, s), l = !0)
            }
            var s = {
                nodes: [],
                records: {}
            };
            if (e(function(t) {
                s.records[t.name] = {}
            }), !i)
                return s;
            o(i, s);
            var l;
            do l = !1, t(r);
            while (l);
            return s
        }
    }, t.exports = a
}, function(t, e, i) {
    function n(t, e) {
        var i = [1 / 0, -(1 / 0)];
        return l(e, function(e) {
            var n = e.getData();
            n && l(e.coordDimToDataDim(t), function(t) {
                var e = n.getDataExtent(t);
                e[0] < i[0] && (i[0] = e[0]), e[1] > i[1] && (i[1] = e[1])
            })
        }, this), i
    }
    function r(t, e, i) {
        return l(["min", "max"], function(n, r) {
            var a = e.get(n, !0);
            null != a && (a + "").toLowerCase() !== "data" + n && (t[r] = i.parse(a))
        }), e.get("scale", !0) || (t[0] > 0 && (t[0] = 0), t[1] < 0 && (t[1] = 0)), t
    }
    function a(t, e) {
        var i = t.getAxisModel(),
            n = t._percentWindow,
            r = t._valueWindow;
        if (n) {
            var a = e || 0 === n[0] && 100 === n[1],
                o = !e && s.getPixelPrecision(r, [0, 500]),
                l = !(e || o < 20 && o >= 0),
                c = e || a || l;
            i.setRange && i.setRange(c ? null : +r[0].toFixed(o), c ? null : +r[1].toFixed(o))
        }
    }
    var o = i(509),
        s = i(512),
        l = o.each,
        c = s.asc,
        u = function(t, e, i, n) {
            this._dimName = t, this._axisIndex = e, this._valueWindow, this._percentWindow, this._dataExtent, this.ecModel = n, this._dataZoomModel = i
        };
    u.prototype = {
        constructor: u,
        hostedBy: function(t) {
            return this._dataZoomModel === t
        },
        getDataExtent: function() {
            return this._dataExtent.slice()
        },
        getDataValueWindow: function() {
            return this._valueWindow.slice()
        },
        getDataPercentWindow: function() {
            return this._percentWindow.slice()
        },
        getTargetSeriesModels: function() {
            var t = [],
                e = this.ecModel;
            return e.eachSeries(function(i) {
                var n = i.get("coordinateSystem");
                if ("cartesian2d" === n || "polar" === n) {
                    var r = this._dimName,
                        a = e.queryComponents({
                            mainType: r + "Axis",
                            index: i.get(r + "AxisIndex"),
                            id: i.get(r + "AxisId")
                        })[0];
                    this._axisIndex === (a && a.componentIndex) && t.push(i)
                }
            }, this), t
        },
        getAxisModel: function() {
            return this.ecModel.getComponent(this._dimName + "Axis", this._axisIndex)
        },
        getOtherAxisModel: function() {
            var t,
                e,
                i = this._dimName,
                n = this.ecModel,
                r = this.getAxisModel(),
                a = "x" === i || "y" === i;
            a ? (e = "gridIndex", t = "x" === i ? "y" : "x") : (e = "polarIndex", t = "angle" === i ? "radius" : "angle");
            var o;
            return n.eachComponent(t + "Axis", function(t) {
                (t.get(e) || 0) === (r.get(e) || 0) && (o = t)
            }), o
        },
        calculateDataWindow: function(t, e) {
            var i = this.getAxisModel(),
                n = i.axis.scale,
                a = [0, 100],
                o = [t.start, t.end],
                u = [];
            return e = e.slice(), r(e, i, n), l(["startValue", "endValue"], function(e) {
                u.push(null != t[e] ? n.parse(t[e]) : null)
            }), l([0, 1], function(t) {
                var i = u[t],
                    r = o[t];
                null != r || null == i ? (null == r && (r = a[t]), i = n.parse(s.linearMap(r, a, e, !0))) : r = s.linearMap(i, e, a, !0), u[t] = i, o[t] = r
            }), {
                valueWindow: c(u),
                percentWindow: c(o)
            }
        },
        reset: function(t) {
            if (t === this._dataZoomModel) {
                var e = this._dataExtent = n(this._dimName, this.getTargetSeriesModels()),
                    i = this.calculateDataWindow(t.option, e);
                this._valueWindow = i.valueWindow, this._percentWindow = i.percentWindow, a(this)
            }
        },
        restore: function(t) {
            t === this._dataZoomModel && (this._valueWindow = this._percentWindow = null, a(this, !0))
        },
        filterData: function(t) {
            function e(t) {
                return t >= a[0] && t <= a[1]
            }
            if (t === this._dataZoomModel) {
                var i = this._dimName,
                    n = this.getTargetSeriesModels(),
                    r = t.get("filterMode"),
                    a = this._valueWindow,
                    o = this.getOtherAxisModel();
                t.get("$fromToolbox") && o && "category" === o.get("type") && (r = "empty"), l(n, function(t) {
                    var n = t.getData();
                    n && l(t.coordDimToDataDim(i), function(i) {
                        "empty" === r ? t.setData(n.map(i, function(t) {
                            return e(t) ? t : NaN
                        })) : n.filterSelf(i, e)
                    })
                })
            }
        }
    }, t.exports = u
}, function(t, e, i) {
    var n = i(534);
    t.exports = n.extend({
        type: "dataZoom",
        render: function(t, e, i, n) {
            this.dataZoomModel = t, this.ecModel = e, this.api = i
        },
        getTargetInfo: function() {
            function t(t, e, i, n) {
                for (var r, a = 0; a < i.length; a++)
                    if (i[a].model === t) {
                        r = i[a];
                        break
                    }
                r || i.push(r = {
                    model: t,
                    axisModels: [],
                    coordIndex: n
                }), r.axisModels.push(e)
            }
            var e = this.dataZoomModel,
                i = this.ecModel,
                n = [],
                r = [],
                a = [];
            return e.eachTargetAxis(function(e, o) {
                var s = i.getComponent(e.axis, o);
                if (s) {
                    a.push(s);
                    var l,
                        c = e.axis;
                    "xAxis" === c || "yAxis" === c ? l = "grid" : "angleAxis" !== c && "radiusAxis" !== c || (l = "polar");
                    var u = l ? i.queryComponents({
                        mainType: l,
                        index: s.get(l + "Index"),
                        id: s.get(l + "Id")
                    })[0] : null;
                    null != u && t(u, s, "grid" === l ? n : r, u.componentIndex)
                }
            }, this), {
                cartesians: n,
                polars: r,
                axisModels: a
            }
        }
    })
}, function(t, e, i) {
    var n = i(825),
        r = n.extend({
            type: "dataZoom.slider",
            layoutMode: "box",
            defaultOption: {
                show: !0,
                right: "ph",
                top: "ph",
                width: "ph",
                height: "ph",
                left: null,
                bottom: null,
                backgroundColor: "rgba(47,69,84,0)",
                dataBackground: {
                    lineStyle: {
                        color: "#2f4554",
                        width: .5,
                        opacity: .3
                    },
                    areaStyle: {
                        color: "rgba(47,69,84,0.3)",
                        opacity: .3
                    }
                },
                borderColor: "#ddd",
                fillerColor: "rgba(167,183,204,0.4)",
                handleIcon: "M8.2,13.6V3.9H6.3v9.7H3.1v14.9h3.3v9.7h1.8v-9.7h3.3V13.6H8.2z M9.7,24.4H4.8v-1.4h4.9V24.4z M9.7,19.1H4.8v-1.4h4.9V19.1z",
                handleSize: "100%",
                handleStyle: {
                    color: "#a7b7cc"
                },
                labelPrecision: null,
                labelFormatter: null,
                showDetail: !0,
                showDataShadow: "auto",
                realtime: !0,
                zoomLock: !1,
                textStyle: {
                    color: "#333"
                }
            }
        });
    t.exports = r
}, function(t, e, i) {
    function n(t) {
        return "x" === t ? "y" : "x"
    }
    var r = i(509),
        a = i(548),
        o = i(586),
        s = i(828),
        l = a.Rect,
        c = i(512),
        u = c.linearMap,
        h = i(526),
        d = i(831),
        p = c.asc,
        f = r.bind,
        g = r.each,
        m = 7,
        v = 1,
        y = 30,
        x = "horizontal",
        _ = "vertical",
        b = 5,
        w = ["line", "bar", "candlestick", "scatter"],
        M = s.extend({
            type: "dataZoom.slider",
            init: function(t, e) {
                this._displayables = {}, this._orient, this._range, this._handleEnds, this._size, this._handleWidth, this._handleHeight, this._location, this._dragging, this._dataShadowInfo, this.api = e
            },
            render: function(t, e, i, n) {
                return M.superApply(this, "render", arguments), o.createOrUpdate(this, "_dispatchZoomAction", this.dataZoomModel.get("throttle"), "fixRate"), this._orient = t.get("orient"), this.dataZoomModel.get("show") === !1 ? void this.group.removeAll() : (n && "dataZoom" === n.type && n.from === this.uid || this._buildView(), void this._updateView())
            },
            remove: function() {
                M.superApply(this, "remove", arguments), o.clear(this, "_dispatchZoomAction")
            },
            dispose: function() {
                M.superApply(this, "dispose", arguments), o.clear(this, "_dispatchZoomAction")
            },
            _buildView: function() {
                var t = this.group;
                t.removeAll(), this._resetLocation(), this._resetInterval();
                var e = this._displayables.barGroup = new a.Group;
                this._renderBackground(), this._renderHandle(), this._renderDataShadow(), t.add(e), this._positionGroup()
            },
            _resetLocation: function() {
                var t = this.dataZoomModel,
                    e = this.api,
                    i = this._findCoordRect(),
                    n = {
                        width: e.getWidth(),
                        height: e.getHeight()
                    },
                    a = this._orient === x ? {
                        right: n.width - i.x - i.width,
                        top: n.height - y - m,
                        width: i.width,
                        height: y
                    } : {
                        right: m,
                        top: i.y,
                        width: y,
                        height: i.height
                    },
                    o = h.getLayoutParams(t.option);
                r.each(["right", "top", "width", "height"], function(t) {
                    "ph" === o[t] && (o[t] = a[t])
                });
                var s = h.getLayoutRect(o, n, t.padding);
                this._location = {
                    x: s.x,
                    y: s.y
                }, this._size = [s.width, s.height], this._orient === _ && this._size.reverse()
            },
            _positionGroup: function() {
                var t = this.group,
                    e = this._location,
                    i = this._orient,
                    n = this.dataZoomModel.getFirstTargetAxisModel(),
                    r = n && n.get("inverse"),
                    a = this._displayables.barGroup,
                    o = (this._dataShadowInfo || {}).otherAxisInverse;
                a.attr(i !== x || r ? i === x && r ? {
                    scale: o ? [-1, 1] : [-1, -1]
                } : i !== _ || r ? {
                    scale: o ? [-1, -1] : [-1, 1],
                    rotation: Math.PI / 2
                } : {
                    scale: o ? [1, -1] : [1, 1],
                    rotation: Math.PI / 2
                } : {
                    scale: o ? [1, 1] : [1, -1]
                });
                var s = t.getBoundingRect([a]);
                t.attr("position", [e.x - s.x, e.y - s.y])
            },
            _getViewExtent: function() {
                return [0, this._size[0]]
            },
            _renderBackground: function() {
                var t = this.dataZoomModel,
                    e = this._size;
                this._displayables.barGroup.add(new l({
                    silent: !0,
                    shape: {
                        x: 0,
                        y: 0,
                        width: e[0],
                        height: e[1]
                    },
                    style: {
                        fill: t.get("backgroundColor")
                    },
                    z2: -40
                }))
            },
            _renderDataShadow: function() {
                var t = this._dataShadowInfo = this._prepareDataShadowInfo();
                if (t) {
                    var e = this._size,
                        i = t.series,
                        n = i.getRawData(),
                        o = i.getShadowDim ? i.getShadowDim() : t.otherDim,
                        s = n.getDataExtent(o),
                        l = .3 * (s[1] - s[0]);
                    s = [s[0] - l, s[1] + l];
                    var c,
                        h = [0, e[1]],
                        d = [0, e[0]],
                        p = [[e[0], 0], [0, 0]],
                        f = [],
                        g = d[1] / (n.count() - 1),
                        m = 0,
                        v = Math.round(n.count() / e[0]);
                    n.each([o], function(t, e) {
                        if (v > 0 && e % v)
                            return void (m += g);
                        var i = null == t || isNaN(t) || "" === t,
                            n = i ? 0 : u(t, s, h, !0);
                        i && !c && e ? (p.push([p[p.length - 1][0], 0]), f.push([f[f.length - 1][0], 0])) : !i && c && (p.push([m, 0]), f.push([m, 0])), p.push([m, n]), f.push([m, n]), m += g, c = i
                    });
                    var y = this.dataZoomModel;
                    this._displayables.barGroup.add(new a.Polygon({
                        shape: {
                            points: p
                        },
                        style: r.defaults({
                            fill: y.get("dataBackgroundColor")
                        }, y.getModel("dataBackground.areaStyle").getAreaStyle()),
                        silent: !0,
                        z2: -20
                    })), this._displayables.barGroup.add(new a.Polyline({
                        shape: {
                            points: f
                        },
                        style: y.getModel("dataBackground.lineStyle").getLineStyle(),
                        silent: !0,
                        z2: -19
                    }))
                }
            },
            _prepareDataShadowInfo: function() {
                var t = this.dataZoomModel,
                    e = t.get("showDataShadow");
                if (e !== !1) {
                    var i,
                        a = this.ecModel;
                    return t.eachTargetAxis(function(o, s) {
                        var l = t.getAxisProxy(o.name, s).getTargetSeriesModels();
                        r.each(l, function(t) {
                            if (!(i || e !== !0 && r.indexOf(w, t.get("type")) < 0)) {
                                var l = n(o.name),
                                    c = a.getComponent(o.axis, s).axis;
                                i = {
                                    thisAxis: c,
                                    series: t,
                                    thisDim: o.name,
                                    otherDim: l,
                                    otherAxisInverse: t.coordinateSystem.getOtherAxis(c).inverse
                                }
                            }
                        }, this)
                    }, this), i
                }
            },
            _renderHandle: function() {
                var t = this._displayables,
                    e = t.handles = [],
                    i = t.handleLabels = [],
                    n = this._displayables.barGroup,
                    r = this._size,
                    o = this.dataZoomModel;
                n.add(t.filler = new l({
                    draggable: !0,
                    cursor: "move",
                    drift: f(this._onDragMove, this, "all"),
                    ondragstart: f(this._showDataInfo, this, !0),
                    ondragend: f(this._onDragEnd, this),
                    onmouseover: f(this._showDataInfo, this, !0),
                    onmouseout: f(this._showDataInfo, this, !1),
                    style: {
                        fill: o.get("fillerColor"),
                        textPosition: "inside"
                    }
                })), n.add(new l(a.subPixelOptimizeRect({
                    silent: !0,
                    shape: {
                        x: 0,
                        y: 0,
                        width: r[0],
                        height: r[1]
                    },
                    style: {
                        stroke: o.get("dataBackgroundColor") || o.get("borderColor"),
                        lineWidth: v,
                        fill: "rgba(0,0,0,0)"
                    }
                })));
                var s = o.get("handleIcon");
                g([0, 1], function(t) {
                    var r = a.makePath(s, {
                            style: {
                                strokeNoScale: !0
                            },
                            rectHover: !0,
                            cursor: "vertical" === this._orient ? "ns-resize" : "ew-resize",
                            draggable: !0,
                            drift: f(this._onDragMove, this, t),
                            ondragend: f(this._onDragEnd, this),
                            onmouseover: f(this._showDataInfo, this, !0),
                            onmouseout: f(this._showDataInfo, this, !1)
                        }, {
                            x: -.5,
                            y: 0,
                            width: 1,
                            height: 1
                        }, "center"),
                        l = r.getBoundingRect();
                    this._handleHeight = c.parsePercent(o.get("handleSize"), this._size[1]), this._handleWidth = l.width / l.height * this._handleHeight, r.setStyle(o.getModel("handleStyle").getItemStyle());
                    var u = o.get("handleColor");
                    null != u && (r.style.fill = u), n.add(e[t] = r);
                    var h = o.textStyleModel;
                    this.group.add(i[t] = new a.Text({
                        silent: !0,
                        invisible: !0,
                        style: {
                            x: 0,
                            y: 0,
                            text: "",
                            textVerticalAlign: "middle",
                            textAlign: "center",
                            fill: h.getTextColor(),
                            textFont: h.getFont()
                        },
                        z2: 10
                    }))
                }, this)
            },
            _resetInterval: function() {
                var t = this._range = this.dataZoomModel.getPercentRange(),
                    e = this._getViewExtent();
                this._handleEnds = [u(t[0], [0, 100], e, !0), u(t[1], [0, 100], e, !0)]
            },
            _updateInterval: function(t, e) {
                var i = this._handleEnds,
                    n = this._getViewExtent();
                d(e, i, n, "all" === t || this.dataZoomModel.get("zoomLock") ? "rigid" : "cross", t), this._range = p([u(i[0], n, [0, 100], !0), u(i[1], n, [0, 100], !0)])
            },
            _updateView: function(t) {
                var e = this._displayables,
                    i = this._handleEnds,
                    n = p(i.slice()),
                    r = this._size;
                g([0, 1], function(t) {
                    var n = e.handles[t],
                        a = this._handleHeight;
                    n.attr({
                        scale: [a, a],
                        position: [i[t], r[1] / 2 - a / 2]
                    })
                }, this), e.filler.setShape({
                    x: n[0],
                    y: 0,
                    width: n[1] - n[0],
                    height: r[1]
                }), this._updateDataInfo(t)
            },
            _updateDataInfo: function(t) {
                function e(t) {
                    var e = a.getTransform(n.handles[t].parent, this.group),
                        i = a.transformDirection(0 === t ? "right" : "left", e),
                        l = this._handleWidth / 2 + b,
                        c = a.applyTransform([d[t] + (0 === t ? -l : l), this._size[1] / 2], e);
                    r[t].setStyle({
                        x: c[0],
                        y: c[1],
                        textVerticalAlign: o === x ? "middle" : i,
                        textAlign: o === x ? i : "center",
                        text: s[t]
                    })
                }
                var i = this.dataZoomModel,
                    n = this._displayables,
                    r = n.handleLabels,
                    o = this._orient,
                    s = ["", ""];
                if (i.get("showDetail")) {
                    var l = i.findRepresentativeAxisProxy();
                    if (l) {
                        var c = l.getAxisModel().axis,
                            u = this._range,
                            h = t ? l.calculateDataWindow({
                                start: u[0],
                                end: u[1]
                            }, l.getDataExtent()).valueWindow : l.getDataValueWindow();
                        s = [this._formatLabel(h[0], c), this._formatLabel(h[1], c)]
                    }
                }
                var d = p(this._handleEnds.slice());
                e.call(this, 0), e.call(this, 1)
            },
            _formatLabel: function(t, e) {
                var i = this.dataZoomModel,
                    n = i.get("labelFormatter"),
                    a = i.get("labelPrecision");
                null != a && "auto" !== a || (a = e.getPixelPrecision());
                var o = null == t && isNaN(t) ? "" : "category" === e.type || "time" === e.type ? e.scale.getLabel(Math.round(t)) : t.toFixed(Math.min(a, 20));
                return r.isFunction(n) ? n(t, o) : r.isString(n) ? n.replace("{value}", o) : o
            },
            _showDataInfo: function(t) {
                t = this._dragging || t;
                var e = this._displayables.handleLabels;
                e[0].attr("invisible", !t), e[1].attr("invisible", !t)
            },
            _onDragMove: function(t, e, i) {
                this._dragging = !0;
                var n = this._applyBarTransform([e, i], !0);
                this._updateInterval(t, n[0]);
                var r = this.dataZoomModel.get("realtime");
                this._updateView(!r), r && r && this._dispatchZoomAction()
            },
            _onDragEnd: function() {
                this._dragging = !1, this._showDataInfo(!1), this._dispatchZoomAction()
            },
            _dispatchZoomAction: function() {
                var t = this._range;
                this.api.dispatchAction({
                    type: "dataZoom",
                    from: this.uid,
                    dataZoomId: this.dataZoomModel.id,
                    start: t[0],
                    end: t[1]
                })
            },
            _applyBarTransform: function(t, e) {
                var i = this._displayables.barGroup.getLocalTransform();
                return a.applyTransform(t, i, e)
            },
            _findCoordRect: function() {
                var t,
                    e = this.getTargetInfo();
                if (e.cartesians.length)
                    t = e.cartesians[0].model.coordinateSystem.getRect();
                else {
                    var i = this.api.getWidth(),
                        n = this.api.getHeight();
                    t = {
                        x: .2 * i,
                        y: .2 * n,
                        width: .6 * i,
                        height: .6 * n
                    }
                }
                return t
            }
        });
    t.exports = M
}, function(t, e) {
    t.exports = function(t, e, i, n, r) {
        function a(t, e, i) {
            var n = e.length ? e.slice() : [e, e];
            return e[0] > e[1] && n.reverse(), t < 0 && n[0] + t < i[0] && (t = i[0] - n[0]), t > 0 && n[1] + t > i[1] && (t = i[1] - n[1]), t
        }
        return t ? ("rigid" === n ? (t = a(t, e, i), e[0] += t, e[1] += t) : (t = a(t, e[r], i), e[r] += t, "push" === n && e[0] > e[1] && (e[1 - r] = e[r])), e) : e
    }
}, function(t, e, i) {
    t.exports = i(825).extend({
        type: "dataZoom.inside",
        defaultOption: {
            disabled: !1,
            zoomLock: !1
        }
    })
}, function(t, e, i) {
    function n(t) {
        var e = [0, 100];
        return !(t[0] <= e[1]) && (t[0] = e[1]), !(t[1] <= e[1]) && (t[1] = e[1]), !(t[0] >= e[0]) && (t[0] = e[0]), !(t[1] >= e[0]) && (t[1] = e[0]), t
    }
    var r = i(828),
        a = i(509),
        o = i(831),
        s = i(834),
        l = a.bind,
        c = r.extend({
            type: "dataZoom.inside",
            init: function(t, e) {
                this._range
            },
            render: function(t, e, i, n) {
                c.superApply(this, "render", arguments), s.shouldRecordRange(n, t.id) && (this._range = t.getPercentRange());
                var r = this.getTargetInfo();
                a.each(["cartesians", "polars"], function(e) {
                    var n = r[e],
                        o = a.map(n, function(t) {
                            return s.generateCoordId(t.model)
                        });
                    a.each(n, function(n) {
                        var r = n.model,
                            a = r.coordinateSystem;
                        s.register(i, {
                            coordId: s.generateCoordId(r),
                            allCoordIds: o,
                            coordinateSystem: a,
                            containsPoint: l(u[e].containsPoint, this, a),
                            dataZoomId: t.id,
                            throttleRate: t.get("throttle", !0),
                            panGetRange: l(this._onPan, this, n, e),
                            zoomGetRange: l(this._onZoom, this, n, e)
                        })
                    }, this)
                }, this)
            },
            dispose: function() {
                s.unregister(this.api, this.dataZoomModel.id), c.superApply(this, "dispose", arguments), this._range = null
            },
            _onPan: function(t, e, i, n, r, a, s, l, c) {
                if (this.dataZoomModel.option.disabled)
                    return this._range;
                var h = this._range.slice(),
                    d = t.axisModels[0];
                if (d) {
                    var p = u[e].getDirectionInfo([a, s], [l, c], d, i, t),
                        f = p.signal * (h[1] - h[0]) * p.pixel / p.pixelLength;
                    return o(f, h, [0, 100], "rigid"), this._range = h
                }
            },
            _onZoom: function(t, e, i, r, a, o) {
                var s = this.dataZoomModel.option;
                if (s.disabled || s.zoomLock)
                    return this._range;
                var l = this._range.slice(),
                    c = t.axisModels[0];
                if (c) {
                    var h = u[e].getDirectionInfo(null, [a, o], c, i, t),
                        d = (h.pixel - h.pixelStart) / h.pixelLength * (l[1] - l[0]) + l[0];
                    return r = Math.max(1 / r, 0), l[0] = (l[0] - d) * r + d, l[1] = (l[1] - d) * r + d, this._range = n(l)
                }
            }
        }),
        u = {
            cartesians: {
                getDirectionInfo: function(t, e, i, n, r) {
                    var a = i.axis,
                        o = {},
                        s = r.model.coordinateSystem.getRect();
                    return t = t || [0, 0], "x" === a.dim ? (o.pixel = e[0] - t[0], o.pixelLength = s.width, o.pixelStart = s.x, o.signal = a.inverse ? 1 : -1) : (o.pixel = e[1] - t[1], o.pixelLength = s.height, o.pixelStart = s.y, o.signal = a.inverse ? -1 : 1), o
                },
                containsPoint: function(t, e, i) {
                    return t.getRect().contain(e, i)
                }
            },
            polars: {
                getDirectionInfo: function(t, e, i, n, r) {
                    var a = i.axis,
                        o = {},
                        s = r.model.coordinateSystem,
                        l = s.getRadiusAxis().getExtent(),
                        c = s.getAngleAxis().getExtent();
                    return t = t ? s.pointToCoord(t) : [0, 0], e = s.pointToCoord(e), "radiusAxis" === i.mainType ? (o.pixel = e[0] - t[0], o.pixelLength = l[1] - l[0], o.pixelStart = l[0], o.signal = a.inverse ? 1 : -1) : (o.pixel = e[1] - t[1], o.pixelLength = c[1] - c[0], o.pixelStart = c[0], o.signal = a.inverse ? -1 : 1), o
                },
                containsPoint: function(t, e, i) {
                    var n = t.getRadiusAxis().getExtent()[1],
                        r = t.cx,
                        a = t.cy;
                    return Math.pow(e - r, 2) + Math.pow(i - a, 2) <= Math.pow(n, 2)
                }
            }
        };
    t.exports = c
}, function(t, e, i) {
    function n(t) {
        var e = t.getZr();
        return e[f] || (e[f] = {})
    }
    function r(t, e, i) {
        var n = new h(t.getZr());
        return n.enable(), n.on("pan", p(o, i)), n.on("zoom", p(s, i)), n
    }
    function a(t) {
        u.each(t, function(e, i) {
            e.count || (e.controller.dispose(), delete t[i])
        })
    }
    function o(t, e, i, n, r, a, o) {
        l(t, function(s) {
            return s.panGetRange(t.controller, e, i, n, r, a, o)
        })
    }
    function s(t, e, i, n) {
        l(t, function(r) {
            return r.zoomGetRange(t.controller, e, i, n)
        })
    }
    function l(t, e) {
        var i = [];
        u.each(t.dataZoomInfos, function(t) {
            var n = e(t);
            n && i.push({
                dataZoomId: t.dataZoomId,
                start: n[0],
                end: n[1]
            })
        }), t.dispatchAction(i)
    }
    function c(t, e) {
        t.dispatchAction({
            type: "dataZoom",
            batch: e
        })
    }
    var u = i(509),
        h = i(681),
        d = i(586),
        p = u.curry,
        f = "\0_ec_dataZoom_roams",
        g = {
            register: function(t, e) {
                var i = n(t),
                    o = e.dataZoomId,
                    s = e.coordId;
                u.each(i, function(t, i) {
                    var n = t.dataZoomInfos;
                    n[o] && u.indexOf(e.allCoordIds, s) < 0 && (delete n[o], t.count--)
                }), a(i);
                var l = i[s];
                l || (l = i[s] = {
                    coordId: s,
                    dataZoomInfos: {},
                    count: 0
                }, l.controller = r(t, e, l), l.dispatchAction = u.curry(c, t)), l.controller.setContainsPoint(e.containsPoint), d.createOrUpdate(l, "dispatchAction", e.throttleRate, "fixRate"), !l.dataZoomInfos[o] && l.count++, l.dataZoomInfos[o] = e
            },
            unregister: function(t, e) {
                var i = n(t);
                u.each(i, function(t) {
                    t.controller.dispose();
                    var i = t.dataZoomInfos;
                    i[e] && (delete i[e], t.count--)
                }), a(i)
            },
            shouldRecordRange: function(t, e) {
                if (t && "dataZoom" === t.type && t.batch)
                    for (var i = 0, n = t.batch.length; i < n; i++)
                        if (t.batch[i].dataZoomId === e)
                            return !1;
                return !0
            },
            generateCoordId: function(t) {
                return t.type + "\0_" + t.id
            }
        };
    t.exports = g
}, function(t, e, i) {
    function n(t, e, i) {
        i.getAxisProxy(t.name, e).reset(i)
    }
    function r(t, e, i) {
        i.getAxisProxy(t.name, e).filterData(i)
    }
    var a = i(506);
    a.registerProcessor(function(t, e) {
        t.eachComponent("dataZoom", function(t) {
            t.eachTargetAxis(n), t.eachTargetAxis(r)
        }), t.eachComponent("dataZoom", function(t) {
            var e = t.findRepresentativeAxisProxy(),
                i = e.getDataPercentWindow(),
                n = e.getDataValueWindow();
            t.setRawRange({
                start: i[0],
                end: i[1],
                startValue: n[0],
                endValue: n[1]
            })
        })
    })
}, function(t, e, i) {
    var n = i(509),
        r = i(826),
        a = i(506);
    a.registerAction("dataZoom", function(t, e) {
        var i = r.createLinkedNodesFinder(n.bind(e.eachComponent, e, "dataZoom"), r.eachAxisDim, function(t, e) {
                return t.get(e.axisIndex)
            }),
            a = [];
        e.eachComponent({
            mainType: "dataZoom",
            query: t
        }, function(t, e) {
            a.push.apply(a, i(t).nodes)
        }), n.each(a, function(e, i) {
            e.setRawRange({
                start: t.start,
                end: t.end,
                startValue: t.startValue,
                endValue: t.endValue
            })
        })
    })
}, function(t, e, i) {
    i(838), i(849)
}, function(t, e, i) {
    i(506).registerPreprocessor(i(839)), i(840), i(841), i(842), i(845), i(848)
}, function(t, e, i) {
    function n(t, e) {
        return t && t.hasOwnProperty && t.hasOwnProperty(e)
    }
    var r = i(509),
        a = r.each;
    t.exports = function(t) {
        var e = t && t.visualMap;
        r.isArray(e) || (e = e ? [e] : []), a(e, function(t) {
            if (t) {
                n(t, "splitList") && !n(t, "pieces") && (t.pieces = t.splitList, delete t.splitList);
                var e = t.pieces;
                e && r.isArray(e) && a(e, function(t) {
                    r.isObject(t) && (n(t, "start") && !n(t, "min") && (t.min = t.start), n(t, "end") && !n(t, "max") && (t.max = t.end))
                })
            }
        })
    }
}, function(t, e, i) {
    i(524).registerSubTypeDefaulter("visualMap", function(t) {
        return t.categories || (t.pieces ? t.pieces.length > 0 : t.splitNumber > 0) && !t.calculable ? "piecewise" : "continuous"
    })
}, function(t, e, i) {
    function n(t, e) {
        t.eachTargetSeries(function(e) {
            var i = e.getData();
            s.applyVisual(t.stateList, t.targetVisuals, i, t.getValueState, t, t.getDataDimension(i))
        })
    }
    function r(t) {
        t.eachSeries(function(e) {
            var i = e.getData(),
                n = [];
            t.eachComponent("visualMap", function(t) {
                if (t.isTargetSeries(e)) {
                    var r = t.getVisualMeta(c.bind(a, null, e, t)) || {
                        stops: [],
                        outerColors: []
                    };
                    r.dimension = t.getDataDimension(i), n.push(r)
                }
            }), e.getData().setVisual("visualMeta", n)
        })
    }
    function a(t, e, i, n) {
        function r(t) {
            return c[t]
        }
        function a(t, e) {
            c[t] = e
        }
        for (var o = e.targetVisuals[n], s = l.prepareVisualTypes(o), c = {
                color: t.getData().getVisual("color")
            }, u = 0, h = s.length; u < h; u++) {
            var d = s[u],
                p = o["opacity" === d ? "__alphaForOpacity" : d];
            p && p.applyVisual(i, r, a)
        }
        return c.color
    }
    var o = i(506),
        s = i(814),
        l = i(699),
        c = i(509);
    o.registerVisual(o.PRIORITY.VISUAL.COMPONENT, function(t) {
        t.eachComponent("visualMap", function(e) {
            n(e, t)
        }), r(t)
    })
}, function(t, e, i) {
    function n(t, e, i) {
        if (i[0] === i[1])
            return i.slice();
        for (var n = 200, r = (i[1] - i[0]) / n, a = i[0], o = [], s = 0; s <= n && a < i[1]; s++)
            o.push(a), a += r;
        return o.push(i[1]), o
    }
    var r = i(843),
        a = i(509),
        o = i(512),
        s = [20, 140],
        l = r.extend({
            type: "visualMap.continuous",
            defaultOption: {
                align: "auto",
                calculable: !1,
                range: null,
                realtime: !0,
                itemHeight: null,
                itemWidth: null,
                hoverLink: !0,
                hoverLinkDataSize: null,
                hoverLinkOnHandle: !0
            },
            optionUpdated: function(t, e) {
                l.superApply(this, "optionUpdated", arguments), this.resetTargetSeries(), this.resetExtent(), this.resetVisual(function(t) {
                    t.mappingMethod = "linear", t.dataExtent = this.getExtent()
                }), this._resetRange()
            },
            resetItemSize: function() {
                l.superApply(this, "resetItemSize", arguments);
                var t = this.itemSize;
                "horizontal" === this._orient && t.reverse(), (null == t[0] || isNaN(t[0])) && (t[0] = s[0]), (null == t[1] || isNaN(t[1])) && (t[1] = s[1])
            },
            _resetRange: function() {
                var t = this.getExtent(),
                    e = this.option.range;
                !e || e.auto ? (t.auto = 1, this.option.range = t) : a.isArray(e) && (e[0] > e[1] && e.reverse(), e[0] = Math.max(e[0], t[0]), e[1] = Math.min(e[1], t[1]))
            },
            completeVisualOption: function() {
                r.prototype.completeVisualOption.apply(this, arguments), a.each(this.stateList, function(t) {
                    var e = this.option.controller[t].symbolSize;
                    e && e[0] !== e[1] && (e[0] = 0)
                }, this)
            },
            setSelected: function(t) {
                this.option.range = t.slice(), this._resetRange()
            },
            getSelected: function() {
                var t = this.getExtent(),
                    e = o.asc((this.get("range") || []).slice());
                return e[0] > t[1] && (e[0] = t[1]), e[1] > t[1] && (e[1] = t[1]), e[0] < t[0] && (e[0] = t[0]), e[1] < t[0] && (e[1] = t[0]), e
            },
            getValueState: function(t) {
                var e = this.option.range,
                    i = this.getExtent();
                return (e[0] <= i[0] || e[0] <= t) && (e[1] >= i[1] || t <= e[1]) ? "inRange" : "outOfRange"
            },
            findTargetDataIndices: function(t) {
                var e = [];
                return this.eachTargetSeries(function(i) {
                    var n = [],
                        r = i.getData();
                    r.each(this.getDataDimension(r), function(e, i) {
                        t[0] <= e && e <= t[1] && n.push(i)
                    }, !0, this), e.push({
                        seriesId: i.id,
                        dataIndex: n
                    })
                }, this), e
            },
            getVisualMeta: function(t) {
                function e(e, i) {
                    a.push({
                        value: e,
                        color: t(e, i)
                    })
                }
                for (var i = n(this, "outOfRange", this.getExtent()), r = n(this, "inRange", this.option.range.slice()), a = [], o = 0, s = 0, l = r.length, c = i.length; s < c && (!r.length || i[s] <= r[0]); s++)
                    i[s] < r[o] && e(i[s], "outOfRange");
                for (var u = 1; o < l; o++, u = 0)
                    u && a.length && e(r[o], "outOfRange"), e(r[o], "inRange");
                for (var u = 1; s < c; s++)
                    (!r.length || r[r.length - 1] < i[s]) && (u && (a.length && e(a[a.length - 1].value, "outOfRange"), u = 0), e(i[s], "outOfRange"));
                var h = a.length;
                return {
                    stops: a,
                    outerColors: [h ? a[0].color : "transparent", h ? a[h - 1].color : "transparent"]
                }
            }
        });
    t.exports = l
}, function(t, e, i) {
    var n = i(506),
        r = i(509),
        a = i(507),
        o = i(844),
        s = i(699),
        l = i(814),
        c = s.mapVisual,
        u = i(510),
        h = s.eachVisual,
        d = i(512),
        p = r.isArray,
        f = r.each,
        g = d.asc,
        m = d.linearMap,
        v = r.noop,
        y = ["#f6efa6", "#d88273", "#bf444c"],
        x = n.extendComponentModel({
            type: "visualMap",
            dependencies: ["series"],
            stateList: ["inRange", "outOfRange"],
            replacableOptionKeys: ["inRange", "outOfRange", "target", "controller", "color"],
            dataBound: [-(1 / 0), 1 / 0],
            layoutMode: {
                type: "box",
                ignoreSize: !0
            },
            defaultOption: {
                show: !0,
                zlevel: 0,
                z: 4,
                seriesIndex: null,
                min: 0,
                max: 200,
                dimension: null,
                inRange: null,
                outOfRange: null,
                left: 0,
                right: null,
                top: null,
                bottom: 0,
                itemWidth: null,
                itemHeight: null,
                inverse: !1,
                orient: "vertical",
                backgroundColor: "rgba(0,0,0,0)",
                borderColor: "#ccc",
                contentColor: "#5793f3",
                inactiveColor: "#aaa",
                borderWidth: 0,
                padding: 5,
                textGap: 10,
                precision: 0,
                color: null,
                formatter: null,
                text: null,
                textStyle: {
                    color: "#333"
                }
            },
            init: function(t, e, i) {
                this._dataExtent, this.targetVisuals = {}, this.controllerVisuals = {}, this.textStyleModel, this.itemSize, this.mergeDefaultAndTheme(t, i)
            },
            optionUpdated: function(t, e) {
                var i = this.option;
                a.canvasSupported || (i.realtime = !1), !e && l.replaceVisualOption(i, t, this.replacableOptionKeys), this.textStyleModel = this.getModel("textStyle"), this.resetItemSize(), this.completeVisualOption()
            },
            resetVisual: function(t) {
                var e = this.stateList;
                t = r.bind(t, this), this.controllerVisuals = l.createVisualMappings(this.option.controller, e, t), this.targetVisuals = l.createVisualMappings(this.option.target, e, t)
            },
            resetTargetSeries: function() {
                var t = this.option,
                    e = null == t.seriesIndex;
                t.seriesIndex = e ? [] : u.normalizeToArray(t.seriesIndex), e && this.ecModel.eachSeries(function(e, i) {
                    t.seriesIndex.push(i)
                })
            },
            eachTargetSeries: function(t, e) {
                r.each(this.option.seriesIndex, function(i) {
                    t.call(e, this.ecModel.getSeriesByIndex(i))
                }, this)
            },
            isTargetSeries: function(t) {
                var e = !1;
                return this.eachTargetSeries(function(i) {
                    i === t && (e = !0)
                }), e
            },
            formatValueText: function(t, e, i) {
                function n(t) {
                    return t === c[0] ? "min" : t === c[1] ? "max" : (+t).toFixed(l)
                }
                var a,
                    o,
                    s = this.option,
                    l = s.precision,
                    c = this.dataBound,
                    u = s.formatter;
                return i = i || ["<", ">"], r.isArray(t) && (t = t.slice(), a = !0), o = e ? t : a ? [n(t[0]), n(t[1])] : n(t), r.isString(u) ? u.replace("{value}", a ? o[0] : o).replace("{value2}", a ? o[1] : o) : r.isFunction(u) ? a ? u(t[0], t[1]) : u(t) : a ? t[0] === c[0] ? i[0] + " " + o[1] : t[1] === c[1] ? i[1] + " " + o[0] : o[0] + " - " + o[1] : o
            },
            resetExtent: function() {
                var t = this.option,
                    e = g([t.min, t.max]);
                this._dataExtent = e
            },
            getDataDimension: function(t) {
                var e = this.option.dimension;
                return null != e ? e : t.dimensions.length - 1
            },
            getExtent: function() {
                return this._dataExtent.slice()
            },
            completeVisualOption: function() {
                function t(t) {
                    p(n.color) && !t.inRange && (t.inRange = {
                        color: n.color.slice().reverse()
                    }), t.inRange = t.inRange || {
                        color: y
                    }, f(this.stateList, function(e) {
                        var i = t[e];
                        if (r.isString(i)) {
                            var n = o.get(i, "active", d);
                            n ? (t[e] = {}, t[e][i] = n) : delete t[e]
                        }
                    }, this)
                }
                function e(t, e, i) {
                    var n = t[e],
                        r = t[i];
                    n && !r && (r = t[i] = {}, f(n, function(t, e) {
                        if (s.isValidType(e)) {
                            var i = o.get(e, "inactive", d);
                            null != i && (r[e] = i, "color" !== e || r.hasOwnProperty("opacity") || r.hasOwnProperty("colorAlpha") || (r.opacity = [0, 0]))
                        }
                    }))
                }
                function i(t) {
                    var e = (t.inRange || {}).symbol || (t.outOfRange || {}).symbol,
                        i = (t.inRange || {}).symbolSize || (t.outOfRange || {}).symbolSize,
                        n = this.get("inactiveColor");
                    f(this.stateList, function(a) {
                        var o = this.itemSize,
                            s = t[a];
                        s || (s = t[a] = {
                            color: d ? n : [n]
                        }), null == s.symbol && (s.symbol = e && r.clone(e) || (d ? "roundRect" : ["roundRect"])), null == s.symbolSize && (s.symbolSize = i && r.clone(i) || (d ? o[0] : [o[0], o[0]])), s.symbol = c(s.symbol, function(t) {
                            return "none" === t || "square" === t ? "roundRect" : t
                        });
                        var l = s.symbolSize;
                        if (null != l) {
                            var u = -(1 / 0);
                            h(l, function(t) {
                                t > u && (u = t)
                            }), s.symbolSize = c(l, function(t) {
                                return m(t, [0, u], [0, o[0]], !0)
                            })
                        }
                    }, this)
                }
                var n = this.option,
                    a = {
                        inRange: n.inRange,
                        outOfRange: n.outOfRange
                    },
                    l = n.target || (n.target = {}),
                    u = n.controller || (n.controller = {});
                r.merge(l, a), r.merge(u, a);
                var d = this.isCategory();
                t.call(this, l), t.call(this, u), e.call(this, l, "inRange", "outOfRange"), i.call(this, u)
            },
            resetItemSize: function() {
                this.itemSize = [parseFloat(this.get("itemWidth")), parseFloat(this.get("itemHeight"))]
            },
            isCategory: function() {
                return !!this.option.categories
            },
            setSelected: v,
            getValueState: v,
            getVisualMeta: v
        });
    t.exports = x
}, function(t, e, i) {
    var n = i(509),
        r = {
            get: function(t, e, i) {
                var r = n.clone((a[t] || {})[e]);
                return i && n.isArray(r) ? r[r.length - 1] : r
            }
        },
        a = {
            color: {
                active: ["#006edd", "#e0ffff"],
                inactive: ["rgba(0,0,0,0)"]
            },
            colorHue: {
                active: [0, 360],
                inactive: [0, 0]
            },
            colorSaturation: {
                active: [.3, 1],
                inactive: [0, 0]
            },
            colorLightness: {
                active: [.9, .5],
                inactive: [0, 0]
            },
            colorAlpha: {
                active: [.3, 1],
                inactive: [0, 0]
            },
            opacity: {
                active: [.3, 1],
                inactive: [0, 0]
            },
            symbol: {
                active: ["circle", "roundRect", "diamond"],
                inactive: ["none"]
            },
            symbolSize: {
                active: [10, 50],
                inactive: [0, 0]
            }
        };
    t.exports = r
}, function(t, e, i) {
    function n(t, e, i, n) {
        return new c.Polygon({
            shape: {
                points: t
            },
            draggable: !!i,
            cursor: e,
            drift: i,
            ondragend: n
        })
    }
    function r(t, e) {
        return 0 === t ? [[0, 0], [e, 0], [e, -e]] : [[0, 0], [e, 0], [e, e]]
    }
    function a(t, e, i, n) {
        return t ? [[0, -y(e, x(i, 0))], [b, 0], [0, y(e, x(n - i, 0))]] : [[0, 0], [5, -5], [5, 5]]
    }
    function o(t, e, i) {
        var n = _ / 2,
            r = t.get("hoverLinkDataSize");
        return r && (n = m(r, e, i, !0) / 2), n
    }
    function s(t) {
        return !t.get("realtime") && t.get("hoverLinkOnHandle")
    }
    var l = i(846),
        c = i(548),
        u = i(509),
        h = i(512),
        d = i(831),
        p = i(583),
        f = i(847),
        g = i(510),
        m = h.linearMap,
        v = u.each,
        y = Math.min,
        x = Math.max,
        _ = 12,
        b = 6,
        w = l.extend({
            type: "visualMap.continuous",
            init: function() {
                w.superApply(this, "init", arguments), this._shapes = {}, this._dataInterval = [], this._handleEnds = [], this._orient, this._useHandle, this._hoverLinkDataIndices = [], this._dragging, this._hovering
            },
            doRender: function(t, e, i, n) {
                n && "selectDataRange" === n.type && n.from === this.uid || this._buildView()
            },
            _buildView: function() {
                this.group.removeAll();
                var t = this.visualMapModel,
                    e = this.group;
                this._orient = t.get("orient"), this._useHandle = t.get("calculable"), this._resetInterval(), this._renderBar(e);
                var i = t.get("text");
                this._renderEndsText(e, i, 0), this._renderEndsText(e, i, 1), this._updateView(!0), this.renderBackground(e), this._updateView(), this._enableHoverLinkToSeries(), this._enableHoverLinkFromSeries(), this.positionGroup(e)
            },
            _renderEndsText: function(t, e, i) {
                if (e) {
                    var n = e[1 - i];
                    n = null != n ? n + "" : "";
                    var r = this.visualMapModel,
                        a = r.get("textGap"),
                        o = r.itemSize,
                        s = this._shapes.barGroup,
                        l = this._applyTransform([o[0] / 2, 0 === i ? -a : o[1] + a], s),
                        u = this._applyTransform(0 === i ? "bottom" : "top", s),
                        h = this._orient,
                        d = this.visualMapModel.textStyleModel;
                    this.group.add(new c.Text({
                        style: {
                            x: l[0],
                            y: l[1],
                            textVerticalAlign: "horizontal" === h ? "middle" : u,
                            textAlign: "horizontal" === h ? u : "center",
                            text: n,
                            textFont: d.getFont(),
                            fill: d.getTextColor()
                        }
                    }))
                }
            },
            _renderBar: function(t) {
                var e = this.visualMapModel,
                    i = this._shapes,
                    r = e.itemSize,
                    a = this._orient,
                    o = this._useHandle,
                    s = f.getItemAlign(e, this.api, r),
                    l = i.barGroup = this._createBarGroup(s);
                l.add(i.outOfRange = n()), l.add(i.inRange = n(null, o ? "move" : null, u.bind(this._dragHandle, this, "all", !1), u.bind(this._dragHandle, this, "all", !0)));
                var c = e.textStyleModel.getTextRect("国"),
                    h = x(c.width, c.height);
                o && (i.handleThumbs = [], i.handleLabels = [], i.handleLabelPoints = [], this._createHandle(l, 0, r, h, a, s), this._createHandle(l, 1, r, h, a, s)), this._createIndicator(l, r, h, a), t.add(l)
            },
            _createHandle: function(t, e, i, a, o) {
                var s = u.bind(this._dragHandle, this, e, !1),
                    l = u.bind(this._dragHandle, this, e, !0),
                    h = n(r(e, a), "move", s, l);
                h.position[0] = i[0], t.add(h);
                var d = this.visualMapModel.textStyleModel,
                    p = new c.Text({
                        draggable: !0,
                        drift: s,
                        ondragend: l,
                        style: {
                            x: 0,
                            y: 0,
                            text: "",
                            textFont: d.getFont(),
                            fill: d.getTextColor()
                        }
                    });
                this.group.add(p);
                var f = ["horizontal" === o ? a / 2 : 1.5 * a, "horizontal" === o ? 0 === e ? -(1.5 * a) : 1.5 * a : 0 === e ? -a / 2 : a / 2],
                    g = this._shapes;
                g.handleThumbs[e] = h, g.handleLabelPoints[e] = f, g.handleLabels[e] = p
            },
            _createIndicator: function(t, e, i, r) {
                var a = n([[0, 0]], "move");
                a.position[0] = e[0], a.attr({
                    invisible: !0,
                    silent: !0
                }), t.add(a);
                var o = this.visualMapModel.textStyleModel,
                    s = new c.Text({
                        silent: !0,
                        invisible: !0,
                        style: {
                            x: 0,
                            y: 0,
                            text: "",
                            textFont: o.getFont(),
                            fill: o.getTextColor()
                        }
                    });
                this.group.add(s);
                var l = ["horizontal" === r ? i / 2 : b + 3, 0],
                    u = this._shapes;
                u.indicator = a, u.indicatorLabel = s, u.indicatorLabelPoint = l
            },
            _dragHandle: function(t, e, i, n) {
                if (this._useHandle) {
                    if (this._dragging = !e, !e) {
                        var r = this._applyTransform([i, n], this._shapes.barGroup, !0);
                        this._updateInterval(t, r[1]), this._updateView()
                    }
                    e === !this.visualMapModel.get("realtime") && this.api.dispatchAction({
                        type: "selectDataRange",
                        from: this.uid,
                        visualMapId: this.visualMapModel.id,
                        selected: this._dataInterval.slice()
                    }), e ? !this._hovering && this._clearHoverLinkToSeries() : s(this.visualMapModel) && this._doHoverLinkToSeries(this._handleEnds[t], !1)
                }
            },
            _resetInterval: function() {
                var t = this.visualMapModel,
                    e = this._dataInterval = t.getSelected(),
                    i = t.getExtent(),
                    n = [0, t.itemSize[1]];
                this._handleEnds = [m(e[0], i, n, !0), m(e[1], i, n, !0)]
            },
            _updateInterval: function(t, e) {
                e = e || 0;
                var i = this.visualMapModel,
                    n = this._handleEnds;
                d(e, n, [0, i.itemSize[1]], "all" === t ? "rigid" : "push", t);
                var r = i.getExtent(),
                    a = [0, i.itemSize[1]];
                this._dataInterval = [m(n[0], a, r, !0), m(n[1], a, r, !0)]
            },
            _updateView: function(t) {
                var e = this.visualMapModel,
                    i = e.getExtent(),
                    n = this._shapes,
                    r = [0, e.itemSize[1]],
                    a = t ? r : this._handleEnds,
                    o = this._createBarVisual(this._dataInterval, i, a, "inRange"),
                    s = this._createBarVisual(i, i, r, "outOfRange");
                n.inRange.setStyle({
                    fill: o.barColor,
                    opacity: o.opacity
                }).setShape("points", o.barPoints), n.outOfRange.setStyle({
                    fill: s.barColor,
                    opacity: s.opacity
                }).setShape("points", s.barPoints), this._updateHandle(a, o)
            },
            _createBarVisual: function(t, e, i, n) {
                var r = {
                        forceState: n,
                        convertOpacityToAlpha: !0
                    },
                    a = this._makeColorGradient(t, r),
                    o = [this.getControllerVisual(t[0], "symbolSize", r), this.getControllerVisual(t[1], "symbolSize", r)],
                    s = this._createBarPoints(i, o);
                return {
                    barColor: new p(0, 0, 0, 1, a),
                    barPoints: s,
                    handlesColor: [a[0].color, a[a.length - 1].color]
                }
            },
            _makeColorGradient: function(t, e) {
                var i = 100,
                    n = [],
                    r = (t[1] - t[0]) / i;
                n.push({
                    color: this.getControllerVisual(t[0], "color", e),
                    offset: 0
                });
                for (var a = 1; a < i; a++) {
                    var o = t[0] + r * a;
                    if (o > t[1])
                        break;
                    n.push({
                        color: this.getControllerVisual(o, "color", e),
                        offset: a / i
                    })
                }
                return n.push({
                    color: this.getControllerVisual(t[1], "color", e),
                    offset: 1
                }), n
            },
            _createBarPoints: function(t, e) {
                var i = this.visualMapModel.itemSize;
                return [[i[0] - e[0], t[0]], [i[0], t[0]], [i[0], t[1]], [i[0] - e[1], t[1]]]
            },
            _createBarGroup: function(t) {
                var e = this._orient,
                    i = this.visualMapModel.get("inverse");
                return new c.Group("horizontal" !== e || i ? "horizontal" === e && i ? {
                    scale: "bottom" === t ? [-1, 1] : [1, 1],
                    rotation: -Math.PI / 2
                } : "vertical" !== e || i ? {
                    scale: "left" === t ? [1, 1] : [-1, 1]
                } : {
                    scale: "left" === t ? [1, -1] : [-1, -1]
                } : {
                    scale: "bottom" === t ? [1, 1] : [-1, 1],
                    rotation: Math.PI / 2
                })
            },
            _updateHandle: function(t, e) {
                if (this._useHandle) {
                    var i = this._shapes,
                        n = this.visualMapModel,
                        r = i.handleThumbs,
                        a = i.handleLabels;
                    v([0, 1], function(o) {
                        var s = r[o];
                        s.setStyle("fill", e.handlesColor[o]), s.position[1] = t[o];
                        var l = c.applyTransform(i.handleLabelPoints[o], c.getTransform(s, this.group));
                        a[o].setStyle({
                            x: l[0],
                            y: l[1],
                            text: n.formatValueText(this._dataInterval[o]),
                            textVerticalAlign: "middle",
                            textAlign: this._applyTransform("horizontal" === this._orient ? 0 === o ? "bottom" : "top" : "left", i.barGroup)
                        })
                    }, this)
                }
            },
            _showIndicator: function(t, e, i, n) {
                var r = this.visualMapModel,
                    o = r.getExtent(),
                    s = r.itemSize,
                    l = [0, s[1]],
                    u = m(t, o, l, !0),
                    h = this._shapes,
                    d = h.indicator;
                if (d) {
                    d.position[1] = u, d.attr("invisible", !1), d.setShape("points", a(!!i, n, u, s[1]));
                    var p = {
                            convertOpacityToAlpha: !0
                        },
                        f = this.getControllerVisual(t, "color", p);
                    d.setStyle("fill", f);
                    var g = c.applyTransform(h.indicatorLabelPoint, c.getTransform(d, this.group)),
                        v = h.indicatorLabel;
                    v.attr("invisible", !1);
                    var y = this._applyTransform("left", h.barGroup),
                        x = this._orient;
                    v.setStyle({
                        text: (i ? i : "") + r.formatValueText(e),
                        textVerticalAlign: "horizontal" === x ? y : "middle",
                        textAlign: "horizontal" === x ? "center" : y,
                        x: g[0],
                        y: g[1]
                    })
                }
            },
            _enableHoverLinkToSeries: function() {
                var t = this;
                this._shapes.barGroup.on("mousemove", function(e) {
                    if (t._hovering = !0, !t._dragging) {
                        var i = t.visualMapModel.itemSize,
                            n = t._applyTransform([e.offsetX, e.offsetY], t._shapes.barGroup, !0, !0);
                        n[1] = y(x(0, n[1]), i[1]), t._doHoverLinkToSeries(n[1], 0 <= n[0] && n[0] <= i[0])
                    }
                }).on("mouseout", function() {
                    t._hovering = !1, !t._dragging && t._clearHoverLinkToSeries()
                })
            },
            _enableHoverLinkFromSeries: function() {
                var t = this.api.getZr();
                this.visualMapModel.option.hoverLink ? (t.on("mouseover", this._hoverLinkFromSeriesMouseOver, this), t.on("mouseout", this._hideIndicator, this)) : this._clearHoverLinkFromSeries()
            },
            _doHoverLinkToSeries: function(t, e) {
                var i = this.visualMapModel,
                    n = i.itemSize;
                if (i.option.hoverLink) {
                    var r = [0, n[1]],
                        a = i.getExtent();
                    t = y(x(r[0], t), r[1]);
                    var l = o(i, a, r),
                        c = [t - l, t + l],
                        u = m(t, r, a, !0),
                        h = [m(c[0], r, a, !0), m(c[1], r, a, !0)];
                    c[0] < r[0] && (h[0] = -(1 / 0)), c[1] > r[1] && (h[1] = 1 / 0), e && (h[0] === -(1 / 0) ? this._showIndicator(u, h[1], "< ", l) : h[1] === 1 / 0 ? this._showIndicator(u, h[0], "> ", l) : this._showIndicator(u, u, "≈ ", l));
                    var d = this._hoverLinkDataIndices,
                        p = [];
                    (e || s(i)) && (p = this._hoverLinkDataIndices = i.findTargetDataIndices(h));
                    var v = g.compressBatches(d, p);
                    this._dispatchHighDown("downplay", f.convertDataIndex(v[0])), this._dispatchHighDown("highlight", f.convertDataIndex(v[1]))
                }
            },
            _hoverLinkFromSeriesMouseOver: function(t) {
                var e = t.target;
                if (e && null != e.dataIndex) {
                    var i = e.dataModel || this.ecModel.getSeriesByIndex(e.seriesIndex),
                        n = i.getData(e.dataType),
                        r = n.getDimension(this.visualMapModel.getDataDimension(n)),
                        a = n.get(r, e.dataIndex, !0);
                    isNaN(a) || this._showIndicator(a, a)
                }
            },
            _hideIndicator: function() {
                var t = this._shapes;
                t.indicator && t.indicator.attr("invisible", !0), t.indicatorLabel && t.indicatorLabel.attr("invisible", !0)
            },
            _clearHoverLinkToSeries: function() {
                this._hideIndicator();
                var t = this._hoverLinkDataIndices;
                this._dispatchHighDown("downplay", f.convertDataIndex(t)), t.length = 0
            },
            _clearHoverLinkFromSeries: function() {
                this._hideIndicator();
                var t = this.api.getZr();
                t.off("mouseover", this._hoverLinkFromSeriesMouseOver), t.off("mouseout", this._hideIndicator)
            },
            _applyTransform: function(t, e, i, n) {
                var r = c.getTransform(e, n ? null : this.group);
                return c[u.isArray(t) ? "applyTransform" : "transformDirection"](t, r, i)
            },
            _dispatchHighDown: function(t, e) {
                e && e.length && this.api.dispatchAction({
                    type: t,
                    batch: e
                })
            },
            dispose: function() {
                this._clearHoverLinkFromSeries(), this._clearHoverLinkToSeries()
            },
            remove: function() {
                this._clearHoverLinkFromSeries(), this._clearHoverLinkToSeries()
            }
        });
    t.exports = w
}, function(t, e, i) {
    var n = i(509),
        r = i(548),
        a = i(511),
        o = i(526),
        s = i(506),
        l = i(699);
    t.exports = s.extendComponentView({
        type: "visualMap",
        autoPositionValues: {
            left: 1,
            right: 1,
            top: 1,
            bottom: 1
        },
        init: function(t, e) {
            this.ecModel = t, this.api = e, this.visualMapModel
        },
        render: function(t, e, i, n) {
            return this.visualMapModel = t, t.get("show") === !1 ? void this.group.removeAll() : void this.doRender.apply(this, arguments)
        },
        renderBackground: function(t) {
            var e = this.visualMapModel,
                i = a.normalizeCssArray(e.get("padding") || 0),
                n = t.getBoundingRect();
            t.add(new r.Rect({
                z2: -1,
                silent: !0,
                shape: {
                    x: n.x - i[3],
                    y: n.y - i[0],
                    width: n.width + i[3] + i[1],
                    height: n.height + i[0] + i[2]
                },
                style: {
                    fill: e.get("backgroundColor"),
                    stroke: e.get("borderColor"),
                    lineWidth: e.get("borderWidth")
                }
            }))
        },
        getControllerVisual: function(t, e, i) {
            function r(t) {
                return c[t]
            }
            function a(t, e) {
                c[t] = e
            }
            i = i || {};
            var o = i.forceState,
                s = this.visualMapModel,
                c = {};
            if ("symbol" === e && (c.symbol = s.get("itemSymbol")), "color" === e) {
                var u = s.get("contentColor");
                c.color = u
            }
            var h = s.controllerVisuals[o || s.getValueState(t)],
                d = l.prepareVisualTypes(h);
            return n.each(d, function(n) {
                var o = h[n];
                i.convertOpacityToAlpha && "opacity" === n && (n = "colorAlpha", o = h.__alphaForOpacity), l.dependsOn(n, e) && o && o.applyVisual(t, r, a)
            }), c[e]
        },
        positionGroup: function(t) {
            var e = this.visualMapModel,
                i = this.api;
            o.positionElement(t, e.getBoxLayoutParams(), {
                width: i.getWidth(),
                height: i.getHeight()
            })
        },
        doRender: n.noop
    })
}, function(t, e, i) {
    var n = i(509),
        r = i(526),
        a = {
            getItemAlign: function(t, e, i) {
                var n = t.option,
                    a = n.align;
                if (null != a && "auto" !== a)
                    return a;
                for (var o = {
                        width: e.getWidth(),
                        height: e.getHeight()
                    }, s = "horizontal" === n.orient ? 1 : 0, l = [["left", "right", "width"], ["top", "bottom", "height"]], c = l[s], u = [0, null, 10], h = {}, d = 0; d < 3; d++)
                    h[l[1 - s][d]] = u[d], h[c[d]] = 2 === d ? i[0] : n[c[d]];
                var p = [["x", "width", 3], ["y", "height", 0]][s],
                    f = r.getLayoutRect(h, o, n.padding);
                return c[(f.margin[p[2]] || 0) + f[p[0]] + .5 * f[p[1]] < .5 * o[p[1]] ? 0 : 1]
            },
            convertDataIndex: function(t) {
                return n.each(t || [], function(e) {
                    null != t.dataIndex && (t.dataIndexInside = t.dataIndex, t.dataIndex = null)
                }), t
            }
        };
    t.exports = a
}, function(t, e, i) {
    var n = i(506),
        r = {
            type: "selectDataRange",
            event: "dataRangeSelected",
            update: "update"
        };
    n.registerAction(r, function(t, e) {
        e.eachComponent({
            mainType: "visualMap",
            query: t
        }, function(e) {
            e.setSelected(t.selected)
        })
    })
}, function(t, e, i) {
    i(506).registerPreprocessor(i(839)), i(840), i(841), i(850), i(851), i(848)
}, function(t, e, i) {
    function n(t, e) {
        var i = t.inverse;
        ("vertical" === t.orient ? !i : i) && e.reverse()
    }
    var r = i(843),
        a = i(509),
        o = i(699),
        s = i(844),
        l = i(512).reformIntervals,
        c = r.extend({
            type: "visualMap.piecewise",
            defaultOption: {
                selected: null,
                minOpen: !1,
                maxOpen: !1,
                align: "auto",
                itemWidth: 20,
                itemHeight: 14,
                itemSymbol: "roundRect",
                pieceList: null,
                categories: null,
                splitNumber: 5,
                selectedMode: "multiple",
                itemGap: 10,
                hoverLink: !0
            },
            optionUpdated: function(t, e) {
                c.superApply(this, "optionUpdated", arguments), this._pieceList = [], this.resetTargetSeries(), this.resetExtent();
                var i = this._mode = this._determineMode();
                u[this._mode].call(this), this._resetSelected(t, e);
                var n = this.option.categories;
                this.resetVisual(function(t, e) {
                    "categories" === i ? (t.mappingMethod = "category", t.categories = a.clone(n)) : (t.dataExtent = this.getExtent(), t.mappingMethod = "piecewise", t.pieceList = a.map(this._pieceList, function(t) {
                        var t = a.clone(t);
                        return "inRange" !== e && (t.visual = null), t
                    }))
                })
            },
            completeVisualOption: function() {
                function t(t, e, i) {
                    return t && t[e] && (a.isObject(t[e]) ? t[e].hasOwnProperty(i) : t[e] === i)
                }
                var e = this.option,
                    i = {},
                    n = o.listVisualTypes(),
                    l = this.isCategory();
                a.each(e.pieces, function(t) {
                    a.each(n, function(e) {
                        t.hasOwnProperty(e) && (i[e] = 1)
                    })
                }), a.each(i, function(i, n) {
                    var r = 0;
                    a.each(this.stateList, function(i) {
                        r |= t(e, i, n) || t(e.target, i, n)
                    }, this), !r && a.each(this.stateList, function(t) {
                        (e[t] || (e[t] = {}))[n] = s.get(n, "inRange" === t ? "active" : "inactive", l)
                    })
                }, this), r.prototype.completeVisualOption.apply(this, arguments)
            },
            _resetSelected: function(t, e) {
                var i = this.option,
                    n = this._pieceList,
                    r = (e ? i : t).selected || {};
                if (i.selected = r, a.each(n, function(t, e) {
                    var i = this.getSelectedMapKey(t);
                    r.hasOwnProperty(i) || (r[i] = !0)
                }, this), "single" === i.selectedMode) {
                    var o = !1;
                    a.each(n, function(t, e) {
                        var i = this.getSelectedMapKey(t);
                        r[i] && (o ? r[i] = !1 : o = !0)
                    }, this)
                }
            },
            getSelectedMapKey: function(t) {
                return "categories" === this._mode ? t.value + "" : t.index + ""
            },
            getPieceList: function() {
                return this._pieceList
            },
            _determineMode: function() {
                var t = this.option;
                return t.pieces && t.pieces.length > 0 ? "pieces" : this.option.categories ? "categories" : "splitNumber"
            },
            setSelected: function(t) {
                this.option.selected = a.clone(t)
            },
            getValueState: function(t) {
                var e = o.findPieceIndex(t, this._pieceList);
                return null != e && this.option.selected[this.getSelectedMapKey(this._pieceList[e])] ? "inRange" : "outOfRange"
            },
            findTargetDataIndices: function(t) {
                var e = [];
                return this.eachTargetSeries(function(i) {
                    var n = [],
                        r = i.getData();
                    r.each(this.getDataDimension(r), function(e, i) {
                        var r = o.findPieceIndex(e, this._pieceList);
                        r === t && n.push(i)
                    }, !0, this), e.push({
                        seriesId: i.id,
                        dataIndex: n
                    })
                }, this), e
            },
            getRepresentValue: function(t) {
                var e;
                if (this.isCategory())
                    e = t.value;
                else if (null != t.value)
                    e = t.value;
                else {
                    var i = t.interval || [];
                    e = i[0] === -(1 / 0) && i[1] === 1 / 0 ? 0 : (i[0] + i[1]) / 2
                }
                return e
            },
            getVisualMeta: function(t) {
                function e(e, a) {
                    var o = r.getRepresentValue({
                        interval: e
                    });
                    a || (a = r.getValueState(o));
                    var s = t(o, a);
                    e[0] === -(1 / 0) ? n[0] = s : e[1] === 1 / 0 ? n[1] = s : i.push({
                        value: e[0],
                        color: s
                    }, {
                        value: e[1],
                        color: s
                    })
                }
                if (!this.isCategory()) {
                    var i = [],
                        n = [],
                        r = this,
                        o = this._pieceList.slice();
                    if (o.length) {
                        var s = o[0].interval[0];
                        s !== -(1 / 0) && o.unshift({
                            interval: [-(1 / 0), s]
                        }), s = o[o.length - 1].interval[1], s !== 1 / 0 && o.push({
                            interval: [s, 1 / 0]
                        })
                    } else
                        o.push({
                            interval: [-(1 / 0), 1 / 0]
                        });
                    var l = -(1 / 0);
                    return a.each(o, function(t) {
                        var i = t.interval;
                        i && (i[0] > l && e([l, i[0]], "outOfRange"), e(i.slice()), l = i[1])
                    }, this), {
                        stops: i,
                        outerColors: n
                    }
                }
            }
        }),
        u = {
            splitNumber: function() {
                var t = this.option,
                    e = this._pieceList,
                    i = t.precision,
                    n = this.getExtent(),
                    r = t.splitNumber;
                r = Math.max(parseInt(r, 10), 1), t.splitNumber = r;
                for (var o = (n[1] - n[0]) / r; +o.toFixed(i) !== o && i < 5;)
                    i++;
                t.precision = i, o = +o.toFixed(i);
                var s = 0;
                t.minOpen && e.push({
                    index: s++,
                    interval: [-(1 / 0), n[0]],
                    close: [0, 0]
                });
                for (var c = n[0], u = s + r; s < u; c += o) {
                    var h = s === r - 1 ? n[1] : c + o;
                    e.push({
                        index: s++,
                        interval: [c, h],
                        close: [1, 1]
                    })
                }
                t.maxOpen && e.push({
                    index: s++,
                    interval: [n[1], 1 / 0],
                    close: [0, 0]
                }), l(e), a.each(e, function(t) {
                    t.text = this.formatValueText(t.interval)
                }, this)
            },
            categories: function() {
                var t = this.option;
                a.each(t.categories, function(t) {
                    this._pieceList.push({
                        text: this.formatValueText(t, !0),
                        value: t
                    })
                }, this), n(t, this._pieceList)
            },
            pieces: function() {
                var t = this.option,
                    e = this._pieceList;
                a.each(t.pieces, function(t, i) {
                    a.isObject(t) || (t = {
                        value: t
                    });
                    var n = {
                        text: "",
                        index: i
                    };
                    if (null != t.label && (n.text = t.label), t.hasOwnProperty("value")) {
                        var r = n.value = t.value;
                        n.interval = [r, r], n.close = [1, 1]
                    } else {
                        for (var s = n.interval = [], l = n.close = [0, 0], c = [1, 0, 1], u = [-(1 / 0), 1 / 0], h = [], d = 0; d < 2; d++) {
                            for (var p = [["gte", "gt", "min"], ["lte", "lt", "max"]][d], f = 0; f < 3 && null == s[d]; f++)
                                s[d] = t[p[f]], l[d] = c[f], h[d] = 2 === f;
                            null == s[d] && (s[d] = u[d])
                        }
                        h[0] && s[1] === 1 / 0 && (l[0] = 0), h[1] && s[0] === -(1 / 0) && (l[1] = 0), __DEV__ && s[0] > s[1] && console.warn("Piece " + i + "is illegal: " + s + " lower bound should not greater then uppper bound."), s[0] === s[1] && l[0] && l[1] && (n.value = s[0])
                    }
                    n.visual = o.retrieveVisuals(t), e.push(n)
                }, this), n(t, e), l(e), a.each(e, function(t) {
                    var e = t.close,
                        i = [["<", "≤"][e[1]], [">", "≥"][e[0]]];
                    t.text = t.text || this.formatValueText(null != t.value ? t.value : t.interval, !1, i)
                }, this)
            }
        };
    t.exports = c
}, function(t, e, i) {
    var n = i(846),
        r = i(509),
        a = i(548),
        o = i(612),
        s = i(526),
        l = i(847),
        c = n.extend({
            type: "visualMap.piecewise",
            doRender: function() {
                function t(t) {
                    var o = t.piece,
                        s = new a.Group;
                    s.onclick = r.bind(this._onItemClick, this, o), this._enableHoverLink(s, t.indexInModelPieceList);
                    var d = i.getRepresentValue(o);
                    if (this._createItemSymbol(s, d, [0, 0, h[0], h[1]]), p) {
                        var f = this.visualMapModel.getValueState(d);
                        s.add(new a.Text({
                            style: {
                                x: "right" === u ? -n : h[0] + n,
                                y: h[1] / 2,
                                text: o.text,
                                textVerticalAlign: "middle",
                                textAlign: u,
                                textFont: l,
                                fill: c,
                                opacity: "outOfRange" === f ? .5 : 1
                            }
                        }))
                    }
                    e.add(s)
                }
                var e = this.group;
                e.removeAll();
                var i = this.visualMapModel,
                    n = i.get("textGap"),
                    o = i.textStyleModel,
                    l = o.getFont(),
                    c = o.getTextColor(),
                    u = this._getItemAlign(),
                    h = i.itemSize,
                    d = this._getViewData(),
                    p = !d.endsText,
                    f = !p;
                f && this._renderEndsText(e, d.endsText[0], h), r.each(d.viewPieceList, t, this), f && this._renderEndsText(e, d.endsText[1], h), s.box(i.get("orient"), e, i.get("itemGap")), this.renderBackground(e), this.positionGroup(e)
            },
            _enableHoverLink: function(t, e) {
                function i(t) {
                    var i = this.visualMapModel;
                    i.option.hoverLink && this.api.dispatchAction({
                        type: t,
                        batch: l.convertDataIndex(i.findTargetDataIndices(e))
                    })
                }
                t.on("mouseover", r.bind(i, this, "highlight")).on("mouseout", r.bind(i, this, "downplay"))
            },
            _getItemAlign: function() {
                var t = this.visualMapModel,
                    e = t.option;
                if ("vertical" === e.orient)
                    return l.getItemAlign(t, this.api, t.itemSize);
                var i = e.align;
                return i && "auto" !== i || (i = "left"), i
            },
            _renderEndsText: function(t, e, i) {
                if (e) {
                    var n = new a.Group,
                        r = this.visualMapModel.textStyleModel;
                    n.add(new a.Text({
                        style: {
                            x: i[0] / 2,
                            y: i[1] / 2,
                            textVerticalAlign: "middle",
                            textAlign: "center",
                            text: e,
                            textFont: r.getFont(),
                            fill: r.getTextColor()
                        }
                    })), t.add(n)
                }
            },
            _getViewData: function() {
                var t = this.visualMapModel,
                    e = r.map(t.getPieceList(), function(t, e) {
                        return {
                            piece: t,
                            indexInModelPieceList: e
                        }
                    }),
                    i = t.get("text"),
                    n = t.get("orient"),
                    a = t.get("inverse");
                return ("horizontal" === n ? a : !a) ? e.reverse() : i && (i = i.slice().reverse()), {
                    viewPieceList: e,
                    endsText: i
                }
            },
            _createItemSymbol: function(t, e, i) {
                t.add(o.createSymbol(this.getControllerVisual(e, "symbol"), i[0], i[1], i[2], i[3], this.getControllerVisual(e, "color")))
            },
            _onItemClick: function(t) {
                var e = this.visualMapModel,
                    i = e.option,
                    n = r.clone(i.selected),
                    a = e.getSelectedMapKey(t);
                "single" === i.selectedMode ? (n[a] = !0, r.each(n, function(t, e) {
                    n[e] = e === a
                })) : n[a] = !n[a], this.api.dispatchAction({
                    type: "selectDataRange",
                    from: this.uid,
                    visualMapId: this.visualMapModel.id,
                    selected: n
                })
            }
        });
    t.exports = c
}, function(t, e, i) {
    i(853), i(855), i(506).registerPreprocessor(function(t) {
        t.markPoint = t.markPoint || {}
    })
}, function(t, e, i) {
    t.exports = i(854).extend({
        type: "markPoint",
        defaultOption: {
            zlevel: 0,
            z: 5,
            symbol: "pin",
            symbolSize: 50,
            tooltip: {
                trigger: "item"
            },
            label: {
                normal: {
                    show: !0,
                    position: "inside"
                },
                emphasis: {
                    show: !0
                }
            },
            itemStyle: {
                normal: {
                    borderWidth: 2
                }
            }
        }
    })
}, function(t, e, i) {
    function n(t) {
        r.defaultEmphasis(t.label, r.LABEL_OPTIONS)
    }
    var r = i(510),
        a = i(509),
        o = i(507),
        s = i(511),
        l = s.addCommas,
        c = s.encodeHTML,
        u = i(506).extendComponentModel({
            type: "marker",
            dependencies: ["series", "grid", "polar", "geo"],
            init: function(t, e, i, n) {
                if (__DEV__ && "marker" === this.type)
                    throw new Error("Marker component is abstract component. Use markLine, markPoint, markArea instead.");
                this.mergeDefaultAndTheme(t, i), this.mergeOption(t, i, n.createdBySelf, !0)
            },
            ifEnableAnimation: function() {
                if (o.node)
                    return !1;
                var t = this.__hostSeries;
                return this.getShallow("animation") && t && t.ifEnableAnimation()
            },
            mergeOption: function(t, e, i, r) {
                var o = this.constructor,
                    s = this.mainType + "Model";
                i || e.eachSeries(function(t) {
                    var i = t.get(this.mainType),
                        l = t[s];
                    return i && i.data ? (l ? l.mergeOption(i, e, !0) : (r && n(i), a.each(i.data, function(t) {
                        t instanceof Array ? (n(t[0]), n(t[1])) : n(t)
                    }), l = new o(i, this, e), a.extend(l, {
                        mainType: this.mainType,
                        seriesIndex: t.seriesIndex,
                        name: t.name,
                        createdBySelf: !0
                    }), l.__hostSeries = t), void (t[s] = l)) : void (t[s] = null)
                }, this)
            },
            formatTooltip: function(t) {
                var e = this.getData(),
                    i = this.getRawValue(t),
                    n = a.isArray(i) ? a.map(i, l).join(", ") : l(i),
                    r = e.getName(t),
                    o = this.name;
                return (null != i || r) && (o += "<br />"), r && (o += c(r), null != i && (o += " : ")), null != i && (o += n), o
            },
            getData: function() {
                return this._data
            },
            setData: function(t) {
                this._data = t
            }
        });
    a.mixin(u, r.dataFormatMixin), t.exports = u
}, function(t, e, i) {
    function n(t, e, i) {
        var n = e.coordinateSystem;
        t.each(function(r) {
            var a,
                o = t.getItemModel(r),
                l = s.parsePercent(o.get("x"), i.getWidth()),
                c = s.parsePercent(o.get("y"), i.getHeight());
            if (isNaN(l) || isNaN(c)) {
                if (e.getMarkerPosition)
                    a = e.getMarkerPosition(t.getValues(t.dimensions, r));
                else if (n) {
                    var u = t.get(n.dimensions[0], r),
                        h = t.get(n.dimensions[1], r);
                    a = n.dataToPoint([u, h])
                }
            } else
                a = [l, c];
            isNaN(l) || (a[0] = l), isNaN(c) || (a[1] = c), t.setItemLayout(r, a)
        })
    }
    function r(t, e, i) {
        var n;
        n = t ? o.map(t && t.dimensions, function(t) {
            var i = e.getData().getDimensionInfo(e.coordDimToDataDim(t)[0]) || {};
            return i.name = t, i
        }) : [{
            name: "value",
            type: "float"
        }];
        var r = new l(n, i),
            a = o.map(i.get("data"), o.curry(c.dataTransform, e));
        return t && (a = o.filter(a, o.curry(c.dataFilter, t))), r.initData(a, null, t ? c.dimValueGetter : function(t) {
            return t.value
        }), r
    }
    var a = i(610),
        o = i(509),
        s = i(512),
        l = i(603),
        c = i(856);
    i(857).extend({
        type: "markPoint",
        updateLayout: function(t, e, i) {
            e.eachSeries(function(t) {
                var e = t.markPointModel;
                e && (n(e.getData(), t, i), this.markerGroupMap[t.name].updateLayout(e))
            }, this)
        },
        renderSeries: function(t, e, i, o) {
            var s = t.coordinateSystem,
                l = t.name,
                c = t.getData(),
                u = this.markerGroupMap,
                h = u[l];
            h || (h = u[l] = new a);
            var d = r(s, t, e);
            e.setData(d), n(e.getData(), t, o), d.each(function(t) {
                var i = d.getItemModel(t),
                    n = i.getShallow("symbolSize");
                "function" == typeof n && (n = n(e.getRawValue(t), e.getDataParams(t))), d.setItemVisual(t, {
                    symbolSize: n,
                    color: i.get("itemStyle.normal.color") || c.getVisual("color"),
                    symbol: i.getShallow("symbol")
                })
            }), h.updateData(d), this.group.add(h.group), d.eachItemGraphicEl(function(t) {
                t.traverse(function(t) {
                    t.dataModel = e
                })
            }), h.__keep = !0, h.group.silent = e.get("silent") || t.get("silent")
        }
    })
}, function(t, e, i) {
    function n(t) {
        return !(isNaN(parseFloat(t.x)) && isNaN(parseFloat(t.y)))
    }
    function r(t) {
        return !isNaN(parseFloat(t.x)) && !isNaN(parseFloat(t.y))
    }
    function a(t, e, i) {
        var n = -1;
        do n = Math.max(l.getPrecision(t.get(e, i)), n), t = t.stackedOn;
        while (t);
        return n
    }
    function o(t, e, i, n, r, o) {
        var s = [],
            l = m(e, n, t),
            c = e.indexOfNearest(n, l, !0);
        s[r] = e.get(i, c, !0), s[o] = e.get(n, c, !0);
        var u = a(e, n, c);
        return u >= 0 && (s[o] = +s[o].toFixed(u)), s
    }
    var s = i(509),
        l = i(512),
        c = s.indexOf,
        u = s.curry,
        h = {
            min: u(o, "min"),
            max: u(o, "max"),
            average: u(o, "average")
        },
        d = function(t, e) {
            var i = t.getData(),
                n = t.coordinateSystem;
            if (e && !r(e) && !s.isArray(e.coord) && n) {
                var a = n.dimensions,
                    o = p(e, i, n, t);
                if (e = s.clone(e), e.type && h[e.type] && o.baseAxis && o.valueAxis) {
                    var l = c(a, o.baseAxis.dim),
                        u = c(a, o.valueAxis.dim);
                    e.coord = h[e.type](i, o.baseDataDim, o.valueDataDim, l, u),
                    e.value = e.coord[u]
                } else {
                    for (var d = [null != e.xAxis ? e.xAxis : e.radiusAxis, null != e.yAxis ? e.yAxis : e.angleAxis], f = 0; f < 2; f++)
                        if (h[d[f]]) {
                            var g = t.coordDimToDataDim(a[f])[0];
                            d[f] = m(i, g, d[f])
                        }
                    e.coord = d
                }
            }
            return e
        },
        p = function(t, e, i, n) {
            var r = {};
            return null != t.valueIndex || null != t.valueDim ? (r.valueDataDim = null != t.valueIndex ? e.getDimension(t.valueIndex) : t.valueDim, r.valueAxis = i.getAxis(n.dataDimToCoordDim(r.valueDataDim)), r.baseAxis = i.getOtherAxis(r.valueAxis), r.baseDataDim = n.coordDimToDataDim(r.baseAxis.dim)[0]) : (r.baseAxis = n.getBaseAxis(), r.valueAxis = i.getOtherAxis(r.baseAxis), r.baseDataDim = n.coordDimToDataDim(r.baseAxis.dim)[0], r.valueDataDim = n.coordDimToDataDim(r.valueAxis.dim)[0]), r
        },
        f = function(t, e) {
            return !(t && t.containData && e.coord && !n(e)) || t.containData(e.coord)
        },
        g = function(t, e, i, n) {
            return n < 2 ? t.coord && t.coord[n] : t.value
        },
        m = function(t, e, i) {
            if ("average" === i) {
                var n = 0,
                    r = 0;
                return t.each(e, function(t, e) {
                    isNaN(t) || (n += t, r++)
                }, !0), n / r
            }
            return t.getDataExtent(e, !0)["max" === i ? 1 : 0]
        };
    t.exports = {
        dataTransform: d,
        dataFilter: f,
        dimValueGetter: g,
        getAxisInfo: p,
        numCalculate: m
    }
}, function(t, e, i) {
    t.exports = i(506).extendComponentView({
        type: "marker",
        init: function() {
            this.markerGroupMap = {}
        },
        render: function(t, e, i) {
            var n = this.markerGroupMap;
            for (var r in n)
                n.hasOwnProperty(r) && (n[r].__keep = !1);
            var a = this.type + "Model";
            e.eachSeries(function(t) {
                var n = t[a];
                n && this.renderSeries(t, n, e, i)
            }, this);
            for (var r in n)
                n.hasOwnProperty(r) && !n[r].__keep && this.group.remove(n[r].group)
        },
        renderSeries: function() {}
    })
}, function(t, e, i) {
    i(859), i(860), i(506).registerPreprocessor(function(t) {
        t.markLine = t.markLine || {}
    })
}, function(t, e, i) {
    t.exports = i(854).extend({
        type: "markLine",
        defaultOption: {
            zlevel: 0,
            z: 5,
            symbol: ["circle", "arrow"],
            symbolSize: [8, 16],
            precision: 2,
            tooltip: {
                trigger: "item"
            },
            label: {
                normal: {
                    show: !0,
                    position: "end"
                },
                emphasis: {
                    show: !0
                }
            },
            lineStyle: {
                normal: {
                    type: "dashed"
                },
                emphasis: {
                    width: 3
                }
            },
            animationEasing: "linear"
        }
    })
}, function(t, e, i) {
    function n(t) {
        return !isNaN(t) && !isFinite(t)
    }
    function r(t, e, i, r) {
        var a = 1 - t,
            o = r.dimensions[t];
        return n(e[a]) && n(i[a]) && e[t] === i[t] && r.getAxis(o).containData(e[t])
    }
    function a(t, e) {
        if ("cartesian2d" === t.type) {
            var i = e[0].coord,
                n = e[1].coord;
            if (i && n && (r(1, i, n, t) || r(0, i, n, t)))
                return !0
        }
        return h.dataFilter(t, e[0]) && h.dataFilter(t, e[1])
    }
    function o(t, e, i, r, a) {
        var o,
            s = r.coordinateSystem,
            l = t.getItemModel(e),
            c = u.parsePercent(l.get("x"), a.getWidth()),
            h = u.parsePercent(l.get("y"), a.getHeight());
        if (isNaN(c) || isNaN(h)) {
            if (r.getMarkerPosition)
                o = r.getMarkerPosition(t.getValues(t.dimensions, e));
            else {
                var d = s.dimensions,
                    p = t.get(d[0], e),
                    f = t.get(d[1], e);
                o = s.dataToPoint([p, f])
            }
            if ("cartesian2d" === s.type) {
                var g = s.getAxis("x"),
                    m = s.getAxis("y"),
                    d = s.dimensions;
                n(t.get(d[0], e)) ? o[0] = g.toGlobalCoord(g.getExtent()[i ? 0 : 1]) : n(t.get(d[1], e)) && (o[1] = m.toGlobalCoord(m.getExtent()[i ? 0 : 1]))
            }
            isNaN(c) || (o[0] = c), isNaN(h) || (o[1] = h)
        } else
            o = [c, h];
        t.setItemLayout(e, o)
    }
    function s(t, e, i) {
        var n;
        n = t ? l.map(t && t.dimensions, function(t) {
            var i = e.getData().getDimensionInfo(e.coordDimToDataDim(t)[0]) || {};
            return i.name = t, i
        }) : [{
            name: "value",
            type: "float"
        }];
        var r = new c(n, i),
            o = new c(n, i),
            s = new c([], i),
            u = l.map(i.get("data"), l.curry(p, e, t, i));
        t && (u = l.filter(u, l.curry(a, t)));
        var d = t ? h.dimValueGetter : function(t) {
            return t.value
        };
        return r.initData(l.map(u, function(t) {
            return t[0]
        }), null, d), o.initData(l.map(u, function(t) {
            return t[1]
        }), null, d), s.initData(l.map(u, function(t) {
            return t[2]
        })), s.hasItemOption = !0, {
            from: r,
            to: o,
            line: s
        }
    }
    var l = i(509),
        c = i(603),
        u = i(512),
        h = i(856),
        d = i(706),
        p = function(t, e, i, n) {
            var r = t.getData(),
                a = n.type;
            if (!l.isArray(n) && ("min" === a || "max" === a || "average" === a || null != n.xAxis || null != n.yAxis)) {
                var o,
                    s,
                    c;
                if (null != n.yAxis || null != n.xAxis)
                    s = null != n.yAxis ? "y" : "x", o = e.getAxis(s), c = l.retrieve(n.yAxis, n.xAxis);
                else {
                    var u = h.getAxisInfo(n, r, e, t);
                    s = u.valueDataDim, o = u.valueAxis, c = h.numCalculate(r, s, a)
                }
                var d = "x" === s ? 0 : 1,
                    p = 1 - d,
                    f = l.clone(n),
                    g = {};
                f.type = null, f.coord = [], g.coord = [], f.coord[p] = -(1 / 0), g.coord[p] = 1 / 0;
                var m = i.get("precision");
                m >= 0 && "number" == typeof c && (c = +c.toFixed(m)), f.coord[d] = g.coord[d] = c, n = [f, g, {
                    type: a,
                    valueIndex: n.valueIndex,
                    value: c
                }]
            }
            return n = [h.dataTransform(t, n[0]), h.dataTransform(t, n[1]), l.extend({}, n[2])], n[2].type = n[2].type || "", l.merge(n[2], n[0]), l.merge(n[2], n[1]), n
        };
    i(857).extend({
        type: "markLine",
        updateLayout: function(t, e, i) {
            e.eachSeries(function(t) {
                var e = t.markLineModel;
                if (e) {
                    var n = e.getData(),
                        r = e.__from,
                        a = e.__to;
                    r.each(function(e) {
                        o(r, e, !0, t, i), o(a, e, !1, t, i)
                    }), n.each(function(t) {
                        n.setItemLayout(t, [r.getItemLayout(t), a.getItemLayout(t)])
                    }), this.markerGroupMap[t.name].updateLayout()
                }
            }, this)
        },
        renderSeries: function(t, e, i, n) {
            function r(e, i, r) {
                var a = e.getItemModel(i);
                o(e, i, r, t, n), e.setItemVisual(i, {
                    symbolSize: a.get("symbolSize") || x[r ? 0 : 1],
                    symbol: a.get("symbol", !0) || y[r ? 0 : 1],
                    color: a.get("itemStyle.normal.color") || u.getVisual("color")
                })
            }
            var a = t.coordinateSystem,
                c = t.name,
                u = t.getData(),
                h = this.markerGroupMap,
                p = h[c];
            p || (p = h[c] = new d), this.group.add(p.group);
            var f = s(a, t, e),
                g = f.from,
                m = f.to,
                v = f.line;
            e.__from = g, e.__to = m, e.setData(v);
            var y = e.get("symbol"),
                x = e.get("symbolSize");
            l.isArray(y) || (y = [y, y]), "number" == typeof x && (x = [x, x]), f.from.each(function(t) {
                r(g, t, !0), r(m, t, !1)
            }), v.each(function(t) {
                var e = v.getItemModel(t).get("lineStyle.normal.color");
                v.setItemVisual(t, {
                    color: e || g.getItemVisual(t, "color")
                }), v.setItemLayout(t, [g.getItemLayout(t), m.getItemLayout(t)]), v.setItemVisual(t, {
                    fromSymbolSize: g.getItemVisual(t, "symbolSize"),
                    fromSymbol: g.getItemVisual(t, "symbol"),
                    toSymbolSize: m.getItemVisual(t, "symbolSize"),
                    toSymbol: m.getItemVisual(t, "symbol")
                })
            }), p.updateData(v), f.line.eachItemGraphicEl(function(t, i) {
                t.traverse(function(t) {
                    t.dataModel = e
                })
            }), p.__keep = !0, p.group.silent = e.get("silent") || t.get("silent")
        }
    })
}, function(t, e, i) {
    i(862), i(863), i(506).registerPreprocessor(function(t) {
        t.markArea = t.markArea || {}
    })
}, function(t, e, i) {
    t.exports = i(854).extend({
        type: "markArea",
        defaultOption: {
            zlevel: 0,
            z: 1,
            tooltip: {
                trigger: "item"
            },
            animation: !1,
            label: {
                normal: {
                    show: !0,
                    position: "top"
                },
                emphasis: {
                    show: !0,
                    position: "top"
                }
            },
            itemStyle: {
                normal: {
                    borderWidth: 0
                }
            }
        }
    })
}, function(t, e, i) {
    function n(t) {
        return !isNaN(t) && !isFinite(t)
    }
    function r(t, e, i, r) {
        var a = 1 - t;
        return n(e[a]) && n(i[a])
    }
    function a(t, e) {
        var i = e.coord[0],
            n = e.coord[1];
        return !("cartesian2d" !== t.type || !i || !n || !r(1, i, n, t) && !r(0, i, n, t)) || (p.dataFilter(t, {
                coord: i,
                x: e.x0,
                y: e.y0
            }) || p.dataFilter(t, {
                coord: n,
                x: e.x1,
                y: e.y1
            }))
    }
    function o(t, e, i, r, a) {
        var o,
            s = r.coordinateSystem,
            l = t.getItemModel(e),
            c = u.parsePercent(l.get(i[0]), a.getWidth()),
            h = u.parsePercent(l.get(i[1]), a.getHeight());
        if (isNaN(c) || isNaN(h)) {
            if (r.getMarkerPosition)
                o = r.getMarkerPosition(t.getValues(i, e));
            else {
                var d = t.get(i[0], e),
                    p = t.get(i[1], e);
                o = s.dataToPoint([d, p], !0)
            }
            if ("cartesian2d" === s.type) {
                var f = s.getAxis("x"),
                    g = s.getAxis("y"),
                    d = t.get(i[0], e),
                    p = t.get(i[1], e);
                n(d) ? o[0] = f.toGlobalCoord(f.getExtent()["x0" === i[0] ? 0 : 1]) : n(p) && (o[1] = g.toGlobalCoord(g.getExtent()["y0" === i[1] ? 0 : 1]))
            }
            isNaN(c) || (o[0] = c), isNaN(h) || (o[1] = h)
        } else
            o = [c, h];
        return o
    }
    function s(t, e, i) {
        var n,
            r,
            o = ["x0", "y0", "x1", "y1"];
        t ? (n = l.map(t && t.dimensions, function(t) {
            var i = e.getData().getDimensionInfo(e.coordDimToDataDim(t)[0]) || {};
            return i.name = t, i
        }), r = new c(l.map(o, function(t, e) {
            return {
                name: t,
                type: n[e % 2].type
            }
        }), i)) : (n = [{
            name: "value",
            type: "float"
        }], r = new c(n, i));
        var s = l.map(i.get("data"), l.curry(f, e, t, i));
        t && (s = l.filter(s, l.curry(a, t)));
        var u = t ? function(t, e, i, n) {
            return t.coord[Math.floor(n / 2)][n % 2]
        } : function(t) {
            return t.value
        };
        return r.initData(s, null, u), r.hasItemOption = !0, r
    }
    var l = i(509),
        c = i(603),
        u = i(512),
        h = i(548),
        d = i(544),
        p = i(856),
        f = function(t, e, i, n) {
            var r = p.dataTransform(t, n[0]),
                a = p.dataTransform(t, n[1]),
                o = l.retrieve,
                s = r.coord,
                c = a.coord;
            s[0] = o(s[0], -(1 / 0)), s[1] = o(s[1], -(1 / 0)), c[0] = o(c[0], 1 / 0), c[1] = o(c[1], 1 / 0);
            var u = l.mergeAll([{}, r, a]);
            return u.coord = [r.coord, a.coord], u.x0 = r.x, u.y0 = r.y, u.x1 = a.x, u.y1 = a.y, u
        },
        g = [["x0", "y0"], ["x1", "y0"], ["x1", "y1"], ["x0", "y1"]];
    i(857).extend({
        type: "markArea",
        updateLayout: function(t, e, i) {
            e.eachSeries(function(t) {
                var e = t.markAreaModel;
                if (e) {
                    var n = e.getData();
                    n.each(function(e) {
                        var r = l.map(g, function(r) {
                            return o(n, e, r, t, i)
                        });
                        n.setItemLayout(e, r);
                        var a = n.getItemGraphicEl(e);
                        a.setShape("points", r)
                    })
                }
            }, this)
        },
        renderSeries: function(t, e, i, n) {
            var r = t.coordinateSystem,
                a = t.name,
                c = t.getData(),
                u = this.markerGroupMap,
                p = u[a];
            p || (p = u[a] = {
                group: new h.Group
            }), this.group.add(p.group), p.__keep = !0;
            var f = s(r, t, e);
            e.setData(f), f.each(function(e) {
                f.setItemLayout(e, l.map(g, function(i) {
                    return o(f, e, i, t, n)
                })), f.setItemVisual(e, {
                    color: c.getVisual("color")
                })
            }), f.diff(p.__data).add(function(t) {
                var e = new h.Polygon({
                    shape: {
                        points: f.getItemLayout(t)
                    }
                });
                f.setItemGraphicEl(t, e), p.group.add(e)
            }).update(function(t, i) {
                var n = p.__data.getItemGraphicEl(i);
                h.updateProps(n, {
                    shape: {
                        points: f.getItemLayout(t)
                    }
                }, e, t), p.group.add(n), f.setItemGraphicEl(t, n)
            }).remove(function(t) {
                var e = p.__data.getItemGraphicEl(t);
                p.group.remove(e)
            }).execute(), f.eachItemGraphicEl(function(t, i) {
                var n = f.getItemModel(i),
                    r = n.getModel("label.normal"),
                    a = n.getModel("label.emphasis"),
                    o = f.getItemVisual(i, "color");
                t.useStyle(l.defaults(n.getModel("itemStyle.normal").getItemStyle(), {
                    fill: d.modifyAlpha(o, .4),
                    stroke: o
                })), t.hoverStyle = n.getModel("itemStyle.normal").getItemStyle();
                var s = f.getName(i) || "",
                    c = o || t.style.fill;
                h.setText(t.style, r, c), t.style.text = l.retrieve(e.getFormattedLabel(i, "normal"), s), h.setText(t.hoverStyle, a, c), t.hoverStyle.text = l.retrieve(e.getFormattedLabel(i, "emphasis"), s), h.setHoverStyle(t, {}), t.dataModel = e
            }), p.__data = f, p.group.silent = e.get("silent") || t.get("silent")
        }
    })
}, function(t, e, i) {
    var n = i(506);
    n.registerPreprocessor(i(865)), i(866), i(867), i(868), i(870)
}, function(t, e, i) {
    function n(t) {
        var e = t.type,
            i = {
                number: "value",
                time: "time"
            };
        if (i[e] && (t.axisType = i[e], delete t.type), r(t), a(t, "controlPosition")) {
            var n = t.controlStyle || (t.controlStyle = {});
            a(n, "position") || (n.position = t.controlPosition), "none" !== n.position || a(n, "show") || (n.show = !1, delete n.position), delete t.controlPosition
        }
        o.each(t.data || [], function(t) {
            o.isObject(t) && !o.isArray(t) && (!a(t, "value") && a(t, "name") && (t.value = t.name), r(t))
        })
    }
    function r(t) {
        var e = t.itemStyle || (t.itemStyle = {}),
            i = e.emphasis || (e.emphasis = {}),
            n = t.label || t.label || {},
            r = n.normal || (n.normal = {}),
            s = {
                normal: 1,
                emphasis: 1
            };
        o.each(n, function(t, e) {
            s[e] || a(r, e) || (r[e] = t)
        }), i.label && !a(n, "emphasis") && (n.emphasis = i.label, delete i.label)
    }
    function a(t, e) {
        return t.hasOwnProperty(e)
    }
    var o = i(509);
    t.exports = function(t) {
        var e = t && t.timeline;
        o.isArray(e) || (e = e ? [e] : []), o.each(e, function(t) {
            t && n(t)
        })
    }
}, function(t, e, i) {
    i(524).registerSubTypeDefaulter("timeline", function() {
        return "slider"
    })
}, function(t, e, i) {
    var n = i(506),
        r = i(509);
    n.registerAction({
        type: "timelineChange",
        event: "timelineChanged",
        update: "prepareAndUpdate"
    }, function(t, e) {
        var i = e.getComponent("timeline");
        return i && null != t.currentIndex && (i.setCurrentIndex(t.currentIndex), !i.get("loop", !0) && i.isIndexMax() && i.setPlayState(!1)), e.resetOption("timeline"), r.defaults({
            currentIndex: i.option.currentIndex
        }, t)
    }), n.registerAction({
        type: "timelinePlayChange",
        event: "timelinePlayChanged",
        update: "update"
    }, function(t, e) {
        var i = e.getComponent("timeline");
        i && null != t.playState && i.setPlayState(t.playState)
    })
}, function(t, e, i) {
    var n = i(869),
        r = i(509),
        a = i(510),
        o = n.extend({
            type: "timeline.slider",
            defaultOption: {
                backgroundColor: "rgba(0,0,0,0)",
                borderColor: "#ccc",
                borderWidth: 0,
                orient: "horizontal",
                inverse: !1,
                tooltip: {
                    trigger: "item"
                },
                symbol: "emptyCircle",
                symbolSize: 10,
                lineStyle: {
                    show: !0,
                    width: 2,
                    color: "#304654"
                },
                label: {
                    position: "auto",
                    normal: {
                        show: !0,
                        interval: "auto",
                        rotate: 0,
                        textStyle: {
                            color: "#304654"
                        }
                    },
                    emphasis: {
                        show: !0,
                        textStyle: {
                            color: "#c23531"
                        }
                    }
                },
                itemStyle: {
                    normal: {
                        color: "#304654",
                        borderWidth: 1
                    },
                    emphasis: {
                        color: "#c23531"
                    }
                },
                checkpointStyle: {
                    symbol: "circle",
                    symbolSize: 13,
                    color: "#c23531",
                    borderWidth: 5,
                    borderColor: "rgba(194,53,49, 0.5)",
                    animation: !0,
                    animationDuration: 300,
                    animationEasing: "quinticInOut"
                },
                controlStyle: {
                    show: !0,
                    showPlayBtn: !0,
                    showPrevBtn: !0,
                    showNextBtn: !0,
                    itemSize: 22,
                    itemGap: 12,
                    position: "left",
                    playIcon: "path://M31.6,53C17.5,53,6,41.5,6,27.4S17.5,1.8,31.6,1.8C45.7,1.8,57.2,13.3,57.2,27.4S45.7,53,31.6,53z M31.6,3.3 C18.4,3.3,7.5,14.1,7.5,27.4c0,13.3,10.8,24.1,24.1,24.1C44.9,51.5,55.7,40.7,55.7,27.4C55.7,14.1,44.9,3.3,31.6,3.3z M24.9,21.3 c0-2.2,1.6-3.1,3.5-2l10.5,6.1c1.899,1.1,1.899,2.9,0,4l-10.5,6.1c-1.9,1.1-3.5,0.2-3.5-2V21.3z",
                    stopIcon: "path://M30.9,53.2C16.8,53.2,5.3,41.7,5.3,27.6S16.8,2,30.9,2C45,2,56.4,13.5,56.4,27.6S45,53.2,30.9,53.2z M30.9,3.5C17.6,3.5,6.8,14.4,6.8,27.6c0,13.3,10.8,24.1,24.101,24.1C44.2,51.7,55,40.9,55,27.6C54.9,14.4,44.1,3.5,30.9,3.5z M36.9,35.8c0,0.601-0.4,1-0.9,1h-1.3c-0.5,0-0.9-0.399-0.9-1V19.5c0-0.6,0.4-1,0.9-1H36c0.5,0,0.9,0.4,0.9,1V35.8z M27.8,35.8 c0,0.601-0.4,1-0.9,1h-1.3c-0.5,0-0.9-0.399-0.9-1V19.5c0-0.6,0.4-1,0.9-1H27c0.5,0,0.9,0.4,0.9,1L27.8,35.8L27.8,35.8z",
                    nextIcon: "path://M18.6,50.8l22.5-22.5c0.2-0.2,0.3-0.4,0.3-0.7c0-0.3-0.1-0.5-0.3-0.7L18.7,4.4c-0.1-0.1-0.2-0.3-0.2-0.5 c0-0.4,0.3-0.8,0.8-0.8c0.2,0,0.5,0.1,0.6,0.3l23.5,23.5l0,0c0.2,0.2,0.3,0.4,0.3,0.7c0,0.3-0.1,0.5-0.3,0.7l-0.1,0.1L19.7,52 c-0.1,0.1-0.3,0.2-0.5,0.2c-0.4,0-0.8-0.3-0.8-0.8C18.4,51.2,18.5,51,18.6,50.8z",
                    prevIcon: "path://M43,52.8L20.4,30.3c-0.2-0.2-0.3-0.4-0.3-0.7c0-0.3,0.1-0.5,0.3-0.7L42.9,6.4c0.1-0.1,0.2-0.3,0.2-0.5 c0-0.4-0.3-0.8-0.8-0.8c-0.2,0-0.5,0.1-0.6,0.3L18.3,28.8l0,0c-0.2,0.2-0.3,0.4-0.3,0.7c0,0.3,0.1,0.5,0.3,0.7l0.1,0.1L41.9,54 c0.1,0.1,0.3,0.2,0.5,0.2c0.4,0,0.8-0.3,0.8-0.8C43.2,53.2,43.1,53,43,52.8z",
                    normal: {
                        color: "#304654",
                        borderColor: "#304654",
                        borderWidth: 1
                    },
                    emphasis: {
                        color: "#c23531",
                        borderColor: "#c23531",
                        borderWidth: 2
                    }
                },
                data: []
            }
        });
    r.mixin(o, a.dataFormatMixin), t.exports = o
}, function(t, e, i) {
    var n = i(524),
        r = i(603),
        a = i(509),
        o = i(510),
        s = n.extend({
            type: "timeline",
            layoutMode: "box",
            defaultOption: {
                zlevel: 0,
                z: 4,
                show: !0,
                axisType: "time",
                realtime: !0,
                left: "20%",
                top: null,
                right: "20%",
                bottom: 0,
                width: null,
                height: 40,
                padding: 5,
                controlPosition: "left",
                autoPlay: !1,
                rewind: !1,
                loop: !0,
                playInterval: 2e3,
                currentIndex: 0,
                itemStyle: {
                    normal: {},
                    emphasis: {}
                },
                label: {
                    normal: {
                        textStyle: {
                            color: "#000"
                        }
                    },
                    emphasis: {}
                },
                data: []
            },
            init: function(t, e, i) {
                this._data, this._names, this.mergeDefaultAndTheme(t, i), this._initData()
            },
            mergeOption: function(t) {
                s.superApply(this, "mergeOption", arguments), this._initData()
            },
            setCurrentIndex: function(t) {
                null == t && (t = this.option.currentIndex);
                var e = this._data.count();
                this.option.loop ? t = (t % e + e) % e : (t >= e && (t = e - 1), t < 0 && (t = 0)), this.option.currentIndex = t
            },
            getCurrentIndex: function() {
                return this.option.currentIndex
            },
            isIndexMax: function() {
                return this.getCurrentIndex() >= this._data.count() - 1
            },
            setPlayState: function(t) {
                this.option.autoPlay = !!t
            },
            getPlayState: function() {
                return !!this.option.autoPlay
            },
            _initData: function() {
                var t = this.option,
                    e = t.data || [],
                    i = t.axisType,
                    n = this._names = [];
                if ("category" === i) {
                    var s = [];
                    a.each(e, function(t, e) {
                        var i,
                            r = o.getDataItemValue(t);
                        a.isObject(t) ? (i = a.clone(t), i.value = e) : i = e, s.push(i), a.isString(r) || null != r && !isNaN(r) || (r = ""), n.push(r + "")
                    }), e = s
                }
                var l = {
                        category: "ordinal",
                        time: "time"
                    }[i] || "number",
                    c = this._data = new r([{
                        name: "value",
                        type: l
                    }], this);
                c.initData(e, n)
            },
            getData: function() {
                return this._data
            },
            getCategories: function() {
                if ("category" === this.get("axisType"))
                    return this._names.slice()
            }
        });
    t.exports = s
}, function(t, e, i) {
    function n(t, e) {
        return c.getLayoutRect(t.getBoxLayoutParams(), {
            width: e.getWidth(),
            height: e.getHeight()
        }, t.get("padding"))
    }
    function r(t, e, i, n) {
        var r = l.makePath(t.get(e).replace(/^path:\/\//, ""), s.clone(n || {}), new f(i[0], i[1], i[2], i[3]), "center");
        return r
    }
    function a(t, e, i, n, r, a) {
        var o = e.get("color");
        if (r)
            r.setColor(o), i.add(r), a && a.onUpdate(r);
        else {
            var l = t.get("symbol");
            r = d.createSymbol(l, -1, -1, 2, 2, o), r.setStyle("strokeNoScale", !0), i.add(r), a && a.onCreate(r)
        }
        var c = e.getItemStyle(["color", "symbol", "symbolSize"]);
        r.setStyle(c), n = s.merge({
            rectHover: !0,
            z2: 100
        }, n, !0);
        var u = t.get("symbolSize");
        u = u instanceof Array ? u.slice() : [+u, +u], u[0] /= 2, u[1] /= 2, n.scale = u;
        var h = t.get("symbolOffset");
        if (h) {
            var p = n.position = n.position || [0, 0];
            p[0] += m.parsePercent(h[0], u[0]), p[1] += m.parsePercent(h[1], u[1])
        }
        var f = t.get("symbolRotate");
        return n.rotation = (f || 0) * Math.PI / 180 || 0, r.attr(n), r.updateTransform(), r
    }
    function o(t, e, i, n, r) {
        if (!t.dragging) {
            var a = n.getModel("checkpointStyle"),
                o = i.dataToCoord(n.getData().get(["value"], e));
            r || !a.get("animation", !0) ? t.attr({
                position: [o, 0]
            }) : (t.stopAnimation(!0), t.animateTo({
                position: [o, 0]
            }, a.get("animationDuration", !0), a.get("animationEasing", !0)))
        }
    }
    var s = i(509),
        l = i(548),
        c = i(526),
        u = i(871),
        h = i(872),
        d = i(612),
        p = i(620),
        f = i(514),
        g = i(516),
        m = i(512),
        v = i(511),
        y = v.encodeHTML,
        x = s.bind,
        _ = s.each,
        b = Math.PI;
    t.exports = u.extend({
        type: "timeline.slider",
        init: function(t, e) {
            this.api = e, this._axis, this._viewRect, this._timer, this._currentPointer, this._mainGroup, this._labelGroup
        },
        render: function(t, e, i, n) {
            if (this.model = t, this.api = i, this.ecModel = e, this.group.removeAll(), t.get("show", !0)) {
                var r = this._layout(t, i),
                    a = this._createGroup("mainGroup"),
                    o = this._createGroup("labelGroup"),
                    s = this._axis = this._createAxis(r, t);
                t.formatTooltip = function(t) {
                    return y(s.scale.getLabel(t))
                }, _(["AxisLine", "AxisTick", "Control", "CurrentPointer"], function(e) {
                    this["_render" + e](r, a, s, t)
                }, this), this._renderAxisLabel(r, o, s, t), this._position(r, t)
            }
            this._doPlayStop()
        },
        remove: function() {
            this._clearTimer(), this.group.removeAll()
        },
        dispose: function() {
            this._clearTimer()
        },
        _layout: function(t, e) {
            var i = t.get("label.normal.position"),
                r = t.get("orient"),
                a = n(t, e);
            null == i || "auto" === i ? i = "horizontal" === r ? a.y + a.height / 2 < e.getHeight() / 2 ? "-" : "+" : a.x + a.width / 2 < e.getWidth() / 2 ? "+" : "-" : isNaN(i) && (i = {
                horizontal: {
                    top: "-",
                    bottom: "+"
                },
                vertical: {
                    left: "-",
                    right: "+"
                }
            }[r][i]);
            var o = {
                    horizontal: "center",
                    vertical: i >= 0 || "+" === i ? "left" : "right"
                },
                s = {
                    horizontal: i >= 0 || "+" === i ? "top" : "bottom",
                    vertical: "middle"
                },
                l = {
                    horizontal: 0,
                    vertical: b / 2
                },
                c = "vertical" === r ? a.height : a.width,
                u = t.getModel("controlStyle"),
                h = u.get("show"),
                d = h ? u.get("itemSize") : 0,
                p = h ? u.get("itemGap") : 0,
                f = d + p,
                g = t.get("label.normal.rotate") || 0;
            g = g * b / 180;
            var m,
                v,
                y,
                x,
                _ = u.get("position", !0),
                h = u.get("show", !0),
                w = h && u.get("showPlayBtn", !0),
                M = h && u.get("showPrevBtn", !0),
                S = h && u.get("showNextBtn", !0),
                A = 0,
                I = c;
            return "left" === _ || "bottom" === _ ? (w && (m = [0, 0], A += f), M && (v = [A, 0], A += f), S && (y = [I - d, 0], I -= f)) : (w && (m = [I - d, 0], I -= f), M && (v = [0, 0], A += f), S && (y = [I - d, 0], I -= f)), x = [A, I], t.get("inverse") && x.reverse(), {
                viewRect: a,
                mainLength: c,
                orient: r,
                rotation: l[r],
                labelRotation: g,
                labelPosOpt: i,
                labelAlign: o[r],
                labelBaseline: s[r],
                playPosition: m,
                prevBtnPosition: v,
                nextBtnPosition: y,
                axisExtent: x,
                controlSize: d,
                controlGap: p
            }
        },
        _position: function(t, e) {
            function i(t) {
                var e = t.position;
                t.origin = [h[0][0] - e[0], h[1][0] - e[1]]
            }
            function n(t) {
                return [[t.x, t.x + t.width], [t.y, t.y + t.height]]
            }
            function r(t, e, i, n, r) {
                t[n] += i[n][r] - e[n][r]
            }
            var a = this._mainGroup,
                o = this._labelGroup,
                s = t.viewRect;
            if ("vertical" === t.orient) {
                var l = g.create(),
                    c = s.x,
                    u = s.y + s.height;
                g.translate(l, l, [-c, -u]), g.rotate(l, l, -b / 2), g.translate(l, l, [c, u]), s = s.clone(), s.applyTransform(l)
            }
            var h = n(s),
                d = n(a.getBoundingRect()),
                p = n(o.getBoundingRect()),
                f = a.position,
                m = o.position;
            m[0] = f[0] = h[0][0];
            var v = t.labelPosOpt;
            if (isNaN(v)) {
                var y = "+" === v ? 0 : 1;
                r(f, d, h, 1, y), r(m, p, h, 1, 1 - y)
            } else {
                var y = v >= 0 ? 0 : 1;
                r(f, d, h, 1, y), m[1] = f[1] + v
            }
            a.attr("position", f), o.attr("position", m), a.rotation = o.rotation = t.rotation, i(a), i(o)
        },
        _createAxis: function(t, e) {
            var i = e.getData(),
                n = e.get("axisType"),
                r = p.createScaleByModel(e, n),
                a = i.getDataExtent("value");
            r.setExtent(a[0], a[1]), this._customizeScale(r, i), r.niceTicks();
            var o = new h("value", r, t.axisExtent, n);
            return o.model = e, o
        },
        _customizeScale: function(t, e) {
            t.getTicks = function() {
                return e.mapArray(["value"], function(t) {
                    return t
                })
            }, t.getTicksLabels = function() {
                return s.map(this.getTicks(), t.getLabel, t)
            }
        },
        _createGroup: function(t) {
            var e = this["_" + t] = new l.Group;
            return this.group.add(e), e
        },
        _renderAxisLine: function(t, e, i, n) {
            var r = i.getExtent();
            n.get("lineStyle.show") && e.add(new l.Line({
                shape: {
                    x1: r[0],
                    y1: 0,
                    x2: r[1],
                    y2: 0
                },
                style: s.extend({
                    lineCap: "round"
                }, n.getModel("lineStyle").getLineStyle()),
                silent: !0,
                z2: 1
            }))
        },
        _renderAxisTick: function(t, e, i, n) {
            var r = n.getData(),
                o = i.scale.getTicks();
            _(o, function(t, o) {
                var s = i.dataToCoord(t),
                    c = r.getItemModel(o),
                    u = c.getModel("itemStyle.normal"),
                    h = c.getModel("itemStyle.emphasis"),
                    d = {
                        position: [s, 0],
                        onclick: x(this._changeTimeline, this, o)
                    },
                    p = a(c, u, e, d);
                l.setHoverStyle(p, h.getItemStyle()), c.get("tooltip") ? (p.dataIndex = o, p.dataModel = n) : p.dataIndex = p.dataModel = null
            }, this)
        },
        _renderAxisLabel: function(t, e, i, n) {
            var r = n.getModel("label.normal");
            if (r.get("show")) {
                var a = n.getData(),
                    o = i.scale.getTicks(),
                    s = p.getFormattedLabels(i, r.get("formatter")),
                    c = i.getLabelInterval();
                _(o, function(n, r) {
                    if (!i.isLabelIgnored(r, c)) {
                        var o = a.getItemModel(r),
                            u = o.getModel("label.normal.textStyle"),
                            h = o.getModel("label.emphasis.textStyle"),
                            d = i.dataToCoord(n),
                            p = new l.Text({
                                style: {
                                    text: s[r],
                                    textAlign: t.labelAlign,
                                    textVerticalAlign: t.labelBaseline,
                                    textFont: u.getFont(),
                                    fill: u.getTextColor()
                                },
                                position: [d, 0],
                                rotation: t.labelRotation - t.rotation,
                                onclick: x(this._changeTimeline, this, r),
                                silent: !1
                            });
                        e.add(p), l.setHoverStyle(p, h.getItemStyle())
                    }
                }, this)
            }
        },
        _renderControl: function(t, e, i, n) {
            function a(t, i, a, d) {
                if (t) {
                    var p = {
                            position: t,
                            origin: [o / 2, 0],
                            rotation: d ? -s : 0,
                            rectHover: !0,
                            style: c,
                            onclick: a
                        },
                        f = r(n, i, h, p);
                    e.add(f), l.setHoverStyle(f, u)
                }
            }
            var o = t.controlSize,
                s = t.rotation,
                c = n.getModel("controlStyle.normal").getItemStyle(),
                u = n.getModel("controlStyle.emphasis").getItemStyle(),
                h = [0, -o / 2, o, o],
                d = n.getPlayState(),
                p = n.get("inverse", !0);
            a(t.nextBtnPosition, "controlStyle.nextIcon", x(this._changeTimeline, this, p ? "-" : "+")), a(t.prevBtnPosition, "controlStyle.prevIcon", x(this._changeTimeline, this, p ? "+" : "-")), a(t.playPosition, "controlStyle." + (d ? "stopIcon" : "playIcon"), x(this._handlePlayClick, this, !d), !0)
        },
        _renderCurrentPointer: function(t, e, i, n) {
            var r = n.getData(),
                s = n.getCurrentIndex(),
                l = r.getItemModel(s).getModel("checkpointStyle"),
                c = this,
                u = {
                    onCreate: function(t) {
                        t.draggable = !0, t.drift = x(c._handlePointerDrag, c), t.ondragend = x(c._handlePointerDragend, c), o(t, s, i, n, !0)
                    },
                    onUpdate: function(t) {
                        o(t, s, i, n)
                    }
                };
            this._currentPointer = a(l, l, this._mainGroup, {}, this._currentPointer, u)
        },
        _handlePlayClick: function(t) {
            this._clearTimer(), this.api.dispatchAction({
                type: "timelinePlayChange",
                playState: t,
                from: this.uid
            })
        },
        _handlePointerDrag: function(t, e, i) {
            this._clearTimer(), this._pointerChangeTimeline([i.offsetX, i.offsetY])
        },
        _handlePointerDragend: function(t) {
            this._pointerChangeTimeline([t.offsetX, t.offsetY], !0)
        },
        _pointerChangeTimeline: function(t, e) {
            var i = this._toAxisCoord(t)[0],
                n = this._axis,
                r = m.asc(n.getExtent().slice());
            i > r[1] && (i = r[1]), i < r[0] && (i = r[0]), this._currentPointer.position[0] = i, this._currentPointer.dirty();
            var a = this._findNearestTick(i),
                o = this.model;
            (e || a !== o.getCurrentIndex() && o.get("realtime")) && this._changeTimeline(a)
        },
        _doPlayStop: function() {
            function t() {
                var t = this.model;
                this._changeTimeline(t.getCurrentIndex() + (t.get("rewind", !0) ? -1 : 1))
            }
            this._clearTimer(), this.model.getPlayState() && (this._timer = setTimeout(x(t, this), this.model.get("playInterval")))
        },
        _toAxisCoord: function(t) {
            var e = this._mainGroup.getLocalTransform();
            return l.applyTransform(t, e, !0)
        },
        _findNearestTick: function(t) {
            var e,
                i = this.model.getData(),
                n = 1 / 0,
                r = this._axis;
            return i.each(["value"], function(i, a) {
                var o = r.dataToCoord(i),
                    s = Math.abs(o - t);
                s < n && (n = s, e = a)
            }), e
        },
        _clearTimer: function() {
            this._timer && (clearTimeout(this._timer), this._timer = null)
        },
        _changeTimeline: function(t) {
            var e = this.model.getCurrentIndex();
            "+" === t ? t = e + 1 : "-" === t && (t = e - 1), this.api.dispatchAction({
                type: "timelineChange",
                currentIndex: t,
                from: this.uid
            })
        }
    })
}, function(t, e, i) {
    var n = i(534);
    t.exports = n.extend({
        type: "timeline"
    })
}, function(t, e, i) {
    var n = i(509),
        r = i(629),
        a = i(620),
        o = function(t, e, i, n) {
            r.call(this, t, e, i), this.type = n || "value", this._autoLabelInterval, this.model = null
        };
    o.prototype = {
        constructor: o,
        getLabelInterval: function() {
            var t = this.model,
                e = t.getModel("label.normal"),
                i = e.get("interval");
            if (null != i && "auto" != i)
                return i;
            var i = this._autoLabelInterval;
            return i || (i = this._autoLabelInterval = a.getAxisLabelInterval(n.map(this.scale.getTicks(), this.dataToCoord, this), a.getFormattedLabels(this, e.get("formatter")), e.getModel("textStyle").getFont(), "horizontal" === t.get("orient"))), i
        },
        isLabelIgnored: function(t) {
            if ("category" === this.type) {
                var e = this.getLabelInterval();
                return "function" == typeof e && !e(t, this.scale.getLabel(t)) || t % (e + 1)
            }
        }
    }, n.inherits(o, r), t.exports = o
}, function(t, e, i) {
    i(874), i(875), i(876), i(877), i(878), i(879), i(884)
}, function(t, e, i) {
    var n = i(821),
        r = i(509),
        a = i(506).extendComponentModel({
            type: "toolbox",
            layoutMode: {
                type: "box",
                ignoreSize: !0
            },
            mergeDefaultAndTheme: function(t) {
                a.superApply(this, "mergeDefaultAndTheme", arguments), r.each(this.option.feature, function(t, e) {
                    var i = n.get(e);
                    i && r.merge(t, i.defaultOption)
                })
            },
            defaultOption: {
                show: !0,
                z: 6,
                zlevel: 0,
                orient: "horizontal",
                left: "right",
                top: "top",
                backgroundColor: "transparent",
                borderColor: "#ccc",
                borderWidth: 0,
                padding: 5,
                itemSize: 15,
                itemGap: 8,
                showTitle: !0,
                iconStyle: {
                    normal: {
                        borderColor: "#666",
                        color: "none"
                    },
                    emphasis: {
                        borderColor: "#3E98C5"
                    }
                }
            }
        });
    t.exports = a
}, function(t, e, i) {
    (function(e) {
        function n(t) {
            return 0 === t.indexOf("my")
        }
        var r = i(821),
            a = i(509),
            o = i(548),
            s = i(517),
            l = i(604),
            c = i(785),
            u = i(513);
        t.exports = i(506).extendComponentView({
            type: "toolbox",
            render: function(t, e, i, h) {
                function d(a, o) {
                    var l,
                        c = y[a],
                        u = y[o],
                        d = m[c],
                        f = new s(d, t, t.ecModel);
                    if (c && !u) {
                        if (n(c))
                            l = {
                                model: f,
                                onclick: f.option.onclick,
                                featureName: c
                            };
                        else {
                            var g = r.get(c);
                            if (!g)
                                return;
                            l = new g(f, e, i)
                        }
                        v[c] = l
                    } else {
                        if (l = v[u], !l)
                            return;
                        l.model = f, l.ecModel = e, l.api = i
                    }
                    return !c && u ? void (l.dispose && l.dispose(e, i)) : !f.get("show") || l.unusable ? void (l.remove && l.remove(e, i)) : (p(f, l, c), f.setIconStatus = function(t, e) {
                        var i = this.option,
                            n = this.iconPaths;
                        i.iconStatus = i.iconStatus || {}, i.iconStatus[t] = e, n[t] && n[t].trigger(e)
                    }, void (l.render && l.render(f, e, i, h)))
                }
                function p(n, r, s) {
                    var l = n.getModel("iconStyle"),
                        c = r.getIcons ? r.getIcons() : n.get("icon"),
                        u = n.get("title") || {};
                    if ("string" == typeof c) {
                        var h = c,
                            d = u;
                        c = {}, u = {}, c[s] = h, u[s] = d
                    }
                    var p = n.iconPaths = {};
                    a.each(c, function(s, c) {
                        var h = l.getModel("normal").getItemStyle(),
                            d = l.getModel("emphasis").getItemStyle(),
                            m = {
                                x: -g / 2,
                                y: -g / 2,
                                width: g,
                                height: g
                            },
                            v = 0 === s.indexOf("image://") ? (m.image = s.slice(8), new o.Image({
                                style: m
                            })) : o.makePath(s.replace("path://", ""), {
                                style: h,
                                hoverStyle: d,
                                rectHover: !0
                            }, m, "center");
                        o.setHoverStyle(v), t.get("showTitle") && (v.__title = u[c], v.on("mouseover", function() {
                            var t = l.getModel("emphasis").getItemStyle();
                            v.setStyle({
                                text: u[c],
                                textPosition: t.textPosition || "bottom",
                                textFill: t.fill || t.stroke || "#000",
                                textAlign: t.textAlign || "center"
                            })
                        }).on("mouseout", function() {
                            v.setStyle({
                                textFill: null
                            })
                        })), v.trigger(n.get("iconStatus." + c) || "normal"), f.add(v), v.on("click", a.bind(r.onclick, r, e, i, c)), p[c] = v
                    })
                }
                var f = this.group;
                if (f.removeAll(), t.get("show")) {
                    var g = +t.get("itemSize"),
                        m = t.get("feature") || {},
                        v = this._features || (this._features = {}),
                        y = [];
                    a.each(m, function(t, e) {
                        y.push(e)
                    }), new l(this._featureNames || [], y).add(d).update(d).remove(a.curry(d, null)).execute(), this._featureNames = y, c.layout(f, t, i), c.addBackground(f, t), f.eachChild(function(t) {
                        var e = t.__title,
                            n = t.hoverStyle;
                        if (n && e) {
                            var r = u.getBoundingRect(e, n.font),
                                a = t.position[0] + f.position[0],
                                o = t.position[1] + f.position[1] + g,
                                s = !1;
                            o + r.height > i.getHeight() && (n.textPosition = "top", s = !0);
                            var l = s ? -5 - r.height : g + 8;
                            a + r.width / 2 > i.getWidth() ? (n.textPosition = ["100%", l], n.textAlign = "right") : a - r.width / 2 < 0 && (n.textPosition = [0, l], n.textAlign = "left")
                        }
                    })
                }
            },
            updateView: function(t, e, i, n) {
                a.each(this._features, function(t) {
                    t.updateView && t.updateView(t.model, e, i, n)
                })
            },
            updateLayout: function(t, e, i, n) {
                a.each(this._features, function(t) {
                    t.updateLayout && t.updateLayout(t.model, e, i, n)
                })
            },
            remove: function(t, e) {
                a.each(this._features, function(i) {
                    i.remove && i.remove(t, e)
                }), this.group.removeAll()
            },
            dispose: function(t, e) {
                a.each(this._features, function(i) {
                    i.dispose && i.dispose(t, e)
                })
            }
        })
    }).call(e, i(294))
}, function(t, e, i) {
    function n(t) {
        this.model = t
    }
    var r = i(507);
    n.defaultOption = {
        show: !0,
        icon: "M4.7,22.9L29.3,45.5L54.7,23.4M4.6,43.6L4.6,58L53.8,58L53.8,43.6M29.2,45.1L29.2,0",
        title: "保存为图片",
        type: "png",
        name: "",
        excludeComponents: ["toolbox"],
        pixelRatio: 1,
        lang: ["右键另存为图片"]
    }, n.prototype.unusable = !r.canvasSupported;
    var a = n.prototype;
    a.onclick = function(t, e) {
        var i = this.model,
            n = i.get("name") || t.get("title.0.text") || "echarts",
            a = document.createElement("a"),
            o = i.get("type", !0) || "png";
        a.download = n + "." + o, a.target = "_blank";
        var s = e.getConnectedDataURL({
            type: o,
            backgroundColor: i.get("backgroundColor", !0) || t.get("backgroundColor") || "#fff",
            excludeComponents: i.get("excludeComponents"),
            pixelRatio: i.get("pixelRatio")
        });
        if (a.href = s, "function" != typeof MouseEvent || r.browser.ie || r.browser.edge) {
            var l = i.get("lang"),
                c = '<body style="margin:0;"><img src="' + s + '" style="max-width:100%;" title="' + (l && l[0] || "") + '" /></body>',
                u = window.open();
            u.document.write(c)
        } else {
            var h = new MouseEvent("click", {
                view: window,
                bubbles: !0,
                cancelable: !1
            });
            a.dispatchEvent(h)
        }
    }, i(821).register("saveAsImage", n), t.exports = n
}, function(t, e, i) {
    "use strict";
    function n(t) {
        this.model = t
    }
    var r = i(509);
    n.defaultOption = {
        show: !0,
        type: [],
        icon: {
            line: "M4.1,28.9h7.1l9.3-22l7.4,38l9.7-19.7l3,12.8h14.9M4.1,58h51.4",
            bar: "M6.7,22.9h10V48h-10V22.9zM24.9,13h10v35h-10V13zM43.2,2h10v46h-10V2zM3.1,58h53.7",
            stack: "M8.2,38.4l-8.4,4.1l30.6,15.3L60,42.5l-8.1-4.1l-21.5,11L8.2,38.4z M51.9,30l-8.1,4.2l-13.4,6.9l-13.9-6.9L8.2,30l-8.4,4.2l8.4,4.2l22.2,11l21.5-11l8.1-4.2L51.9,30z M51.9,21.7l-8.1,4.2L35.7,30l-5.3,2.8L24.9,30l-8.4-4.1l-8.3-4.2l-8.4,4.2L8.2,30l8.3,4.2l13.9,6.9l13.4-6.9l8.1-4.2l8.1-4.1L51.9,21.7zM30.4,2.2L-0.2,17.5l8.4,4.1l8.3,4.2l8.4,4.2l5.5,2.7l5.3-2.7l8.1-4.2l8.1-4.2l8.1-4.1L30.4,2.2z",
            tiled: "M2.3,2.2h22.8V25H2.3V2.2z M35,2.2h22.8V25H35V2.2zM2.3,35h22.8v22.8H2.3V35z M35,35h22.8v22.8H35V35z"
        },
        title: {
            line: "切换为折线图",
            bar: "切换为柱状图",
            stack: "切换为堆叠",
            tiled: "切换为平铺"
        },
        option: {},
        seriesIndex: {}
    };
    var a = n.prototype;
    a.getIcons = function() {
        var t = this.model,
            e = t.get("icon"),
            i = {};
        return r.each(t.get("type"), function(t) {
            e[t] && (i[t] = e[t])
        }), i
    };
    var o = {
            line: function(t, e, i, n) {
                if ("bar" === t)
                    return r.merge({
                        id: e,
                        type: "line",
                        data: i.get("data"),
                        stack: i.get("stack"),
                        markPoint: i.get("markPoint"),
                        markLine: i.get("markLine")
                    }, n.get("option.line") || {}, !0)
            },
            bar: function(t, e, i, n) {
                if ("line" === t)
                    return r.merge({
                        id: e,
                        type: "bar",
                        data: i.get("data"),
                        stack: i.get("stack"),
                        markPoint: i.get("markPoint"),
                        markLine: i.get("markLine")
                    }, n.get("option.bar") || {}, !0)
            },
            stack: function(t, e, i, n) {
                if ("line" === t || "bar" === t)
                    return r.merge({
                        id: e,
                        stack: "__ec_magicType_stack__"
                    }, n.get("option.stack") || {}, !0)
            },
            tiled: function(t, e, i, n) {
                if ("line" === t || "bar" === t)
                    return r.merge({
                        id: e,
                        stack: ""
                    }, n.get("option.tiled") || {}, !0)
            }
        },
        s = [["line", "bar"], ["stack", "tiled"]];
    a.onclick = function(t, e, i) {
        var n = this.model,
            a = n.get("seriesIndex." + i);
        if (o[i]) {
            var l = {
                    series: []
                },
                c = function(e) {
                    var a = e.subType,
                        s = e.id,
                        c = o[i](a, s, e, n);
                    c && (r.defaults(c, e.option), l.series.push(c));
                    var u = e.coordinateSystem;
                    if (u && "cartesian2d" === u.type && ("line" === i || "bar" === i)) {
                        var h = u.getAxesByScale("ordinal")[0];
                        if (h) {
                            var d = h.dim,
                                p = d + "Axis",
                                f = t.queryComponents({
                                    mainType: p,
                                    index: e.get(name + "Index"),
                                    id: e.get(name + "Id")
                                })[0],
                                g = f.componentIndex;
                            l[p] = l[p] || [];
                            for (var m = 0; m <= g; m++)
                                l[p][g] = l[p][g] || {};
                            l[p][g].boundaryGap = "bar" === i
                        }
                    }
                };
            r.each(s, function(t) {
                r.indexOf(t, i) >= 0 && r.each(t, function(t) {
                    n.setIconStatus(t, "normal")
                })
            }), n.setIconStatus(i, "emphasis"), t.eachComponent({
                mainType: "series",
                query: null == a ? null : {
                    seriesIndex: a
                }
            }, c), e.dispatchAction({
                type: "changeMagicType",
                currentType: i,
                newOption: l
            })
        }
    };
    var l = i(506);
    l.registerAction({
        type: "changeMagicType",
        event: "magicTypeChanged",
        update: "prepareAndUpdate"
    }, function(t, e) {
        e.mergeOption(t.newOption)
    }), i(821).register("magicType", n), t.exports = n
}, function(t, e, i) {
    function n(t) {
        var e = {},
            i = [],
            n = [];
        return t.eachRawSeries(function(t) {
            var r = t.coordinateSystem;
            if (!r || "cartesian2d" !== r.type && "polar" !== r.type)
                i.push(t);
            else {
                var a = r.getBaseAxis();
                if ("category" === a.type) {
                    var o = a.dim + "_" + a.index;
                    e[o] || (e[o] = {
                        categoryAxis: a,
                        valueAxis: r.getOtherAxis(a),
                        series: []
                    }, n.push({
                        axisDim: a.dim,
                        axisIndex: a.index
                    })), e[o].series.push(t)
                } else
                    i.push(t)
            }
        }), {
            seriesGroupByCategoryAxis: e,
            other: i,
            meta: n
        }
    }
    function r(t) {
        var e = [];
        return f.each(t, function(t, i) {
            var n = t.categoryAxis,
                r = t.valueAxis,
                a = r.dim,
                o = [" "].concat(f.map(t.series, function(t) {
                    return t.name
                })),
                s = [n.model.getCategories()];
            f.each(t.series, function(t) {
                s.push(t.getRawData().mapArray(a, function(t) {
                    return t
                }))
            });
            for (var l = [o.join(v)], c = 0; c < s[0].length; c++) {
                for (var u = [], h = 0; h < s.length; h++)
                    u.push(s[h][c]);
                l.push(u.join(v))
            }
            e.push(l.join("\n"))
        }), e.join("\n\n" + m + "\n\n")
    }
    function a(t) {
        return f.map(t, function(t) {
            var e = t.getRawData(),
                i = [t.name],
                n = [];
            return e.each(e.dimensions, function() {
                for (var t = arguments.length, r = arguments[t - 1], a = e.getName(r), o = 0; o < t - 1; o++)
                    n[o] = arguments[o];
                i.push((a ? a + v : "") + n.join(v))
            }), i.join("\n")
        }).join("\n\n" + m + "\n\n")
    }
    function o(t) {
        var e = n(t);
        return {
            value: f.filter([r(e.seriesGroupByCategoryAxis), a(e.other)], function(t) {
                return t.replace(/[\n\t\s]/g, "")
            }).join("\n\n" + m + "\n\n"),
            meta: e.meta
        }
    }
    function s(t) {
        return t.replace(/^\s\s*/, "").replace(/\s\s*$/, "")
    }
    function l(t) {
        var e = t.slice(0, t.indexOf("\n"));
        if (e.indexOf(v) >= 0)
            return !0
    }
    function c(t) {
        for (var e = t.split(/\n+/g), i = s(e.shift()).split(y), n = [], r = f.map(i, function(t) {
                return {
                    name: t,
                    data: []
                }
            }), a = 0; a < e.length; a++) {
            var o = s(e[a]).split(y);
            n.push(o.shift());
            for (var l = 0; l < o.length; l++)
                r[l] && (r[l].data[a] = o[l])
        }
        return {
            series: r,
            categories: n
        }
    }
    function u(t) {
        for (var e = t.split(/\n+/g), i = s(e.shift()), n = [], r = 0; r < e.length; r++) {
            var a,
                o = s(e[r]).split(y),
                l = "",
                c = !1;
            isNaN(o[0]) ? (c = !0, l = o[0], o = o.slice(1), n[r] = {
                name: l,
                value: []
            }, a = n[r].value) : a = n[r] = [];
            for (var u = 0; u < o.length; u++)
                a.push(+o[u]);
            1 === a.length && (c ? n[r].value = a[0] : n[r] = a[0])
        }
        return {
            name: i,
            data: n
        }
    }
    function h(t, e) {
        var i = t.split(new RegExp("\n*" + m + "\n*", "g")),
            n = {
                series: []
            };
        return f.each(i, function(t, i) {
            if (l(t)) {
                var r = c(t),
                    a = e[i],
                    o = a.axisDim + "Axis";
                a && (n[o] = n[o] || [], n[o][a.axisIndex] = {
                    data: r.categories
                }, n.series = n.series.concat(r.series))
            } else {
                var r = u(t);
                n.series.push(r)
            }
        }), n
    }
    function d(t) {
        this._dom = null, this.model = t
    }
    function p(t, e) {
        return f.map(t, function(t, i) {
            var n = e && e[i];
            return f.isObject(n) && !f.isArray(n) ? (f.isObject(t) && !f.isArray(t) && (t = t.value), f.defaults({
                value: t
            }, n)) : t
        })
    }
    var f = i(509),
        g = i(593),
        m = new Array(60).join("-"),
        v = "\t",
        y = new RegExp("[" + v + "]+", "g");
    d.defaultOption = {
        show: !0,
        readOnly: !1,
        optionToContent: null,
        contentToOption: null,
        icon: "M17.5,17.3H33 M17.5,17.3H33 M45.4,29.5h-28 M11.5,2v56H51V14.8L38.4,2H11.5z M38.4,2.2v12.7H51 M45.4,41.7h-28",
        title: "数据视图",
        lang: ["数据视图", "关闭", "刷新"],
        backgroundColor: "#fff",
        textColor: "#000",
        textareaColor: "#fff",
        textareaBorderColor: "#333",
        buttonColor: "#c23531",
        buttonTextColor: "#fff"
    }, d.prototype.onclick = function(t, e) {
        function i() {
            n.removeChild(a), S._dom = null
        }
        var n = e.getDom(),
            r = this.model;
        this._dom && n.removeChild(this._dom);
        var a = document.createElement("div");
        a.style.cssText = "position:absolute;left:5px;top:5px;bottom:5px;right:5px;", a.style.backgroundColor = r.get("backgroundColor") || "#fff";
        var s = document.createElement("h4"),
            l = r.get("lang") || [];
        s.innerHTML = l[0] || r.get("title"), s.style.cssText = "margin: 10px 20px;", s.style.color = r.get("textColor");
        var c = document.createElement("div"),
            u = document.createElement("textarea");
        c.style.cssText = "display:block;width:100%;overflow:hidden;";
        var d = r.get("optionToContent"),
            p = r.get("contentToOption"),
            m = o(t);
        if ("function" == typeof d) {
            var y = d(e.getOption());
            "string" == typeof y ? c.innerHTML = y : f.isDom(y) && c.appendChild(y)
        } else
            c.appendChild(u), u.readOnly = r.get("readOnly"), u.style.cssText = "width:100%;height:100%;font-family:monospace;font-size:14px;line-height:1.6rem;", u.style.color = r.get("textColor"), u.style.borderColor = r.get("textareaBorderColor"), u.style.backgroundColor = r.get("textareaColor"), u.value = m.value;
        var x = m.meta,
            _ = document.createElement("div");
        _.style.cssText = "position:absolute;bottom:0;left:0;right:0;";
        var b = "float:right;margin-right:20px;border:none;cursor:pointer;padding:2px 5px;font-size:12px;border-radius:3px",
            w = document.createElement("div"),
            M = document.createElement("div");
        b += ";background-color:" + r.get("buttonColor"), b += ";color:" + r.get("buttonTextColor");
        var S = this;
        g.addEventListener(w, "click", i), g.addEventListener(M, "click", function() {
            var t;
            try {
                t = "function" == typeof p ? p(c, e.getOption()) : h(u.value, x)
            } catch (t) {
                throw i(), new Error("Data view format error " + t)
            }
            t && e.dispatchAction({
                type: "changeDataView",
                newOption: t
            }), i()
        }), w.innerHTML = l[1], M.innerHTML = l[2], M.style.cssText = b, w.style.cssText = b, !r.get("readOnly") && _.appendChild(M), _.appendChild(w), g.addEventListener(u, "keydown", function(t) {
            if (9 === (t.keyCode || t.which)) {
                var e = this.value,
                    i = this.selectionStart,
                    n = this.selectionEnd;
                this.value = e.substring(0, i) + v + e.substring(n), this.selectionStart = this.selectionEnd = i + 1, g.stop(t)
            }
        }), a.appendChild(s), a.appendChild(c), a.appendChild(_), c.style.height = n.clientHeight - 80 + "px", n.appendChild(a), this._dom = a
    }, d.prototype.remove = function(t, e) {
        this._dom && e.getDom().removeChild(this._dom)
    }, d.prototype.dispose = function(t, e) {
        this.remove(t, e)
    }, i(821).register("dataView", d), i(506).registerAction({
        type: "changeDataView",
        event: "dataViewChanged",
        update: "prepareAndUpdate"
    }, function(t, e) {
        var i = [];
        f.each(t.newOption.series, function(t) {
            var n = e.getSeriesByName(t.name)[0];
            if (n) {
                var r = n.get("data");
                i.push({
                    name: t.name,
                    data: p(t.data, r)
                })
            } else
                i.push(f.extend({
                    type: "scatter"
                }, t))
        }), e.mergeOption(f.defaults({
            series: i
        }, t.newOption))
    }), t.exports = d
}, function(t, e, i) {
    "use strict";
    function n(t, e, i) {
        (this._brushController = new l(i.getZr())).on("brush", s.bind(this._onBrush, this)).mount(), this._isZoomActive
    }
    function r(t) {
        var e = {};
        return s.each(["xAxisIndex", "yAxisIndex"], function(i) {
            e[i] = t[i], null == e[i] && (e[i] = "all"), (e[i] === !1 || "none" === e[i]) && (e[i] = [])
        }), e
    }
    function a(t, e) {
        t.setIconStatus("back", u.count(e) > 1 ? "emphasis" : "normal")
    }
    function o(t, e, i, n) {
        var a = i._isZoomActive;
        n && "takeGlobalCursor" === n.type && (a = "dataZoomSelect" === n.key && n.dataZoomSelectActive), i._isZoomActive = a, t.setIconStatus("zoom", a ? "emphasis" : "normal");
        var o = c.makeCoordInfoList(r(t.option), e),
            s = o.xAxisHas && !o.yAxisHas ? "lineX" : !o.xAxisHas && o.yAxisHas ? "lineY" : "rect";
        i._brushController.setPanels(c.makePanelOpts(o)).enableBrush(!!a && {
            brushType: s,
            brushStyle: {
                lineWidth: 0,
                fill: "rgba(0,0,0,0.2)"
            }
        })
    }
    var s = i(509),
        l = i(740),
        c = i(816),
        u = i(880),
        h = s.each;
    i(881);
    var d = "\0_ec_\0toolbox-dataZoom_";
    n.defaultOption = {
        show: !0,
        icon: {
            zoom: "M0,13.5h26.9 M13.5,26.9V0 M32.1,13.5H58V58H13.5 V32.1",
            back: "M22,1.4L9.9,13.5l12.3,12.3 M10.3,13.5H54.9v44.6 H10.3v-26"
        },
        title: {
            zoom: "区域缩放",
            back: "区域缩放还原"
        }
    };
    var p = n.prototype;
    p.render = function(t, e, i, n) {
        this.model = t, this.ecModel = e, this.api = i, o(t, e, this, n), a(t, e)
    }, p.onclick = function(t, e, i) {
        f[i].call(this)
    }, p.remove = function(t, e) {
        this._brushController.unmount()
    }, p.dispose = function(t, e) {
        this._brushController.dispose()
    };
    var f = {
        zoom: function() {
            var t = !this._isZoomActive;
            this.api.dispatchAction({
                type: "takeGlobalCursor",
                key: "dataZoomSelect",
                dataZoomSelectActive: t
            })
        },
        back: function() {
            this._dispatchZoomAction(u.pop(this.ecModel))
        }
    };
    p._onBrush = function(t, e) {
        function i(t, e, i) {
            var r = n(t, i[t], o);
            r && (a[r.id] = {
                dataZoomId: r.id,
                startValue: e[0],
                endValue: e[1]
            })
        }
        function n(t, e, i) {
            var n;
            return i.eachComponent({
                mainType: "dataZoom",
                subType: "select"
            }, function(r, a) {
                var o = r.get(t + "Index");
                null != o && i.getComponent(t, o) === e && (n = r)
            }), n
        }
        if (e.isEnd && t.length) {
            var a = {},
                o = this.ecModel;
            this._brushController.updateCovers([]);
            var s = c.makeCoordInfoList(r(this.model.option), o),
                l = [];
            c.parseOutputRanges(t, s, o, l);
            var h = t[0],
                d = l[0],
                p = h.coordRange,
                f = h.brushType;
            if (d && p)
                if ("rect" === f)
                    i("xAxis", p[0], d), i("yAxis", p[1], d);
                else {
                    var g = {
                        lineX: "xAxis",
                        lineY: "yAxis"
                    };
                    i(g[f], p, d)
                }
            u.push(o, a), this._dispatchZoomAction(a)
        }
    }, p._dispatchZoomAction = function(t) {
        var e = [];
        h(t, function(t, i) {
            e.push(s.clone(t))
        }), e.length && this.api.dispatchAction({
            type: "dataZoom",
            from: this.uid,
            batch: e
        })
    }, i(821).register("dataZoom", n), i(506).registerPreprocessor(function(t) {
        function e(t, e) {
            if (e) {
                var r = t + "Index",
                    a = e[r];
                null == a || "all" == a || s.isArray(a) || (a = a === !1 || "none" === a ? [] : [a]), i(t, function(e, i) {
                    if (null == a || "all" == a || s.indexOf(a, i) !== -1) {
                        var o = {
                            type: "select",
                            $fromToolbox: !0,
                            id: d + t + i
                        };
                        o[r] = i, n.push(o)
                    }
                })
            }
        }
        function i(e, i) {
            var n = t[e];
            s.isArray(n) || (n = n ? [n] : []), h(n, i)
        }
        if (t) {
            var n = t.dataZoom || (t.dataZoom = []);
            s.isArray(n) || (t.dataZoom = n = [n]);
            var r = t.toolbox;
            if (r && (s.isArray(r) && (r = r[0]), r && r.feature)) {
                var a = r.feature.dataZoom;
                e("xAxis", a), e("yAxis", a)
            }
        }
    }), t.exports = n
}, function(t, e, i) {
    function n(t) {
        var e = t[o];
        return e || (e = t[o] = [{}]), e
    }
    var r = i(509),
        a = r.each,
        o = "\0_ec_hist_store",
        s = {
            push: function(t, e) {
                var i = n(t);
                a(e, function(e, n) {
                    for (var r = i.length - 1; r >= 0; r--) {
                        var a = i[r];
                        if (a[n])
                            break
                    }
                    if (r < 0) {
                        var o = t.queryComponents({
                            mainType: "dataZoom",
                            subType: "select",
                            id: n
                        })[0];
                        if (o) {
                            var s = o.getPercentRange();
                            i[0][n] = {
                                dataZoomId: n,
                                start: s[0],
                                end: s[1]
                            }
                        }
                    }
                }), i.push(e)
            },
            pop: function(t) {
                var e = n(t),
                    i = e[e.length - 1];
                e.length > 1 && e.pop();
                var r = {};
                return a(i, function(t, i) {
                    for (var n = e.length - 1; n >= 0; n--) {
                        var t = e[n][i];
                        if (t) {
                            r[i] = t;
                            break
                        }
                    }
                }), r
            },
            clear: function(t) {
                t[o] = null
            },
            count: function(t) {
                return n(t).length
            }
        };
    t.exports = s
}, function(t, e, i) {
    i(824), i(825), i(828), i(882), i(883), i(835), i(836)
}, function(t, e, i) {
    var n = i(825);
    t.exports = n.extend({
        type: "dataZoom.select"
    })
}, function(t, e, i) {
    t.exports = i(828).extend({
        type: "dataZoom.select"
    })
}, function(t, e, i) {
    "use strict";
    function n(t) {
        this.model = t
    }
    var r = i(880);
    n.defaultOption = {
        show: !0,
        icon: "M3.8,33.4 M47,18.9h9.8V8.7 M56.3,20.1 C52.1,9,40.5,0.6,26.8,2.1C12.6,3.7,1.6,16.2,2.1,30.6 M13,41.1H3.1v10.2 M3.7,39.9c4.2,11.1,15.8,19.5,29.5,18 c14.2-1.6,25.2-14.1,24.7-28.5",
        title: "还原"
    };
    var a = n.prototype;
    a.onclick = function(t, e, i) {
        r.clear(t), e.dispatchAction({
            type: "restore",
            from: this.uid
        })
    }, i(821).register("restore", n), i(506).registerAction({
        type: "restore",
        event: "restore",
        update: "prepareAndUpdate"
    }, function(t, e) {
        e.resetOption("recreate")
    }), t.exports = n
}, function(t, e, i) {
    i(886), i(587).registerPainter("vml", i(888))
}, function(t, e, i) {
    if (!i(507).canvasSupported) {
        var n = i(515),
            r = i(514),
            a = i(554).CMD,
            o = i(544),
            s = i(513),
            l = i(553),
            c = i(551),
            u = i(566),
            h = i(568),
            d = i(550),
            p = i(584),
            f = i(887),
            g = Math.round,
            m = Math.sqrt,
            v = Math.abs,
            y = Math.cos,
            x = Math.sin,
            _ = Math.max,
            b = n.applyTransform,
            w = ",",
            M = "progid:DXImageTransform.Microsoft",
            S = 21600,
            A = S / 2,
            I = 1e5,
            D = 1e3,
            k = function(t) {
                t.style.cssText = "position:absolute;left:0;top:0;width:1px;height:1px;", t.coordsize = S + "," + S, t.coordorigin = "0,0"
            },
            T = function(t) {
                return String(t).replace(/&/g, "&amp;").replace(/"/g, "&quot;")
            },
            C = function(t, e, i) {
                return "rgb(" + [t, e, i].join(",") + ")"
            },
            L = function(t, e) {
                e && t && e.parentNode !== t && t.appendChild(e)
            },
            P = function(t, e) {
                e && t && e.parentNode === t && t.removeChild(e)
            },
            E = function(t, e, i) {
                return (parseFloat(t) || 0) * I + (parseFloat(e) || 0) * D + i
            },
            O = function(t, e) {
                return "string" == typeof t ? t.lastIndexOf("%") >= 0 ? parseFloat(t) / 100 * e : parseFloat(t) : t
            },
            R = function(t, e, i) {
                var n = o.parse(e);
                i = +i, isNaN(i) && (i = 1), n && (t.color = C(n[0], n[1], n[2]), t.opacity = i * n[3])
            },
            z = function(t) {
                var e = o.parse(t);
                return [C(e[0], e[1], e[2]), e[3]]
            },
            V = function(t, e, i) {
                var n = e.fill;
                if (null != n)
                    if (n instanceof p) {
                        var r,
                            a = 0,
                            o = [0, 0],
                            s = 0,
                            l = 1,
                            c = i.getBoundingRect(),
                            u = c.width,
                            h = c.height;
                        if ("linear" === n.type) {
                            r = "gradient";
                            var d = i.transform,
                                f = [n.x * u, n.y * h],
                                g = [n.x2 * u, n.y2 * h];
                            d && (b(f, f, d), b(g, g, d));
                            var m = g[0] - f[0],
                                v = g[1] - f[1];
                            a = 180 * Math.atan2(m, v) / Math.PI, a < 0 && (a += 360), a < 1e-6 && (a = 0)
                        } else {
                            r = "gradientradial";
                            var f = [n.x * u, n.y * h],
                                d = i.transform,
                                y = i.scale,
                                x = u,
                                w = h;
                            o = [(f[0] - c.x) / x, (f[1] - c.y) / w], d && b(f, f, d), x /= y[0] * S, w /= y[1] * S;
                            var M = _(x, w);
                            s = 0 / M, l = 2 * n.r / M - s
                        }
                        var A = n.colorStops.slice();
                        A.sort(function(t, e) {
                            return t.offset - e.offset
                        });
                        for (var I = A.length, D = [], k = [], T = 0; T < I; T++) {
                            var C = A[T],
                                L = z(C.color);
                            k.push(C.offset * l + s + " " + L[0]), 0 !== T && T !== I - 1 || D.push(L)
                        }
                        if (I >= 2) {
                            var P = D[0][0],
                                E = D[1][0],
                                O = D[0][1] * e.opacity,
                                V = D[1][1] * e.opacity;
                            t.type = r, t.method = "none", t.focus = "100%", t.angle = a, t.color = P, t.color2 = E, t.colors = k.join(","), t.opacity = V, t.opacity2 = O
                        }
                        "radial" === r && (t.focusposition = o.join(","))
                    } else
                        R(t, n, e.opacity)
            },
            N = function(t, e) {
                null != e.lineDash && (t.dashstyle = e.lineDash.join(" ")), null == e.stroke || e.stroke instanceof p || R(t, e.stroke, e.opacity)
            },
            B = function(t, e, i, n) {
                var r = "fill" == e,
                    a = t.getElementsByTagName(e)[0];
                null != i[e] && "none" !== i[e] && (r || !r && i.lineWidth) ? (t[r ? "filled" : "stroked"] = "true", i[e] instanceof p && P(t, a), a || (a = f.createNode(e)), r ? V(a, i, n) : N(a, i), L(t, a)) : (t[r ? "filled" : "stroked"] = "false", P(t, a))
            },
            F = [[], [], []],
            H = function(t, e) {
                var i,
                    n,
                    r,
                    o,
                    s,
                    l,
                    c = a.M,
                    u = a.C,
                    h = a.L,
                    d = a.A,
                    p = a.Q,
                    f = [];
                for (o = 0; o < t.length;) {
                    switch (r = t[o++], n = "", i = 0, r) {
                    case c:
                        n = " m ", i = 1, s = t[o++], l = t[o++], F[0][0] = s, F[0][1] = l;
                        break;
                    case h:
                        n = " l ", i = 1, s = t[o++], l = t[o++], F[0][0] = s, F[0][1] = l;
                        break;
                    case p:
                    case u:
                        n = " c ", i = 3;
                        var v,
                            _,
                            M = t[o++],
                            I = t[o++],
                            D = t[o++],
                            k = t[o++];
                        r === p ? (v = D, _ = k, D = (D + 2 * M) / 3, k = (k + 2 * I) / 3, M = (s + 2 * M) / 3, I = (l + 2 * I) / 3) : (v = t[o++], _ = t[o++]), F[0][0] = M, F[0][1] = I, F[1][0] = D, F[1][1] = k, F[2][0] = v, F[2][1] = _, s = v, l = _;
                        break;
                    case d:
                        var T = 0,
                            C = 0,
                            L = 1,
                            P = 1,
                            E = 0;
                        e && (T = e[4], C = e[5], L = m(e[0] * e[0] + e[1] * e[1]), P = m(e[2] * e[2] + e[3] * e[3]), E = Math.atan2(-e[1] / P, e[0] / L));
                        var O = t[o++],
                            R = t[o++],
                            z = t[o++],
                            V = t[o++],
                            N = t[o++] + E,
                            B = t[o++] + N + E;
                        o++;
                        var H = t[o++],
                            G = O + y(N) * z,
                            $ = R + x(N) * V,
                            M = O + y(B) * z,
                            I = R + x(B) * V,
                            W = H ? " wa " : " at ";
                        Math.abs(G - M) < 1e-10 && (Math.abs(B - N) > .01 ? H && (G += 270 / S) : Math.abs($ - R) < 1e-10 ? H && G < O || !H && G > O ? I -= 270 / S : I += 270 / S : H && $ < R || !H && $ > R ? M += 270 / S : M -= 270 / S), f.push(W, g(((O - z) * L + T) * S - A), w, g(((R - V) * P + C) * S - A), w, g(((O + z) * L + T) * S - A), w, g(((R + V) * P + C) * S - A), w, g((G * L + T) * S - A), w, g(($ * P + C) * S - A), w, g((M * L + T) * S - A), w, g((I * P + C) * S - A)), s = M, l = I;
                        break;
                    case a.R:
                        var Y = F[0],
                            q = F[1];
                        Y[0] = t[o++], Y[1] = t[o++], q[0] = Y[0] + t[o++], q[1] = Y[1] + t[o++], e && (b(Y, Y, e), b(q, q, e)), Y[0] = g(Y[0] * S - A), q[0] = g(q[0] * S - A), Y[1] = g(Y[1] * S - A), q[1] = g(q[1] * S - A), f.push(" m ", Y[0], w, Y[1], " l ", q[0], w, Y[1], " l ", q[0], w, q[1], " l ", Y[0], w, q[1]);
                        break;
                    case a.Z:
                        f.push(" x ")
                    }
                    if (i > 0) {
                        f.push(n);
                        for (var U = 0; U < i; U++) {
                            var Z = F[U];
                            e && b(Z, Z, e), f.push(g(Z[0] * S - A), w, g(Z[1] * S - A), U < i - 1 ? w : "")
                        }
                    }
                }
                return f.join("")
            };
        d.prototype.brushVML = function(t) {
            var e = this.style,
                i = this._vmlEl;
            i || (i = f.createNode("shape"), k(i), this._vmlEl = i), B(i, "fill", e, this), B(i, "stroke", e, this);
            var n = this.transform,
                r = null != n,
                a = i.getElementsByTagName("stroke")[0];
            if (a) {
                var o = e.lineWidth;
                if (r && !e.strokeNoScale) {
                    var s = n[0] * n[3] - n[1] * n[2];
                    o *= m(v(s))
                }
                a.weight = o + "px"
            }
            var l = this.path;
            this.__dirtyPath && (l.beginPath(), this.buildPath(l, this.shape), l.toStatic(), this.__dirtyPath = !1), i.path = H(l.data, this.transform), i.style.zIndex = E(this.zlevel, this.z, this.z2), L(t, i), null != e.text ? this.drawRectText(t, this.getBoundingRect()) : this.removeRectText(t)
        }, d.prototype.onRemove = function(t) {
            P(t, this._vmlEl), this.removeRectText(t)
        }, d.prototype.onAdd = function(t) {
            L(t, this._vmlEl), this.appendRectText(t)
        };
        var G = function(t) {
            return "object" == typeof t && t.tagName && "IMG" === t.tagName.toUpperCase()
        };
        u.prototype.brushVML = function(t) {
            var e,
                i,
                n = this.style,
                r = n.image;
            if (G(r)) {
                var a = r.src;
                if (a === this._imageSrc)
                    e = this._imageWidth, i = this._imageHeight;
                else {
                    var o = r.runtimeStyle,
                        s = o.width,
                        l = o.height;
                    o.width = "auto", o.height = "auto", e = r.width, i = r.height, o.width = s, o.height = l, this._imageSrc = a, this._imageWidth = e, this._imageHeight = i
                }
                r = a
            } else
                r === this._imageSrc && (e = this._imageWidth, i = this._imageHeight);
            if (r) {
                var c = n.x || 0,
                    u = n.y || 0,
                    h = n.width,
                    d = n.height,
                    p = n.sWidth,
                    v = n.sHeight,
                    y = n.sx || 0,
                    x = n.sy || 0,
                    S = p && v,
                    A = this._vmlEl;
                A || (A = f.doc.createElement("div"), k(A), this._vmlEl = A);
                var I,
                    D = A.style,
                    T = !1,
                    C = 1,
                    P = 1;
                if (this.transform && (I = this.transform, C = m(I[0] * I[0] + I[1] * I[1]), P = m(I[2] * I[2] + I[3] * I[3]), T = I[1] || I[2]), T) {
                    var O = [c, u],
                        R = [c + h, u],
                        z = [c, u + d],
                        V = [c + h, u + d];
                    b(O, O, I), b(R, R, I), b(z, z, I), b(V, V, I);
                    var N = _(O[0], R[0], z[0], V[0]),
                        B = _(O[1], R[1], z[1], V[1]),
                        F = [];
                    F.push("M11=", I[0] / C, w, "M12=", I[2] / P, w, "M21=", I[1] / C, w, "M22=", I[3] / P, w, "Dx=", g(c * C + I[4]), w, "Dy=", g(u * P + I[5])), D.padding = "0 " + g(N) + "px " + g(B) + "px 0", D.filter = M + ".Matrix(" + F.join("") + ", SizingMethod=clip)"
                } else
                    I && (c = c * C + I[4], u = u * P + I[5]), D.filter = "", D.left = g(c) + "px", D.top = g(u) + "px";
                var H = this._imageEl,
                    $ = this._cropEl;
                H || (H = f.doc.createElement("div"), this._imageEl = H);
                var W = H.style;
                if (S) {
                    if (e && i)
                        W.width = g(C * e * h / p) + "px", W.height = g(P * i * d / v) + "px";
                    else {
                        var Y = new Image,
                            q = this;
                        Y.onload = function() {
                            Y.onload = null, e = Y.width, i = Y.height, W.width = g(C * e * h / p) + "px", W.height = g(P * i * d / v) + "px", q._imageWidth = e, q._imageHeight = i, q._imageSrc = r
                        }, Y.src = r
                    }
                    $ || ($ = f.doc.createElement("div"), $.style.overflow = "hidden", this._cropEl = $);
                    var U = $.style;
                    U.width = g((h + y * h / p) * C), U.height = g((d + x * d / v) * P), U.filter = M + ".Matrix(Dx=" + -y * h / p * C + ",Dy=" + -x * d / v * P + ")", $.parentNode || A.appendChild($), H.parentNode != $ && $.appendChild(H)
                } else
                    W.width = g(C * h) + "px", W.height = g(P * d) + "px", A.appendChild(H), $ && $.parentNode && (A.removeChild($), this._cropEl = null);
                var Z = "",
                    j = n.opacity;
                j < 1 && (Z += ".Alpha(opacity=" + g(100 * j) + ") "), Z += M + ".AlphaImageLoader(src=" + r + ", SizingMethod=scale)", W.filter = Z, A.style.zIndex = E(this.zlevel, this.z, this.z2), L(t, A), null != n.text && this.drawRectText(t, this.getBoundingRect())
            }
        }, u.prototype.onRemove = function(t) {
            P(t, this._vmlEl), this._vmlEl = null, this._cropEl = null, this._imageEl = null, this.removeRectText(t)
        }, u.prototype.onAdd = function(t) {
            L(t, this._vmlEl), this.appendRectText(t)
        };
        var $,
            W = "normal",
            Y = {},
            q = 0,
            U = 100,
            Z = document.createElement("div"),
            j = function(t) {
                var e = Y[t];
                if (!e) {
                    q > U && (q = 0, Y = {});
                    var i,
                        n = Z.style;
                    try {
                        n.font = t, i = n.fontFamily.split(",")[0]
                    } catch (t) {}
                    e = {
                        style: n.fontStyle || W,
                        variant: n.fontVariant || W,
                        weight: n.fontWeight || W,
                        size: 0 | parseFloat(n.fontSize || 12),
                        family: i || "Microsoft YaHei"
                    }, Y[t] = e, q++
                }
                return e
            };
        s.measureText = function(t, e) {
            var i = f.doc;
            $ || ($ = i.createElement("div"), $.style.cssText = "position:absolute;top:-20000px;left:0;padding:0;margin:0;border:none;white-space:pre;", f.doc.body.appendChild($));
            try {
                $.style.font = e
            } catch (t) {}
            return $.innerHTML = "", $.appendChild(i.createTextNode(t)), {
                width: $.offsetWidth
            }
        };
        for (var X = new r, K = function(t, e, i, n) {
                var r = this.style,
                    a = r.text;
                if (null != a && (a += ""), a) {
                    var o,
                        l,
                        c = r.textAlign,
                        u = j(r.textFont),
                        h = u.style + " " + u.variant + " " + u.weight + " " + u.size + 'px "' + u.family + '"',
                        d = r.textBaseline,
                        p = r.textVerticalAlign;
                    i = i || s.getBoundingRect(a, h, c, d);
                    var m = this.transform;
                    if (m && !n && (X.copy(e), X.applyTransform(m), e = X), n)
                        o = e.x, l = e.y;
                    else {
                        var v = r.textPosition,
                            y = r.textDistance;
                        if (v instanceof Array)
                            o = e.x + O(v[0], e.width), l = e.y + O(v[1], e.height), c = c || "left", d = d || "top";
                        else {
                            var x = s.adjustTextPositionOnRect(v, e, i, y);
                            o = x.x, l = x.y, c = c || x.textAlign, d = d || x.textBaseline
                        }
                    }
                    if (p) {
                        switch (p) {
                        case "middle":
                            l -= i.height / 2;
                            break;
                        case "bottom":
                            l -= i.height
                        }
                        d = "top"
                    }
                    var _ = u.size;
                    switch (d) {
                    case "hanging":
                    case "top":
                        l += _ / 1.75;
                        break;
                    case "middle":
                        break;
                    default:
                        l -= _ / 2.25
                    }
                    switch (c) {
                    case "left":
                        break;
                    case "center":
                        o -= i.width / 2;
                        break;
                    case "right":
                        o -= i.width
                    }
                    var M,
                        S,
                        A,
                        I = f.createNode,
                        D = this._textVmlEl;
                    D ? (A = D.firstChild, M = A.nextSibling, S = M.nextSibling) : (D = I("line"), M = I("path"), S = I("textpath"), A = I("skew"), S.style["v-text-align"] = "left", k(D), M.textpathok = !0, S.on = !0, D.from = "0 0", D.to = "1000 0.05", L(D, A), L(D, M), L(D, S), this._textVmlEl = D);
                    var C = [o, l],
                        P = D.style;
                    m && n ? (b(C, C, m), A.on = !0, A.matrix = m[0].toFixed(3) + w + m[2].toFixed(3) + w + m[1].toFixed(3) + w + m[3].toFixed(3) + ",0,0", A.offset = (g(C[0]) || 0) + "," + (g(C[1]) || 0), A.origin = "0 0", P.left = "0px", P.top = "0px") : (A.on = !1, P.left = g(o) + "px", P.top = g(l) + "px"), S.string = T(a);
                    try {
                        S.style.font = h
                    } catch (t) {}
                    B(D, "fill", {
                        fill: n ? r.fill : r.textFill,
                        opacity: r.opacity
                    }, this), B(D, "stroke", {
                        stroke: n ? r.stroke : r.textStroke,
                        opacity: r.opacity,
                        lineDash: r.lineDash
                    }, this), D.style.zIndex = E(this.zlevel, this.z, this.z2), L(t, D)
                }
            }, J = function(t) {
                P(t, this._textVmlEl), this._textVmlEl = null
            }, Q = function(t) {
                L(t, this._textVmlEl)
            }, tt = [l, c, u, d, h], et = 0; et < tt.length; et++) {
            var it = tt[et].prototype;
            it.drawRectText = K, it.removeRectText = J, it.appendRectText = Q
        }
        h.prototype.brushVML = function(t) {
            var e = this.style;
            null != e.text ? this.drawRectText(t, {
                x: e.x || 0,
                y: e.y || 0,
                width: 0,
                height: 0
            }, this.getBoundingRect(), !0) : this.removeRectText(t)
        }, h.prototype.onRemove = function(t) {
            this.removeRectText(t)
        }, h.prototype.onAdd = function(t) {
            this.appendRectText(t)
        }
    }
}, function(t, e, i) {
    if (!i(507).canvasSupported) {
        var n,
            r = "urn:schemas-microsoft-com:vml",
            a = window,
            o = a.document,
            s = !1;
        try {
            !o.namespaces.zrvml && o.namespaces.add("zrvml", r), n = function(t) {
                return o.createElement("<zrvml:" + t + ' class="zrvml">')
            }
        } catch (t) {
            n = function(t) {
                return o.createElement("<" + t + ' xmlns="' + r + '" class="zrvml">')
            }
        }
        var l = function() {
            if (!s) {
                s = !0;
                var t = o.styleSheets;
                t.length < 31 ? o.createStyleSheet().addRule(".zrvml", "behavior:url(#default#VML)") : t[0].addRule(".zrvml", "behavior:url(#default#VML)")
            }
        };
        t.exports = {
            doc: o,
            initVML: l,
            createNode: n
        }
    }
}, function(t, e, i) {
    function n(t) {
        return parseInt(t, 10)
    }
    function r(t, e) {
        s.initVML(), this.root = t, this.storage = e;
        var i = document.createElement("div"),
            n = document.createElement("div");
        i.style.cssText = "display:inline-block;overflow:hidden;position:relative;width:300px;height:150px;", n.style.cssText = "position:absolute;left:0;top:0;", t.appendChild(i), this._vmlRoot = n, this._vmlViewport = i, this.resize();
        var r = e.delFromMap,
            a = e.addToMap;
        e.delFromMap = function(t) {
            var i = e.get(t);
            r.call(e, t), i && i.onRemove && i.onRemove(n)
        }, e.addToMap = function(t) {
            t.onAdd && t.onAdd(n), a.call(e, t)
        }, this._firstPaint = !0
    }
    function a(t) {
        return function() {
            o('In IE8.0 VML mode painter not support method "' + t + '"')
        }
    }
    var o = i(545),
        s = i(887);
    r.prototype = {
        constructor: r,
        getViewportRoot: function() {
            return this._vmlViewport
        },
        refresh: function() {
            var t = this.storage.getDisplayList(!0, !0);
            this._paintList(t)
        },
        _paintList: function(t) {
            for (var e = this._vmlRoot, i = 0; i < t.length; i++) {
                var n = t[i];
                n.invisible || n.ignore ? (n.__alreadyNotVisible || n.onRemove(e), n.__alreadyNotVisible = !0) : (n.__alreadyNotVisible && n.onAdd(e), n.__alreadyNotVisible = !1, n.__dirty && (n.beforeBrush && n.beforeBrush(), (n.brushVML || n.brush).call(n, e), n.afterBrush && n.afterBrush())), n.__dirty = !1
            }
            this._firstPaint && (this._vmlViewport.appendChild(e), this._firstPaint = !1)
        },
        resize: function(t, e) {
            var t = null == t ? this._getWidth() : t,
                e = null == e ? this._getHeight() : e;
            if (this._width != t || this._height != e) {
                this._width = t, this._height = e;
                var i = this._vmlViewport.style;
                i.width = t + "px", i.height = e + "px"
            }
        },
        dispose: function() {
            this.root.innerHTML = "", this._vmlRoot = this._vmlViewport = this.storage = null
        },
        getWidth: function() {
            return this._width
        },
        getHeight: function() {
            return this._height
        },
        clear: function() {
            this._vmlViewport && this.root.removeChild(this._vmlViewport)
        },
        _getWidth: function() {
            var t = this.root,
                e = t.currentStyle;
            return (t.clientWidth || n(e.width)) - n(e.paddingLeft) - n(e.paddingRight) | 0
        },
        _getHeight: function() {
            var t = this.root,
                e = t.currentStyle;
            return (t.clientHeight || n(e.height)) - n(e.paddingTop) - n(e.paddingBottom) | 0
        }
    };
    for (var l = ["getLayer", "insertLayer", "eachLayer", "eachBuildinLayer", "eachOtherLayer", "getLayers", "modLayer", "delLayer", "clearLayer", "toDataURL", "pathToImage"], c = 0; c < l.length; c++) {
        var u = l[c];
        r.prototype[u] = a(u)
    }
    t.exports = r
}, function(t, e, i) {
    (function(e) {
        !function(e, i) {
            t.exports = i()
        }(this, function() {
            "use strict";
            function t(t) {
                return getComputedStyle(t)
            }
            function i(t) {
                return parseFloat(t) || 0
            }
            function n(t) {
                for (var e = arguments.length, n = Array(e > 1 ? e - 1 : 0), r = 1; r < e; r++)
                    n[r - 1] = arguments[r];
                return n.reduce(function(e, n) {
                    var r = t["border-" + n + "-width"];
                    return e + i(r)
                }, 0)
            }
            function r(t) {
                for (var e = ["top", "right", "bottom", "left"], n = {}, r = e, a = Array.isArray(r), o = 0, r = a ? r : r[Symbol.iterator]();;) {
                    var s;
                    if (a) {
                        if (o >= r.length)
                            break;
                        s = r[o++]
                    } else {
                        if (o = r.next(), o.done)
                            break;
                        s = o.value
                    }
                    var l = s,
                        c = t["padding-" + l];
                    n[l] = i(c)
                }
                return n
            }
            function a(t, e, i, n) {
                return {
                    width: t,
                    height: e,
                    top: i,
                    right: t + n,
                    bottom: e + i,
                    left: n
                }
            }
            function o(t) {
                var e = t.getBBox();
                return a(e.width, e.height, 0, 0)
            }
            function s() {
                var e = t(document.documentElement),
                    n = i(e.width),
                    r = i(e.height);
                return a(n, r, 0, 0)
            }
            function l(e) {
                var o = e.clientWidth,
                    s = e.clientHeight;
                if (!o && !s)
                    return w;
                var l = t(e),
                    c = r(l),
                    u = c.left + c.right,
                    h = c.top + c.bottom,
                    d = i(l.width),
                    p = i(l.height);
                "border-box" === l.boxSizing && (Math.round(d + u) !== o && (d -= n(l, "left", "right") + u), Math.round(p + h) !== s && (p -= n(l, "top", "bottom") + h));
                var f = Math.round(d + u) - o,
                    g = Math.round(p + h) - s;
                return 1 !== Math.abs(f) && (d -= f), 1 !== Math.abs(g) && (p -= g), a(d, p, c.top, c.left)
            }
            function c(t) {
                return t instanceof SVGElement
            }
            function u(t) {
                return t === document.documentElement
            }
            function h(t) {
                return b ? c(t) ? o(t) : u(t) ? s() : l(t) : w
            }
            function d(t, e) {
                for (var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, n = {
                        configurable: i.configurable || !1,
                        writable: i.writable || !1,
                        enumerable: i.enumerable || !1
                    }, r = Object.keys(e), a = Array.isArray(r), o = 0, r = a ? r : r[Symbol.iterator]();;) {
                    var s;
                    if (a) {
                        if (o >= r.length)
                            break;
                        s = r[o++]
                    } else {
                        if (o = r.next(), o.done)
                            break;
                        s = o.value
                    }
                    var l = s;
                    n.value = e[l], Object.defineProperty(t, l, n)
                }
                return t
            }
            var p = function() {
                    return "undefined" != typeof self && self.Math === Math ? self : "undefined" != typeof window && window.Math === Math ? window : "undefined" != typeof e && e.Math === Math ? e : Function("return this")()
                }(),
                f = function(t, e) {
                    if (!(t instanceof e))
                        throw new TypeError("Cannot call a class as a function")
                },
                g = function() {
                    function t(t, e) {
                        for (var i = 0; i < e.length; i++) {
                            var n = e[i];
                            n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n)
                        }
                    }
                    return function(e, i, n) {
                        return i && t(e.prototype, i), n && t(e, n), e
                    }
                }(),
                m = function(t, e) {
                    if ("function" != typeof e && null !== e)
                        throw new TypeError("Super expression must either be null or a function, not " + typeof e);
                    t.prototype = Object.create(e && e.prototype, {
                        constructor: {
                            value: t,
                            enumerable: !1,
                            writable: !0,
                            configurable: !0
                        }
                    }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e)
                },
                v = function(t, e) {
                    if (!t)
                        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return !e || "object" != typeof e && "function" != typeof e ? t : e
                },
                y = "function" == typeof p.WeakMap && "function" == typeof p.Map,
                x = function() {
                    function t(t, e) {
                        var i = -1;
                        return t.some(function(t, n) {
                            var r = t[0] === e;
                            return r && (i = n), r
                        }), i
                    }
                    return y ? p.WeakMap : function() {
                        function e() {
                            f(this, e), this.__entries__ = []
                        }
                        return e.prototype.get = function(e) {
                            var i = t(this.__entries__, e);
                            return this.__entries__[i][1]
                        }, e.prototype.set = function(e, i) {
                            var n = t(this.__entries__, e);
                            ~n ? this.__entries__[n][1] = i : this.__entries__.push([e, i])
                        }, e.prototype.delete = function(e) {
                            var i = this.__entries__,
                                n = t(i, e);
                            ~n && i.splice(n, 1)
                        }, e.prototype.has = function(e) {
                            return !!~t(this.__entries__, e)
                        }, e
                    }()
                }(),
                _ = function() {
                    return y ? p.Map : function(t) {
                        function e() {
                            return f(this, e), v(this, t.apply(this, arguments))
                        }
                        return m(e, t), e.prototype.clear = function() {
                            this.__entries__.splice(0, this.__entries__.length)
                        }, e.prototype.entries = function() {
                            return this.__entries__.slice()
                        }, e.prototype.keys = function() {
                            return this.__entries__.map(function(t) {
                                return t[0]
                            })
                        }, e.prototype.values = function() {
                            return this.__entries__.map(function(t) {
                                return t[1]
                            })
                        }, e.prototype.forEach = function(t) {
                            for (var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, i = this.__entries__, n = Array.isArray(i), r = 0, i = n ? i : i[Symbol.iterator]();;) {
                                var a;
                                if (n) {
                                    if (r >= i.length)
                                        break;
                                    a = i[r++]
                                } else {
                                    if (r = i.next(), r.done)
                                        break;
                                    a = r.value
                                }
                                var o = a;
                                t.call(e, o[1], o[0])
                            }
                        }, g(e, [{
                            key: "size",
                            get: function() {
                                return this.__entries__.length
                            }
                        }]), e
                    }(x)
                }(),
                b = p.window === p && "undefined" != typeof document,
                w = a(0, 0, 0, 0),
                M = function() {
                    function t(e) {
                        f(this, t), this.target = e, this._contentRect = w, this.broadcastWidth = 0, this.broadcastHeight = 0
                    }
                    return t.prototype.broadcastRect = function() {
                        var t = this._contentRect;
                        return this.broadcastWidth = t.width, this.broadcastHeight = t.height, t
                    }, t.prototype.isActive = function() {
                        var t = h(this.target);
                        return this._contentRect = t, t.width !== this.broadcastWidth || t.height !== this.broadcastHeight
                    }, t
                }(),
                S = function t(e, i) {
                    f(this, t);
                    var n = p.ClientRect || Object,
                        r = Object.create(n.prototype);
                    d(r, i, {
                        configurable: !0
                    }), d(this, {
                        target: e,
                        contentRect: r
                    }, {
                        configurable: !0
                    })
                },
                A = function() {
                    function t(e, i, n) {
                        if (f(this, t), "function" != typeof e)
                            throw new TypeError("The callback provided as parameter 1 is not a function.");
                        this._callback = e, this._targets = new _, this._activeTargets = [], this._controller = i, this._publicObserver = n
                    }
                    return t.prototype.observe = function(t) {
                        if (!arguments.length)
                            throw new TypeError("1 argument required, but only 0 present.");
                        if ("Element" in p && Element instanceof Object) {
                            if (!(t instanceof Element))
                                throw new TypeError('parameter 1 is not of type "Element".');
                            var e = this._targets;
                            e.has(t) || (e.set(t, new M(t)), this._controller.isConnected(this) || this._controller.connect(this), this._controller.refresh())
                        }
                    }, t.prototype.unobserve = function(t) {
                        if (!arguments.length)
                            throw new TypeError("1 argument required, but only 0 present.");
                        if ("Element" in p && Element instanceof Object) {
                            if (!(t instanceof Element))
                                throw new TypeError('parameter 1 is not of type "Element".');
                            var e = this._targets;
                            e.has(t) && (e.delete(t), e.size || this.disconnect())
                        }
                    }, t.prototype.disconnect = function() {
                        this.clearActive(), this._targets.clear(), this._controller.disconnect(this)
                    }, t.prototype.gatherActive = function() {
                        this.clearActive();
                        var t = this._activeTargets;
                        this._targets.forEach(function(e) {
                            e.isActive() && t.push(e)
                        })
                    }, t.prototype.broadcastActive = function() {
                        if (this.hasActive()) {
                            var t = this._publicObserver,
                                e = this._activeTargets.map(function(t) {
                                    return new S(t.target, t.broadcastRect())
                                });
                            this.clearActive(), this._callback.call(t, e, t)
                        }
                    }, t.prototype.clearActive = function() {
                        this._activeTargets.splice(0)
                    }, t.prototype.hasActive = function() {
                        return !!this._activeTargets.length
                    }, t
                }(),
                I = function() {
                    return "function" == typeof requestAnimationFrame ? requestAnimationFrame : function(t) {
                        return setTimeout(function() {
                            return t(Date.now())
                        }, 1e3 / 60)
                    }
                }(),
                D = function(t) {
                    function e() {
                        t.apply.apply(t, o), o = null, s && (n.apply.apply(n, s), s = null)
                    }
                    function i() {
                        a ? I(e) : e()
                    }
                    function n() {
                        for (var t = arguments.length, e = Array(t), n = 0; n < t; n++)
                            e[n] = arguments[n];
                        var a = [this, e];
                        o ? s = a : (o = a, setTimeout(i, r))
                    }
                    var r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
                        a = arguments.length > 2 && void 0 !== arguments[2] && arguments[2],
                        o = null,
                        s = null;
                    return n
                },
                k = "function" == typeof MutationObserver,
                T = function() {
                    function t() {
                        var e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
                        f(this, t), this._isCycleContinuous = !k || e, this._listenersEnabled = !1, this._mutationsObserver = null, this._observers = [], this.refresh = D(this.refresh.bind(this), 30, !0), this._continuousUpdateHandler = D(this.refresh, 70)
                    }
                    return t.prototype.connect = function(t) {
                        this.isConnected(t) || this._observers.push(t), this._listenersEnabled || this._addListeners()
                    }, t.prototype.disconnect = function(t) {
                        var e = this._observers,
                            i = e.indexOf(t);
                        ~i && e.splice(i, 1), !e.length && this._listenersEnabled && this._removeListeners()
                    }, t.prototype.isConnected = function(t) {
                        return !!~this._observers.indexOf(t)
                    }, t.prototype.refresh = function() {
                        var t = this._updateObservers();
                        t ? this.refresh() : this._isCycleContinuous && this._listenersEnabled && this._continuousUpdateHandler()
                    }, t.prototype._updateObservers = function() {
                        for (var t = !1, e = this._observers, i = Array.isArray(e), n = 0, e = i ? e : e[Symbol.iterator]();;) {
                            var r;
                            if (i) {
                                if (n >= e.length)
                                    break;
                                r = e[n++]
                            } else {
                                if (n = e.next(), n.done)
                                    break;
                                r = n.value
                            }
                            var a = r;
                            a.gatherActive(), a.hasActive() && (t = !0, a.broadcastActive())
                        }
                        return t
                    }, t.prototype._addListeners = function() {
                        b && !this._listenersEnabled && (window.addEventListener("resize", this.refresh), k && (this._mutationsObserver = new MutationObserver(this.refresh), this._mutationsObserver.observe(document, {
                            attributes: !0,
                            childList: !0,
                            characterData: !0,
                            subtree: !0
                        })), this._listenersEnabled = !0, this._isCycleContinuous && this.refresh())
                    }, t.prototype._removeListeners = function() {
                        b && this._listenersEnabled && (window.removeEventListener("resize", this.refresh), this._mutationsObserver && this._mutationsObserver.disconnect(), this._mutationsObserver = null, this._listenersEnabled = !1)
                    }, g(t, [{
                        key: "continuousUpdates",
                        get: function() {
                            return this._isCycleContinuous
                        },
                        set: function(t) {
                            k && (this._isCycleContinuous = t, this._listenersEnabled && t && this.refresh())
                        }
                    }]), t
                }(),
                C = new T,
                L = new x,
                P = function() {
                    function t(e) {
                        if (f(this, t), !arguments.length)
                            throw new TypeError("1 argument required, but only 0 present.");
                        var i = new A(e, C, this);
                        L.set(this, i)
                    }
                    return g(t, null, [{
                        key: "continuousUpdates",
                        get: function() {
                            return C.continuousUpdates
                        },
                        set: function(t) {
                            if ("boolean" != typeof t)
                                throw new TypeError('type of "continuousUpdates" value must be boolean.');
                            C.continuousUpdates = t
                        }
                    }]), t
                }();
            ["observe", "unobserve", "disconnect"].forEach(function(t) {
                P.prototype[t] = function() {
                    var e;
                    return (e = L.get(this))[t].apply(e, arguments)
                }
            });
            var E = function() {
                return "function" == typeof p.ResizeObserver ? p.ResizeObserver : P
            }();
            return E
        })
    }).call(e, function() {
        return this
    }())
}, , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , function(t, e, i) {
    (function(e) {
        /*!
	 * @description Recursive object extending
	 * @author Viacheslav Lotsmanov <lotsmanov89@gmail.com>
	 * @license MIT
	 *
	 * The MIT License (MIT)
	 *
	 * Copyright (c) 2013-2015 Viacheslav Lotsmanov
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining a copy of
	 * this software and associated documentation files (the "Software"), to deal in
	 * the Software without restriction, including without limitation the rights to
	 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
	 * the Software, and to permit persons to whom the Software is furnished to do so,
	 * subject to the following conditions:
	 *
	 * The above copyright notice and this permission notice shall be included in all
	 * copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
	 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
	 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
	 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
	 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
	 */
        "use strict";
        function i(t) {
            return t instanceof e || t instanceof Date || t instanceof RegExp
        }
        function n(t) {
            if (t instanceof e) {
                var i = new e(t.length);
                return t.copy(i), i
            }
            if (t instanceof Date)
                return new Date(t.getTime());
            if (t instanceof RegExp)
                return new RegExp(t);
            throw new Error("Unexpected situation")
        }
        function r(t) {
            var e = [];
            return t.forEach(function(t, o) {
                "object" == typeof t && null !== t ? Array.isArray(t) ? e[o] = r(t) : i(t) ? e[o] = n(t) : e[o] = a({}, t) : e[o] = t
            }), e
        }
        var a = t.exports = function() {
            if (arguments.length < 1 || "object" != typeof arguments[0])
                return !1;
            if (arguments.length < 2)
                return arguments[0];
            var t,
                e,
                o = arguments[0],
                s = Array.prototype.slice.call(arguments, 1);
            return s.forEach(function(s) {
                "object" != typeof s || Array.isArray(s) || Object.keys(s).forEach(function(l) {
                    return e = o[l], t = s[l], t === o ? void 0 : "object" != typeof t || null === t ? void (o[l] = t) : Array.isArray(t) ? void (o[l] = r(t)) : i(t) ? void (o[l] = n(t)) : "object" != typeof e || null === e || Array.isArray(e) ? void (o[l] = a({}, t)) : void (o[l] = a(e, t))
                })
            }), o
        }
    }).call(e, i(1026).Buffer)
}, function(t, e, i) {
    (function(t) {
        /*!
	 * The buffer module from node.js, for the browser.
	 *
	 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
	 * @license  MIT
	 */
        "use strict";
        function n() {
            try {
                var t = new Uint8Array(1);
                return t.__proto__ = {
                    __proto__: Uint8Array.prototype,
                    foo: function() {
                        return 42
                    }
                }, 42 === t.foo() && "function" == typeof t.subarray && 0 === t.subarray(1, 1).byteLength
            } catch (t) {
                return !1
            }
        }
        function r() {
            return o.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823
        }
        function a(t, e) {
            if (r() < e)
                throw new RangeError("Invalid typed array length");
            return o.TYPED_ARRAY_SUPPORT ? (t = new Uint8Array(e), t.__proto__ = o.prototype) : (null === t && (t = new o(e)), t.length = e), t
        }
        function o(t, e, i) {
            if (!(o.TYPED_ARRAY_SUPPORT || this instanceof o))
                return new o(t, e, i);
            if ("number" == typeof t) {
                if ("string" == typeof e)
                    throw new Error("If encoding is specified then the first argument must be a string");
                return u(this, t)
            }
            return s(this, t, e, i)
        }
        function s(t, e, i, n) {
            if ("number" == typeof e)
                throw new TypeError('"value" argument must not be a number');
            return "undefined" != typeof ArrayBuffer && e instanceof ArrayBuffer ? p(t, e, i, n) : "string" == typeof e ? h(t, e, i) : f(t, e)
        }
        function l(t) {
            if ("number" != typeof t)
                throw new TypeError('"size" argument must be a number');
            if (t < 0)
                throw new RangeError('"size" argument must not be negative')
        }
        function c(t, e, i, n) {
            return l(e), e <= 0 ? a(t, e) : void 0 !== i ? "string" == typeof n ? a(t, e).fill(i, n) : a(t, e).fill(i) : a(t, e)
        }
        function u(t, e) {
            if (l(e), t = a(t, e < 0 ? 0 : 0 | g(e)), !o.TYPED_ARRAY_SUPPORT)
                for (var i = 0; i < e; ++i)
                    t[i] = 0;
            return t
        }
        function h(t, e, i) {
            if ("string" == typeof i && "" !== i || (i = "utf8"), !o.isEncoding(i))
                throw new TypeError('"encoding" must be a valid string encoding');
            var n = 0 | v(e, i);
            t = a(t, n);
            var r = t.write(e, i);
            return r !== n && (t = t.slice(0, r)), t
        }
        function d(t, e) {
            var i = e.length < 0 ? 0 : 0 | g(e.length);
            t = a(t, i);
            for (var n = 0; n < i; n += 1)
                t[n] = 255 & e[n];
            return t
        }
        function p(t, e, i, n) {
            if (e.byteLength, i < 0 || e.byteLength < i)
                throw new RangeError("'offset' is out of bounds");
            if (e.byteLength < i + (n || 0))
                throw new RangeError("'length' is out of bounds");
            return e = void 0 === i && void 0 === n ? new Uint8Array(e) : void 0 === n ? new Uint8Array(e, i) : new Uint8Array(e, i, n), o.TYPED_ARRAY_SUPPORT ? (t = e, t.__proto__ = o.prototype) : t = d(t, e), t
        }
        function f(t, e) {
            if (o.isBuffer(e)) {
                var i = 0 | g(e.length);
                return t = a(t, i), 0 === t.length ? t : (e.copy(t, 0, 0, i), t)
            }
            if (e) {
                if ("undefined" != typeof ArrayBuffer && e.buffer instanceof ArrayBuffer || "length" in e)
                    return "number" != typeof e.length || X(e.length) ? a(t, 0) : d(t, e);
                if ("Buffer" === e.type && Q(e.data))
                    return d(t, e.data)
            }
            throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.")
        }
        function g(t) {
            if (t >= r())
                throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + r().toString(16) + " bytes");
            return 0 | t
        }
        function m(t) {
            return +t != t && (t = 0), o.alloc(+t)
        }
        function v(t, e) {
            if (o.isBuffer(t))
                return t.length;
            if ("undefined" != typeof ArrayBuffer && "function" == typeof ArrayBuffer.isView && (ArrayBuffer.isView(t) || t instanceof ArrayBuffer))
                return t.byteLength;
            "string" != typeof t && (t = "" + t);
            var i = t.length;
            if (0 === i)
                return 0;
            for (var n = !1;;)
                switch (e) {
                case "ascii":
                case "latin1":
                case "binary":
                    return i;
                case "utf8":
                case "utf-8":
                case void 0:
                    return Y(t).length;
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                    return 2 * i;
                case "hex":
                    return i >>> 1;
                case "base64":
                    return Z(t).length;
                default:
                    if (n)
                        return Y(t).length;
                    e = ("" + e).toLowerCase(), n = !0
                }
        }
        function y(t, e, i) {
            var n = !1;
            if ((void 0 === e || e < 0) && (e = 0), e > this.length)
                return "";
            if ((void 0 === i || i > this.length) && (i = this.length), i <= 0)
                return "";
            if (i >>>= 0, e >>>= 0, i <= e)
                return "";
            for (t || (t = "utf8");;)
                switch (t) {
                case "hex":
                    return E(this, e, i);
                case "utf8":
                case "utf-8":
                    return T(this, e, i);
                case "ascii":
                    return L(this, e, i);
                case "latin1":
                case "binary":
                    return P(this, e, i);
                case "base64":
                    return k(this, e, i);
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                    return O(this, e, i);
                default:
                    if (n)
                        throw new TypeError("Unknown encoding: " + t);
                    t = (t + "").toLowerCase(), n = !0
                }
        }
        function x(t, e, i) {
            var n = t[e];
            t[e] = t[i], t[i] = n
        }
        function _(t, e, i, n, r) {
            if (0 === t.length)
                return -1;
            if ("string" == typeof i ? (n = i, i = 0) : i > 2147483647 ? i = 2147483647 : i < -2147483648 && (i = -2147483648), i = +i, isNaN(i) && (i = r ? 0 : t.length - 1), i < 0 && (i = t.length + i), i >= t.length) {
                if (r)
                    return -1;
                i = t.length - 1
            } else if (i < 0) {
                if (!r)
                    return -1;
                i = 0
            }
            if ("string" == typeof e && (e = o.from(e, n)), o.isBuffer(e))
                return 0 === e.length ? -1 : b(t, e, i, n, r);
            if ("number" == typeof e)
                return e &= 255, o.TYPED_ARRAY_SUPPORT && "function" == typeof Uint8Array.prototype.indexOf ? r ? Uint8Array.prototype.indexOf.call(t, e, i) : Uint8Array.prototype.lastIndexOf.call(t, e, i) : b(t, [e], i, n, r);
            throw new TypeError("val must be string, number or Buffer")
        }
        function b(t, e, i, n, r) {
            function a(t, e) {
                return 1 === o ? t[e] : t.readUInt16BE(e * o)
            }
            var o = 1,
                s = t.length,
                l = e.length;
            if (void 0 !== n && (n = String(n).toLowerCase(), "ucs2" === n || "ucs-2" === n || "utf16le" === n || "utf-16le" === n)) {
                if (t.length < 2 || e.length < 2)
                    return -1;
                o = 2, s /= 2, l /= 2, i /= 2
            }
            var c;
            if (r) {
                var u = -1;
                for (c = i; c < s; c++)
                    if (a(t, c) === a(e, u === -1 ? 0 : c - u)) {
                        if (u === -1 && (u = c), c - u + 1 === l)
                            return u * o
                    } else
                        u !== -1 && (c -= c - u), u = -1
            } else
                for (i + l > s && (i = s - l), c = i; c >= 0; c--) {
                    for (var h = !0, d = 0; d < l; d++)
                        if (a(t, c + d) !== a(e, d)) {
                            h = !1;
                            break
                        }
                    if (h)
                        return c
                }
            return -1
        }
        function w(t, e, i, n) {
            i = Number(i) || 0;
            var r = t.length - i;
            n ? (n = Number(n), n > r && (n = r)) : n = r;
            var a = e.length;
            if (a % 2 !== 0)
                throw new TypeError("Invalid hex string");
            n > a / 2 && (n = a / 2);
            for (var o = 0; o < n; ++o) {
                var s = parseInt(e.substr(2 * o, 2), 16);
                if (isNaN(s))
                    return o;
                t[i + o] = s
            }
            return o
        }
        function M(t, e, i, n) {
            return j(Y(e, t.length - i), t, i, n)
        }
        function S(t, e, i, n) {
            return j(q(e), t, i, n)
        }
        function A(t, e, i, n) {
            return S(t, e, i, n)
        }
        function I(t, e, i, n) {
            return j(Z(e), t, i, n)
        }
        function D(t, e, i, n) {
            return j(U(e, t.length - i), t, i, n)
        }
        function k(t, e, i) {
            return 0 === e && i === t.length ? K.fromByteArray(t) : K.fromByteArray(t.slice(e, i))
        }
        function T(t, e, i) {
            i = Math.min(t.length, i);
            for (var n = [], r = e; r < i;) {
                var a = t[r],
                    o = null,
                    s = a > 239 ? 4 : a > 223 ? 3 : a > 191 ? 2 : 1;
                if (r + s <= i) {
                    var l,
                        c,
                        u,
                        h;
                    switch (s) {
                    case 1:
                        a < 128 && (o = a);
                        break;
                    case 2:
                        l = t[r + 1], 128 === (192 & l) && (h = (31 & a) << 6 | 63 & l, h > 127 && (o = h));
                        break;
                    case 3:
                        l = t[r + 1], c = t[r + 2], 128 === (192 & l) && 128 === (192 & c) && (h = (15 & a) << 12 | (63 & l) << 6 | 63 & c, h > 2047 && (h < 55296 || h > 57343) && (o = h));
                        break;
                    case 4:
                        l = t[r + 1], c = t[r + 2], u = t[r + 3], 128 === (192 & l) && 128 === (192 & c) && 128 === (192 & u) && (h = (15 & a) << 18 | (63 & l) << 12 | (63 & c) << 6 | 63 & u, h > 65535 && h < 1114112 && (o = h))
                    }
                }
                null === o ? (o = 65533, s = 1) : o > 65535 && (o -= 65536, n.push(o >>> 10 & 1023 | 55296), o = 56320 | 1023 & o), n.push(o), r += s
            }
            return C(n)
        }
        function C(t) {
            var e = t.length;
            if (e <= tt)
                return String.fromCharCode.apply(String, t);
            for (var i = "", n = 0; n < e;)
                i += String.fromCharCode.apply(String, t.slice(n, n += tt));
            return i
        }
        function L(t, e, i) {
            var n = "";
            i = Math.min(t.length, i);
            for (var r = e; r < i; ++r)
                n += String.fromCharCode(127 & t[r]);
            return n
        }
        function P(t, e, i) {
            var n = "";
            i = Math.min(t.length, i);
            for (var r = e; r < i; ++r)
                n += String.fromCharCode(t[r]);
            return n
        }
        function E(t, e, i) {
            var n = t.length;
            (!e || e < 0) && (e = 0), (!i || i < 0 || i > n) && (i = n);
            for (var r = "", a = e; a < i; ++a)
                r += W(t[a]);
            return r
        }
        function O(t, e, i) {
            for (var n = t.slice(e, i), r = "", a = 0; a < n.length; a += 2)
                r += String.fromCharCode(n[a] + 256 * n[a + 1]);
            return r
        }
        function R(t, e, i) {
            if (t % 1 !== 0 || t < 0)
                throw new RangeError("offset is not uint");
            if (t + e > i)
                throw new RangeError("Trying to access beyond buffer length")
        }
        function z(t, e, i, n, r, a) {
            if (!o.isBuffer(t))
                throw new TypeError('"buffer" argument must be a Buffer instance');
            if (e > r || e < a)
                throw new RangeError('"value" argument is out of bounds');
            if (i + n > t.length)
                throw new RangeError("Index out of range")
        }
        function V(t, e, i, n) {
            e < 0 && (e = 65535 + e + 1);
            for (var r = 0, a = Math.min(t.length - i, 2); r < a; ++r)
                t[i + r] = (e & 255 << 8 * (n ? r : 1 - r)) >>> 8 * (n ? r : 1 - r)
        }
        function N(t, e, i, n) {
            e < 0 && (e = 4294967295 + e + 1);
            for (var r = 0, a = Math.min(t.length - i, 4); r < a; ++r)
                t[i + r] = e >>> 8 * (n ? r : 3 - r) & 255
        }
        function B(t, e, i, n, r, a) {
            if (i + n > t.length)
                throw new RangeError("Index out of range");
            if (i < 0)
                throw new RangeError("Index out of range")
        }
        function F(t, e, i, n, r) {
            return r || B(t, e, i, 4, 3.4028234663852886e38, -3.4028234663852886e38), J.write(t, e, i, n, 23, 4), i + 4
        }
        function H(t, e, i, n, r) {
            return r || B(t, e, i, 8, 1.7976931348623157e308, -1.7976931348623157e308), J.write(t, e, i, n, 52, 8), i + 8
        }
        function G(t) {
            if (t = $(t).replace(et, ""), t.length < 2)
                return "";
            for (; t.length % 4 !== 0;)
                t += "=";
            return t
        }
        function $(t) {
            return t.trim ? t.trim() : t.replace(/^\s+|\s+$/g, "")
        }
        function W(t) {
            return t < 16 ? "0" + t.toString(16) : t.toString(16)
        }
        function Y(t, e) {
            e = e || 1 / 0;
            for (var i, n = t.length, r = null, a = [], o = 0; o < n; ++o) {
                if (i = t.charCodeAt(o), i > 55295 && i < 57344) {
                    if (!r) {
                        if (i > 56319) {
                            (e -= 3) > -1 && a.push(239, 191, 189);
                            continue
                        }
                        if (o + 1 === n) {
                            (e -= 3) > -1 && a.push(239, 191, 189);
                            continue
                        }
                        r = i;
                        continue
                    }
                    if (i < 56320) {
                        (e -= 3) > -1 && a.push(239, 191, 189), r = i;
                        continue
                    }
                    i = (r - 55296 << 10 | i - 56320) + 65536
                } else
                    r && (e -= 3) > -1 && a.push(239, 191, 189);
                if (r = null, i < 128) {
                    if ((e -= 1) < 0)
                        break;
                    a.push(i)
                } else if (i < 2048) {
                    if ((e -= 2) < 0)
                        break;
                    a.push(i >> 6 | 192, 63 & i | 128)
                } else if (i < 65536) {
                    if ((e -= 3) < 0)
                        break;
                    a.push(i >> 12 | 224, i >> 6 & 63 | 128, 63 & i | 128)
                } else {
                    if (!(i < 1114112))
                        throw new Error("Invalid code point");
                    if ((e -= 4) < 0)
                        break;
                    a.push(i >> 18 | 240, i >> 12 & 63 | 128, i >> 6 & 63 | 128, 63 & i | 128)
                }
            }
            return a
        }
        function q(t) {
            for (var e = [], i = 0; i < t.length; ++i)
                e.push(255 & t.charCodeAt(i));
            return e
        }
        function U(t, e) {
            for (var i, n, r, a = [], o = 0; o < t.length && !((e -= 2) < 0); ++o)
                i = t.charCodeAt(o), n = i >> 8, r = i % 256, a.push(r), a.push(n);
            return a
        }
        function Z(t) {
            return K.toByteArray(G(t))
        }
        function j(t, e, i, n) {
            for (var r = 0; r < n && !(r + i >= e.length || r >= t.length); ++r)
                e[r + i] = t[r];
            return r
        }
        function X(t) {
            return t !== t
        }
        var K = i(1027),
            J = i(1028),
            Q = i(1029);
        e.Buffer = o, e.SlowBuffer = m, e.INSPECT_MAX_BYTES = 50, o.TYPED_ARRAY_SUPPORT = void 0 !== t.TYPED_ARRAY_SUPPORT ? t.TYPED_ARRAY_SUPPORT : n(), e.kMaxLength = r(), o.poolSize = 8192, o._augment = function(t) {
            return t.__proto__ = o.prototype, t
        }, o.from = function(t, e, i) {
            return s(null, t, e, i)
        }, o.TYPED_ARRAY_SUPPORT && (o.prototype.__proto__ = Uint8Array.prototype, o.__proto__ = Uint8Array, "undefined" != typeof Symbol && Symbol.species && o[Symbol.species] === o && Object.defineProperty(o, Symbol.species, {
            value: null,
            configurable: !0
        })), o.alloc = function(t, e, i) {
            return c(null, t, e, i)
        }, o.allocUnsafe = function(t) {
            return u(null, t)
        }, o.allocUnsafeSlow = function(t) {
            return u(null, t)
        }, o.isBuffer = function(t) {
            return !(null == t || !t._isBuffer)
        }, o.compare = function(t, e) {
            if (!o.isBuffer(t) || !o.isBuffer(e))
                throw new TypeError("Arguments must be Buffers");
            if (t === e)
                return 0;
            for (var i = t.length, n = e.length, r = 0, a = Math.min(i, n); r < a; ++r)
                if (t[r] !== e[r]) {
                    i = t[r], n = e[r];
                    break
                }
            return i < n ? -1 : n < i ? 1 : 0
        }, o.isEncoding = function(t) {
            switch (String(t).toLowerCase()) {
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "latin1":
            case "binary":
            case "base64":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return !0;
            default:
                return !1
            }
        }, o.concat = function(t, e) {
            if (!Q(t))
                throw new TypeError('"list" argument must be an Array of Buffers');
            if (0 === t.length)
                return o.alloc(0);
            var i;
            if (void 0 === e)
                for (e = 0, i = 0; i < t.length; ++i)
                    e += t[i].length;
            var n = o.allocUnsafe(e),
                r = 0;
            for (i = 0; i < t.length; ++i) {
                var a = t[i];
                if (!o.isBuffer(a))
                    throw new TypeError('"list" argument must be an Array of Buffers');
                a.copy(n, r), r += a.length
            }
            return n
        }, o.byteLength = v, o.prototype._isBuffer = !0, o.prototype.swap16 = function() {
            var t = this.length;
            if (t % 2 !== 0)
                throw new RangeError("Buffer size must be a multiple of 16-bits");
            for (var e = 0; e < t; e += 2)
                x(this, e, e + 1);
            return this
        }, o.prototype.swap32 = function() {
            var t = this.length;
            if (t % 4 !== 0)
                throw new RangeError("Buffer size must be a multiple of 32-bits");
            for (var e = 0; e < t; e += 4)
                x(this, e, e + 3), x(this, e + 1, e + 2);
            return this
        }, o.prototype.swap64 = function() {
            var t = this.length;
            if (t % 8 !== 0)
                throw new RangeError("Buffer size must be a multiple of 64-bits");
            for (var e = 0; e < t; e += 8)
                x(this, e, e + 7), x(this, e + 1, e + 6), x(this, e + 2, e + 5), x(this, e + 3, e + 4);
            return this
        }, o.prototype.toString = function() {
            var t = 0 | this.length;
            return 0 === t ? "" : 0 === arguments.length ? T(this, 0, t) : y.apply(this, arguments)
        }, o.prototype.equals = function(t) {
            if (!o.isBuffer(t))
                throw new TypeError("Argument must be a Buffer");
            return this === t || 0 === o.compare(this, t)
        }, o.prototype.inspect = function() {
            var t = "",
                i = e.INSPECT_MAX_BYTES;
            return this.length > 0 && (t = this.toString("hex", 0, i).match(/.{2}/g).join(" "), this.length > i && (t += " ... ")), "<Buffer " + t + ">"
        }, o.prototype.compare = function(t, e, i, n, r) {
            if (!o.isBuffer(t))
                throw new TypeError("Argument must be a Buffer");
            if (void 0 === e && (e = 0), void 0 === i && (i = t ? t.length : 0), void 0 === n && (n = 0), void 0 === r && (r = this.length), e < 0 || i > t.length || n < 0 || r > this.length)
                throw new RangeError("out of range index");
            if (n >= r && e >= i)
                return 0;
            if (n >= r)
                return -1;
            if (e >= i)
                return 1;
            if (e >>>= 0, i >>>= 0, n >>>= 0, r >>>= 0, this === t)
                return 0;
            for (var a = r - n, s = i - e, l = Math.min(a, s), c = this.slice(n, r), u = t.slice(e, i), h = 0; h < l; ++h)
                if (c[h] !== u[h]) {
                    a = c[h], s = u[h];
                    break
                }
            return a < s ? -1 : s < a ? 1 : 0
        }, o.prototype.includes = function(t, e, i) {
            return this.indexOf(t, e, i) !== -1
        }, o.prototype.indexOf = function(t, e, i) {
            return _(this, t, e, i, !0)
        }, o.prototype.lastIndexOf = function(t, e, i) {
            return _(this, t, e, i, !1)
        }, o.prototype.write = function(t, e, i, n) {
            if (void 0 === e)
                n = "utf8", i = this.length, e = 0;
            else if (void 0 === i && "string" == typeof e)
                n = e, i = this.length, e = 0;
            else {
                if (!isFinite(e))
                    throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
                e |= 0, isFinite(i) ? (i |= 0, void 0 === n && (n = "utf8")) : (n = i, i = void 0)
            }
            var r = this.length - e;
            if ((void 0 === i || i > r) && (i = r), t.length > 0 && (i < 0 || e < 0) || e > this.length)
                throw new RangeError("Attempt to write outside buffer bounds");
            n || (n = "utf8");
            for (var a = !1;;)
                switch (n) {
                case "hex":
                    return w(this, t, e, i);
                case "utf8":
                case "utf-8":
                    return M(this, t, e, i);
                case "ascii":
                    return S(this, t, e, i);
                case "latin1":
                case "binary":
                    return A(this, t, e, i);
                case "base64":
                    return I(this, t, e, i);
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                    return D(this, t, e, i);
                default:
                    if (a)
                        throw new TypeError("Unknown encoding: " + n);
                    n = ("" + n).toLowerCase(), a = !0
                }
        }, o.prototype.toJSON = function() {
            return {
                type: "Buffer",
                data: Array.prototype.slice.call(this._arr || this, 0)
            }
        };
        var tt = 4096;
        o.prototype.slice = function(t, e) {
            var i = this.length;
            t = ~~t, e = void 0 === e ? i : ~~e, t < 0 ? (t += i, t < 0 && (t = 0)) : t > i && (t = i), e < 0 ? (e += i, e < 0 && (e = 0)) : e > i && (e = i), e < t && (e = t);
            var n;
            if (o.TYPED_ARRAY_SUPPORT)
                n = this.subarray(t, e), n.__proto__ = o.prototype;
            else {
                var r = e - t;
                n = new o(r, void 0);
                for (var a = 0; a < r; ++a)
                    n[a] = this[a + t]
            }
            return n
        }, o.prototype.readUIntLE = function(t, e, i) {
            t |= 0, e |= 0, i || R(t, e, this.length);
            for (var n = this[t], r = 1, a = 0; ++a < e && (r *= 256);)
                n += this[t + a] * r;
            return n
        }, o.prototype.readUIntBE = function(t, e, i) {
            t |= 0, e |= 0, i || R(t, e, this.length);
            for (var n = this[t + --e], r = 1; e > 0 && (r *= 256);)
                n += this[t + --e] * r;
            return n
        }, o.prototype.readUInt8 = function(t, e) {
            return e || R(t, 1, this.length), this[t]
        }, o.prototype.readUInt16LE = function(t, e) {
            return e || R(t, 2, this.length), this[t] | this[t + 1] << 8
        }, o.prototype.readUInt16BE = function(t, e) {
            return e || R(t, 2, this.length), this[t] << 8 | this[t + 1]
        }, o.prototype.readUInt32LE = function(t, e) {
            return e || R(t, 4, this.length), (this[t] | this[t + 1] << 8 | this[t + 2] << 16) + 16777216 * this[t + 3]
        }, o.prototype.readUInt32BE = function(t, e) {
            return e || R(t, 4, this.length), 16777216 * this[t] + (this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3])
        }, o.prototype.readIntLE = function(t, e, i) {
            t |= 0, e |= 0, i || R(t, e, this.length);
            for (var n = this[t], r = 1, a = 0; ++a < e && (r *= 256);)
                n += this[t + a] * r;
            return r *= 128, n >= r && (n -= Math.pow(2, 8 * e)), n
        }, o.prototype.readIntBE = function(t, e, i) {
            t |= 0, e |= 0, i || R(t, e, this.length);
            for (var n = e, r = 1, a = this[t + --n]; n > 0 && (r *= 256);)
                a += this[t + --n] * r;
            return r *= 128, a >= r && (a -= Math.pow(2, 8 * e)), a
        }, o.prototype.readInt8 = function(t, e) {
            return e || R(t, 1, this.length), 128 & this[t] ? (255 - this[t] + 1) * -1 : this[t]
        }, o.prototype.readInt16LE = function(t, e) {
            e || R(t, 2, this.length);
            var i = this[t] | this[t + 1] << 8;
            return 32768 & i ? 4294901760 | i : i
        }, o.prototype.readInt16BE = function(t, e) {
            e || R(t, 2, this.length);
            var i = this[t + 1] | this[t] << 8;
            return 32768 & i ? 4294901760 | i : i
        }, o.prototype.readInt32LE = function(t, e) {
            return e || R(t, 4, this.length), this[t] | this[t + 1] << 8 | this[t + 2] << 16 | this[t + 3] << 24
        }, o.prototype.readInt32BE = function(t, e) {
            return e || R(t, 4, this.length), this[t] << 24 | this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3]
        }, o.prototype.readFloatLE = function(t, e) {
            return e || R(t, 4, this.length), J.read(this, t, !0, 23, 4)
        }, o.prototype.readFloatBE = function(t, e) {
            return e || R(t, 4, this.length), J.read(this, t, !1, 23, 4)
        }, o.prototype.readDoubleLE = function(t, e) {
            return e || R(t, 8, this.length), J.read(this, t, !0, 52, 8)
        }, o.prototype.readDoubleBE = function(t, e) {
            return e || R(t, 8, this.length), J.read(this, t, !1, 52, 8)
        }, o.prototype.writeUIntLE = function(t, e, i, n) {
            if (t = +t, e |= 0, i |= 0, !n) {
                var r = Math.pow(2, 8 * i) - 1;
                z(this, t, e, i, r, 0)
            }
            var a = 1,
                o = 0;
            for (this[e] = 255 & t; ++o < i && (a *= 256);)
                this[e + o] = t / a & 255;
            return e + i
        }, o.prototype.writeUIntBE = function(t, e, i, n) {
            if (t = +t, e |= 0, i |= 0, !n) {
                var r = Math.pow(2, 8 * i) - 1;
                z(this, t, e, i, r, 0)
            }
            var a = i - 1,
                o = 1;
            for (this[e + a] = 255 & t; --a >= 0 && (o *= 256);)
                this[e + a] = t / o & 255;
            return e + i
        }, o.prototype.writeUInt8 = function(t, e, i) {
            return t = +t, e |= 0, i || z(this, t, e, 1, 255, 0), o.TYPED_ARRAY_SUPPORT || (t = Math.floor(t)), this[e] = 255 & t, e + 1
        }, o.prototype.writeUInt16LE = function(t, e, i) {
            return t = +t, e |= 0, i || z(this, t, e, 2, 65535, 0), o.TYPED_ARRAY_SUPPORT ? (this[e] = 255 & t, this[e + 1] = t >>> 8) : V(this, t, e, !0), e + 2
        }, o.prototype.writeUInt16BE = function(t, e, i) {
            return t = +t, e |= 0, i || z(this, t, e, 2, 65535, 0), o.TYPED_ARRAY_SUPPORT ? (this[e] = t >>> 8, this[e + 1] = 255 & t) : V(this, t, e, !1), e + 2
        }, o.prototype.writeUInt32LE = function(t, e, i) {
            return t = +t, e |= 0, i || z(this, t, e, 4, 4294967295, 0), o.TYPED_ARRAY_SUPPORT ? (this[e + 3] = t >>> 24, this[e + 2] = t >>> 16, this[e + 1] = t >>> 8, this[e] = 255 & t) : N(this, t, e, !0), e + 4
        }, o.prototype.writeUInt32BE = function(t, e, i) {
            return t = +t, e |= 0, i || z(this, t, e, 4, 4294967295, 0), o.TYPED_ARRAY_SUPPORT ? (this[e] = t >>> 24, this[e + 1] = t >>> 16, this[e + 2] = t >>> 8, this[e + 3] = 255 & t) : N(this, t, e, !1), e + 4
        }, o.prototype.writeIntLE = function(t, e, i, n) {
            if (t = +t, e |= 0, !n) {
                var r = Math.pow(2, 8 * i - 1);
                z(this, t, e, i, r - 1, -r)
            }
            var a = 0,
                o = 1,
                s = 0;
            for (this[e] = 255 & t; ++a < i && (o *= 256);)
                t < 0 && 0 === s && 0 !== this[e + a - 1] && (s = 1), this[e + a] = (t / o >> 0) - s & 255;
            return e + i
        }, o.prototype.writeIntBE = function(t, e, i, n) {
            if (t = +t, e |= 0, !n) {
                var r = Math.pow(2, 8 * i - 1);
                z(this, t, e, i, r - 1, -r)
            }
            var a = i - 1,
                o = 1,
                s = 0;
            for (this[e + a] = 255 & t; --a >= 0 && (o *= 256);)
                t < 0 && 0 === s && 0 !== this[e + a + 1] && (s = 1), this[e + a] = (t / o >> 0) - s & 255;
            return e + i
        }, o.prototype.writeInt8 = function(t, e, i) {
            return t = +t, e |= 0, i || z(this, t, e, 1, 127, -128), o.TYPED_ARRAY_SUPPORT || (t = Math.floor(t)), t < 0 && (t = 255 + t + 1), this[e] = 255 & t, e + 1
        }, o.prototype.writeInt16LE = function(t, e, i) {
            return t = +t, e |= 0, i || z(this, t, e, 2, 32767, -32768), o.TYPED_ARRAY_SUPPORT ? (this[e] = 255 & t, this[e + 1] = t >>> 8) : V(this, t, e, !0), e + 2
        }, o.prototype.writeInt16BE = function(t, e, i) {
            return t = +t, e |= 0, i || z(this, t, e, 2, 32767, -32768), o.TYPED_ARRAY_SUPPORT ? (this[e] = t >>> 8, this[e + 1] = 255 & t) : V(this, t, e, !1), e + 2
        }, o.prototype.writeInt32LE = function(t, e, i) {
            return t = +t, e |= 0, i || z(this, t, e, 4, 2147483647, -2147483648), o.TYPED_ARRAY_SUPPORT ? (this[e] = 255 & t, this[e + 1] = t >>> 8, this[e + 2] = t >>> 16, this[e + 3] = t >>> 24) : N(this, t, e, !0), e + 4
        }, o.prototype.writeInt32BE = function(t, e, i) {
            return t = +t, e |= 0, i || z(this, t, e, 4, 2147483647, -2147483648), t < 0 && (t = 4294967295 + t + 1), o.TYPED_ARRAY_SUPPORT ? (this[e] = t >>> 24, this[e + 1] = t >>> 16, this[e + 2] = t >>> 8, this[e + 3] = 255 & t) : N(this, t, e, !1), e + 4
        }, o.prototype.writeFloatLE = function(t, e, i) {
            return F(this, t, e, !0, i)
        }, o.prototype.writeFloatBE = function(t, e, i) {
            return F(this, t, e, !1, i)
        }, o.prototype.writeDoubleLE = function(t, e, i) {
            return H(this, t, e, !0, i)
        }, o.prototype.writeDoubleBE = function(t, e, i) {
            return H(this, t, e, !1, i)
        }, o.prototype.copy = function(t, e, i, n) {
            if (i || (i = 0), n || 0 === n || (n = this.length), e >= t.length && (e = t.length), e || (e = 0), n > 0 && n < i && (n = i), n === i)
                return 0;
            if (0 === t.length || 0 === this.length)
                return 0;
            if (e < 0)
                throw new RangeError("targetStart out of bounds");
            if (i < 0 || i >= this.length)
                throw new RangeError("sourceStart out of bounds");
            if (n < 0)
                throw new RangeError("sourceEnd out of bounds");
            n > this.length && (n = this.length), t.length - e < n - i && (n = t.length - e + i);
            var r,
                a = n - i;
            if (this === t && i < e && e < n)
                for (r = a - 1; r >= 0; --r)
                    t[r + e] = this[r + i];
            else if (a < 1e3 || !o.TYPED_ARRAY_SUPPORT)
                for (r = 0; r < a; ++r)
                    t[r + e] = this[r + i];
            else
                Uint8Array.prototype.set.call(t, this.subarray(i, i + a), e);
            return a
        }, o.prototype.fill = function(t, e, i, n) {
            if ("string" == typeof t) {
                if ("string" == typeof e ? (n = e, e = 0, i = this.length) : "string" == typeof i && (n = i, i = this.length), 1 === t.length) {
                    var r = t.charCodeAt(0);
                    r < 256 && (t = r)
                }
                if (void 0 !== n && "string" != typeof n)
                    throw new TypeError("encoding must be a string");
                if ("string" == typeof n && !o.isEncoding(n))
                    throw new TypeError("Unknown encoding: " + n)
            } else
                "number" == typeof t && (t &= 255);
            if (e < 0 || this.length < e || this.length < i)
                throw new RangeError("Out of range index");
            if (i <= e)
                return this;
            e >>>= 0, i = void 0 === i ? this.length : i >>> 0, t || (t = 0);
            var a;
            if ("number" == typeof t)
                for (a = e; a < i; ++a)
                    this[a] = t;
            else {
                var s = o.isBuffer(t) ? t : Y(new o(t, n).toString()),
                    l = s.length;
                for (a = 0; a < i - e; ++a)
                    this[a + e] = s[a % l]
            }
            return this
        };
        var et = /[^+\/0-9A-Za-z-_]/g
    }).call(e, function() {
        return this
    }())
}, function(t, e) {
    "use strict";
    function i(t) {
        var e = t.length;
        if (e % 4 > 0)
            throw new Error("Invalid string. Length must be a multiple of 4");
        return "=" === t[e - 2] ? 2 : "=" === t[e - 1] ? 1 : 0
    }
    function n(t) {
        return 3 * t.length / 4 - i(t)
    }
    function r(t) {
        var e,
            n,
            r,
            a,
            o,
            s,
            l = t.length;
        o = i(t), s = new u(3 * l / 4 - o), r = o > 0 ? l - 4 : l;
        var h = 0;
        for (e = 0, n = 0; e < r; e += 4, n += 3)
            a = c[t.charCodeAt(e)] << 18 | c[t.charCodeAt(e + 1)] << 12 | c[t.charCodeAt(e + 2)] << 6 | c[t.charCodeAt(e + 3)], s[h++] = a >> 16 & 255, s[h++] = a >> 8 & 255, s[h++] = 255 & a;
        return 2 === o ? (a = c[t.charCodeAt(e)] << 2 | c[t.charCodeAt(e + 1)] >> 4, s[h++] = 255 & a) : 1 === o && (a = c[t.charCodeAt(e)] << 10 | c[t.charCodeAt(e + 1)] << 4 | c[t.charCodeAt(e + 2)] >> 2, s[h++] = a >> 8 & 255, s[h++] = 255 & a), s
    }
    function a(t) {
        return l[t >> 18 & 63] + l[t >> 12 & 63] + l[t >> 6 & 63] + l[63 & t]
    }
    function o(t, e, i) {
        for (var n, r = [], o = e; o < i; o += 3)
            n = (t[o] << 16) + (t[o + 1] << 8) + t[o + 2], r.push(a(n));
        return r.join("")
    }
    function s(t) {
        for (var e, i = t.length, n = i % 3, r = "", a = [], s = 16383, c = 0, u = i - n; c < u; c += s)
            a.push(o(t, c, c + s > u ? u : c + s));
        return 1 === n ? (e = t[i - 1], r += l[e >> 2], r += l[e << 4 & 63], r += "==") : 2 === n && (e = (t[i - 2] << 8) + t[i - 1], r += l[e >> 10], r += l[e >> 4 & 63], r += l[e << 2 & 63], r += "="), a.push(r), a.join("")
    }
    e.byteLength = n, e.toByteArray = r, e.fromByteArray = s;
    for (var l = [], c = [], u = "undefined" != typeof Uint8Array ? Uint8Array : Array, h = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", d = 0, p = h.length; d < p; ++d)
        l[d] = h[d], c[h.charCodeAt(d)] = d;
    c["-".charCodeAt(0)] = 62, c["_".charCodeAt(0)] = 63
}, function(t, e) {
    e.read = function(t, e, i, n, r) {
        var a,
            o,
            s = 8 * r - n - 1,
            l = (1 << s) - 1,
            c = l >> 1,
            u = -7,
            h = i ? r - 1 : 0,
            d = i ? -1 : 1,
            p = t[e + h];
        for (h += d, a = p & (1 << -u) - 1, p >>= -u, u += s; u > 0; a = 256 * a + t[e + h], h += d, u -= 8)
            ;
        for (o = a & (1 << -u) - 1, a >>= -u, u += n; u > 0; o = 256 * o + t[e + h], h += d, u -= 8)
            ;
        if (0 === a)
            a = 1 - c;
        else {
            if (a === l)
                return o ? NaN : (p ? -1 : 1) * (1 / 0);
            o += Math.pow(2, n), a -= c
        }
        return (p ? -1 : 1) * o * Math.pow(2, a - n)
    }, e.write = function(t, e, i, n, r, a) {
        var o,
            s,
            l,
            c = 8 * a - r - 1,
            u = (1 << c) - 1,
            h = u >> 1,
            d = 23 === r ? Math.pow(2, -24) - Math.pow(2, -77) : 0,
            p = n ? 0 : a - 1,
            f = n ? 1 : -1,
            g = e < 0 || 0 === e && 1 / e < 0 ? 1 : 0;
        for (e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (s = isNaN(e) ? 1 : 0, o = u) : (o = Math.floor(Math.log(e) / Math.LN2), e * (l = Math.pow(2, -o)) < 1 && (o--, l *= 2), e += o + h >= 1 ? d / l : d * Math.pow(2, 1 - h), e * l >= 2 && (o++, l /= 2), o + h >= u ? (s = 0, o = u) : o + h >= 1 ? (s = (e * l - 1) * Math.pow(2, r), o += h) : (s = e * Math.pow(2, h - 1) * Math.pow(2, r), o = 0)); r >= 8; t[i + p] = 255 & s, p += f, s /= 256, r -= 8)
            ;
        for (o = o << r | s, c += r; c > 0; t[i + p] = 255 & o, p += f, o /= 256, c -= 8)
            ;
        t[i + p - f] |= 128 * g
    }
}, function(t, e) {
    var i = {}.toString;
    t.exports = Array.isArray || function(t) {
        return "[object Array]" == i.call(t)
    }
}, , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , function(t, e, i) {
    "use strict";
    i(1061);
    var n = i(405);
    t.exports = n.module("ads", [i(1063).name, i(1064).name, i(1065).name, i(1066).name, i(1069).name, i(1070).name]).config(["$stateProvider", function(t) {
        "ngInject";
        t.state("ads", {
            url: "/ads?instance_id",
            abstract: !0,
            views: {
                main: {
                    template: '<ui-view class="ads-scope"/>'
                }
            },
            resolve: {}
        }), t.state("ads.default", {
            url: "",
            template: i(1073),
            controller: "adsMealListCtrl",
            controllerAs: "vm"
        }), t.state("ads.meal", {
            url: "/meal?meal_id",
            abstract: !0,
            template: "<ui-view/>",
            resolve: {
                meal: ["$stateParams", "$adsData", "$_yaq", function(t, e, i) {
                    return e.getMeal(t.meal_id).catch(function(t) {
                        i.broadMsgFn({
                            msg: t.description
                        })
                    })
                }]
            }
        }), t.state("ads.meal.default", {
            url: "",
            template: i(1074),
            controller: "adsMealCtrl",
            controllerAs: "vm"
        }), t.state("ads.meal.service", {
            url: "/service?service_id&type",
            controller: "adsServiceCtrl",
            controllerAs: "vm",
            template: i(1075),
            resolve: {
                service: ["$stateParams", "$adsData", "meal", function(t, e, i) {
                    return e.getService(i, t.service_id, t.type)
                }]
            }
        }), t.state("ads.meal.list", {
            url: "/list?tab",
            controller: "adsBwlistCtrl",
            controllerAs: "vm",
            template: i(1076)
        }), t.state("ads.meal.report", {
            url: "/report",
            controller: "adsReportCtrl",
            controllerAs: "vm",
            template: i(1077)
        })
    }]).filter("adsIspToZH", function() {
        return function(t) {
            var e = {
                mobile: "移动",
                unicom: "联通",
                telecom: "电信"
            };
            return e[t] || t
        }
    })
}, function(t, e, i) {
    var n = i(1062);
    "string" == typeof n && (n = [[t.id, n, ""]]);
    i(307)(n, {});
    n.locals && (t.exports = n.locals)
}, function(t, e, i) {
    e = t.exports = i(301)(), e.push([t.id, ".ads-scope th{background-color:#f9f9f9!important;font-size:16px!important;padding:10px!important;text-align:center!important;border:0!important}.ads-scope tr{border:1px solid #eaedf1}.ads-scope td{text-align:center}.ads-scope td div{margin:5px}.ads-scope .form-horizontal .form-group .control-label{text-align:left;padding-right:0}.ads-scope .block-options button{border-radius:3px;margin-right:14px}.ads-scope .report .dropdown .dropdown-toggle,a{cursor:pointer}.ads-scope .report .dropdown-menu-right{min-width:220px}.ads-scope .report .dropdown-menu-right .btn:hover{background-color:#1bbae1;color:#fff}.ads-scope .btn-link{padding:0;margin:0;border:0}", ""])
}, function(t, e, i) {
    (function(e) {
        "use strict";
        var n = i(405);
        t.exports = n.module("ads.service", []).factory("$adsData", ["$rootScope", "$_http", "$window", function(t, i, n) {
            "ngInject";
            function r(e, n) {
                return i.reqPostFn("addos/ads_query_meal", {
                    instance_id: t.base.ID,
                    page: e,
                    per_page: n
                }).then(function(t) {
                    return t.data
                })
            }
            function a(n) {
                return e.extend(n, {
                    instance_id: t.base.ID
                }), i.reqPostFn("addos/ads_config", n).then(function(t) {
                    return t.data
                })
            }
            function o(e) {
                return i.reqPostFn("addos/ads_search", {
                    instance_id: t.base.ID,
                    meal_id: e
                }).then(function(t) {
                    return t.data
                })
            }
            function s(t, e, i) {
                if (!~["http", "https", "tcp"].indexOf(i))
                    throw new Error;
                if (e) {
                    var n = t.services.find(function(t) {
                        return t.service_id == e
                    });
                    if (n && n.type === i)
                        return n;
                    throw new Error
                }
                switch (i) {
                case "http":
                    return {
                        port: 80,
                        type: "http",
                        domains: [],
                        upstream_ips: []
                    };
                case "https":
                    return {
                        port: 443,
                        type: "https",
                        domains: [],
                        upstream_ips: [],
                        keyserver: []
                    };
                case "tcp":
                    return {
                        type: "http",
                        haproxy: !1,
                        upstream_ips: []
                    };
                default:
                    return {}
                }
            }
            function l(t, e, i) {
                var n = {
                    meal_id: e,
                    services: [t]
                };
                return a(n)
            }
            function c(t) {
                return i.reqPostFn("addos/ads_privatekey", t).then(function(t) {
                    return t.data
                })
            }
            function u(e) {
                return i.reqPostFn("addos/ads_all", {
                    instance_id: t.base.ID,
                    meal_id: e
                }, {
                    ignoreLoadingBar: !0
                }).then(function(t) {
                    return t.data
                })
            }
            function h(n) {
                return e.extend(n, {
                    instance_id: t.base.ID
                }), i.reqPostFn("addos/ads_history_ddos", n).then(function(t) {
                    return t.data.ddos
                })
            }
            function d(n) {
                return e.extend(n, {
                    instance_id: t.base.ID
                }), i.reqPostFn("addos/ads_history_cc", n).then(function(t) {
                    return t.data.cc
                })
            }
            function p(n) {
                return e.extend(n, {
                    instance_id: t.base.ID
                }), i.reqPostFn("addos/ads_history_tcp", n).then(function(t) {
                    return t.data.tcp
                })
            }
            return {
                getMealList: r,
                setMeal: a,
                getMeal: o,
                getService: s,
                setService: l,
                checkPrivateKey: c,
                getLiveAll: u,
                getHistoryDdos: h,
                getHistoryCc: d,
                getHistoryTcp: p
            }
        }])
    }).call(e, i(482))
}, function(t, e, i) {
    "use strict";
    var n = i(405);
    t.exports = n.module("ads.mealList", []).controller("adsMealListCtrl", ["$scope", "$state", "$adsData", "$_yaq", function(t, e, i, n) {
        "ngInject";
        var r = this;
        r.mealList = [], r.isFetching = !1, r.total, r.fetchDataFn = function() {
            var t = 5;
            if (!r.isFetching && r.mealList.length != r.total) {
                r.isFetching = !0;
                var e = r.mealList.length / t + 1;
                i.getMealList(e, t).then(function(t) {
                    r.total = t.total, r.mealList = r.mealList.concat(t.data)
                }).catch(function(t) {}).then(function() {
                    r.isFetching = !1
                })
            }
        }, r.$onInit = function() {
            r.fetchDataFn()
        }
    }])
}, function(t, e, i) {
    "use strict";
    var n = i(405);
    t.exports = n.module("ads.meal", []).controller("adsMealCtrl", ["$rootScope", "$scope", "$_yaq", "$stateParams", "$state", "$uibModal", "$adsData", "meal", function(t, e, i, r, a, o, s, l) {
        "ngInject";
        function c(t) {
            o.open({
                templateUrl: "addos/meal/modalDeleteConfig.html",
                size: "sm",
                animation: !1,
                backdrop: "static"
            }).result.then(function() {
                s.setMeal({
                    meal_id: r.meal_id,
                    services: [{
                        service_id: t,
                        service_action: "delete"
                    }]
                }).then(function() {
                    return a.reload()
                }).catch(function(t) {
                    i.broadMsgFn({
                        msg: t.description
                    })
                })
            }).catch(function() {})
        }
        var u = this;
        u.openModalDeleteConfigFn = c, u.meal = n.copy(l), u.cc_sensitivity = u.meal.cc_sensitivity || 0, u.cc_sensitivity > 100 && (u.cc_sensitivity = 100), u.onCcChange = function(t) {
            if (null != t) {
                if (100 == t)
                    switch (u.meal.cc_sensitivity) {
                    case 0:
                        t = 102;
                        break;
                    case 1:
                    case 2:
                    case 3:
                        t += u.meal.cc_sensitivity;
                        break;
                    default:
                        t = u.meal.cc_sensitivity
                    }
                [0, 1, 2, 3, 101, 102, 103].indexOf(t) != -1 && t != u.meal.cc_sensitivity && s.setMeal({
                    meal_id: r.meal_id,
                    cc_sensitivity: t
                }).catch(function(t) {
                    i.broadMsgFn({
                        msg: t.description
                    })
                }).then(function() {
                    return a.reload()
                })
            }
        }
    }])
}, function(t, e, i) {
    (function(e, n) {
        "use strict";
        function r(t, n, r, a, o, s, l, c, u, h) {
            "ngInject";
            function d(t, i) {
                return e.omit(t, function(t, n) {
                    return e.isEqual(i[n], t)
                })
            }
            function p(t) {
                return l(function(e, i) {
                    var n = new FileReader;
                    n.onloadend = function() {
                        this.error ? i(this.error) : e(this.result)
                    }, n.readAsText(t)
                })
            }
            function f() {
                try {
                    if (("http" === r.type || "https" === r.type) && !x.service.domains.length)
                        throw null
                } catch (t) {
                    return void s.broadMsgFn({
                        msg: "请先添加域名"
                    })
                }
                try {
                    if (!x.service.upstream_ips.length)
                        throw null
                } catch (t) {
                    return void s.broadMsgFn({
                        msg: "请先添加源站IP"
                    })
                }
                try {
                    if ("https" === r.type && x.keyless && !x.service.keyserver.length)
                        throw null
                } catch (t) {
                    return void s.broadMsgFn({
                        msg: "请先添加KeyLess"
                    })
                }
                return "tcp" != r.type || (x.service.empty_conn_defense = parseInt(x.service.empty_conn_defense) || 0, /\-/.test(x.portRange) ? (x.service.port_end = parseInt(x.portRange.split("-")[1]), x.service.port = parseInt(x.portRange.split("-")[0])) : (x.service.port = parseInt(x.portRange), x.service.port_end = parseInt(x.portRange)), x.service.upstream_ips.every(function(t) {
                    return x.service.port_end - x.service.port == t.port_end - t.port
                })) ? new Promise(function(t, e) {
                    "https" != r.type ? t(x.service) : Promise.all(x.service.domains.map(function(t) {
                        return Promise.resolve()
                    })).then(function() {
                        t(x.service)
                    }).catch(function(t) {
                        e(t)
                    })
                }).then(function(t) {
                    return t.port = parseInt(t.port) || void 0, r.service_id ? (t.service_id = r.service_id, t.service_action = "modify") : (t.type = r.type, t.service_action = "add"), c.setService(t, r.meal_id, r.type)
                }).then(function() {
                    return a.go("^.default", {}, {
                        reload: !0
                    })
                }).catch(function(t) {
                    s.broadMsgFn({
                        msg: t.description
                    })
                }) : void s.broadMsgFn({
                    msg: "端口范围不匹配，请重新输入"
                })
            }
            function g(t) {
                var e = "http" === r.type,
                    n = void 0 !== t;
                x.service.domains = x.service.domains || [];
                var a = x.service.domains[t];
                o.open({
                    template: i(1067),
                    controller: ["$uibModalInstance", function(t) {
                        var i = this;
                        i.isEdit = n, i.isHttp = e, e ? i.domain = {
                            domain: a || ""
                        } : (i.domain = _.copy(a) || {}, i.isHttpEnabled = Boolean(i.domain.http), i.domain.keyless = Boolean(i.domain.keyless)), i.close = function() {
                            return e ? t.close(i.domain) : void Promise.resolve(i.domain).then(function(t) {
                                return i.cert ? p(i.cert).then(function(e) {
                                    return t.cert = e, t
                                }).catch(function(t) {
                                    throw {
                                        description: "获取公钥失败"
                                    }
                                }) : t
                            }).then(function(t) {
                                return i.private_key ? p(i.private_key).then(function(e) {
                                    return t.private_key = e, t
                                }).catch(function(t) {
                                    throw {
                                        description: "获取私钥失败"
                                    }
                                }) : t
                            }).then(function(e) {
                                if (!e.keyless && !e.private_key)
                                    throw {
                                        description: "请选择私钥"
                                    };
                                i.isHttpEnabled ? (e.http = parseInt(e.http) || void 0, e.upstream_http = parseInt(e.upstream_http) || void 0) : (e.http = void 0, e.upstream_http = void 0), t.close(e)
                            }).catch(function(t) {
                                s.broadMsgFn({
                                    msg: t.description
                                })
                            })
                        }
                    }],
                    controllerAs: "vm",
                    size: "md",
                    animation: !1,
                    backdrop: "static"
                }).result.then(function(i) {
                    e && (i = i.domain), n ? x.service.domains[t] = i : x.service.domains.push(i)
                }).catch(function() {})
            }
            function m(t) {
                var e = void 0 !== t,
                    n = x.service.upstream_ips;
                o.open({
                    template: i(1068),
                    controller: function() {
                        var i = this;
                        i.isEdit = e, e ? (i.upstream_ip = _.copy(n[t]), "tcp" == r.type && (i.upstream_ip.port_end && i.upstream_ip.port != i.upstream_ip.port_end ? i.portRange = "" + (i.upstream_ip.port || "") + (i.upstream_ip.port_end ? "-" : "") + (i.upstream_ip.port_end || "") : i.portRange = i.upstream_ip.port)) : i.upstream_ip = {
                            isp: "mobile",
                            lock: !1
                        }
                    },
                    controllerAs: "vm",
                    size: "md",
                    animation: !1,
                    backdrop: "static"
                }).result.then(function(i) {
                    var n = i.upstream_ip;
                    "tcp" == r.type ? /\-/.test(i.portRange) ? (n.port_end = parseInt(i.portRange.split("-")[1]), n.port = parseInt(i.portRange.split("-")[0])) : (n.port = parseInt(i.portRange), n.port_end = parseInt(i.portRange)) : n.port = parseInt(n.port), x.service.upstream_ips = x.service.upstream_ips || [], e ? x.service.upstream_ips[t] = n : x.service.upstream_ips.push(n)
                }).catch(function() {})
            }
            function v() {
                return e.isEmpty(d(x.service, h)) || 1 != x.meal.order_status || !t.base.authority ? a.go("ads.meal.default") : void o.open({
                    templateUrl: "addos/service/modalAlert.html",
                    size: "sm",
                    animation: !1,
                    backdrop: "static"
                }).result.then(function() {
                    return a.go("ads.meal.default")
                }).catch(function() {})
            }
            function y(t) {
                function e() {
                    var e = this;
                    e.isEdit = i, i ? e.keyserver = _.copy(n[t]) : e.keyserver = {
                        isp: "mobile"
                    }
                }
                var i = void 0 !== t,
                    n = x.service.keyserver;
                o.open({
                    templateUrl: "addos/service/modalAddKeyLess.html",
                    controller: e,
                    controllerAs: "vm",
                    size: "md",
                    animation: !1,
                    backdrop: "static"
                }).result.then(function(e) {
                    e.port = parseInt(e.port) || void 0, x.service.keyserver = x.service.keyserver || [], i ? x.service.keyserver[t] = e : x.service.keyserver.push(e)
                }).catch(function() {})
            }
            var x = this;
            x.meal = u, x.service = n.service = _.copy(h), x.saveServiceFn = f, x.openModalAddDomainFn = g, x.openModalAddUpstreamFn = m, x.openModalAddKeyLessFn = y, x.openModalAlertFn = v, "tcp" === r.type && (x.service.port_end && x.service.port != x.service.port_end ? x.portRange = "" + (x.service.port || "") + (x.service.port_end ? "-" : "") + (x.service.port_end || "") : x.portRange = x.service.port), "https" === r.type && n.$watchCollection("vm.service.domains", function(t) {
                t ? x.keyless = !!t.find(function(t) {
                    return t && t.keyless
                }) : x.keyless = !1, x.keyless || (x.service.keyserver = [])
            })
        }
        function a() {
            return function(t) {
                return t ? "是" : "否"
            }
        }
        function o() {
            return {
                require: "ngModel",
                link: function(t, e, i, n) {
                    n.$formatters.push(function(t) {
                        return Number(t)
                    }), n.$validators.port = function(t, i) {
                        var n = /^[1-9]\d*$/.test(i) && i >= 1 && i <= 65535;
                        return n || e.next(".v-msg").text("端口格式错误"), n
                    }
                }
            }
        }
        function s() {
            return {
                require: "ngModel",
                link: function(t, e, i, n) {
                    n.$formatters.push(function(t) {
                        return Number(t)
                    }), n.$validators.port = function(t, i) {
                        var n = /^[1-9]\d*$/.test(i) && i >= 1 && i <= 65535 && (i < 81 || i > 87) && 62222 != i;
                        return n || e.next(".v-msg").text("端口格式错误"), n
                    }
                }
            }
        }
        function l() {
            return {
                require: "ngModel",
                link: function(t, e, i, n) {
                    n.$validators.portRange = function(t, i) {
                        var n = !0;
                        try {
                            if (!/^[1-9]\d*(\-[1-9]\d*)?$/.test(i))
                                throw new Error;
                            i = i + "-" + i;
                            var r = parseInt(i.split("-")[0]),
                                a = parseInt(i.split("-")[1]);
                            if (r < 1 || r > 65535)
                                throw new Error;
                            if (a < 1 || a > 65535)
                                throw new Error;
                            if (r > a)
                                throw new Error;
                            for (var o = r; o <= a; o++)
                                if ([62222, 80, 81, 82, 83, 84, 85, 86, 87].indexOf(o) != -1)
                                    throw new Error
                        } catch (t) {
                            n = !1
                        }
                        return n || e.next(".v-msg").text("端口格式错误"), n
                    }
                }
            }
        }
        function c() {
            return {
                require: "ngModel",
                link: function(t, e, i, n) {
                    n.$validators.domain = function(t, e) {
                        return /^(\*\.)?([a-zA-Z0-9\-]+\.)+[a-zA-Z]{2,}$/.test(e) && !/--/.test(e) && !/\.\-|\-\./.test(e)
                    }, e.next(".v-msg").text("域名格式错误")
                }
            }
        }
        function u() {
            return {
                require: "ngModel",
                link: function(t, i, n, r) {
                    r.$validators.ipRange = function(t, i) {
                        if (/((^|\.)((25[0-5])|(2[0-4]\d)|(1\d\d)|([1-9]?\d))){4}((-|\.)((25[0-5])|(2[0-4]\d)|(1\d\d)|([1-9]?\d))){4}$/.test(i)) {
                            var n = i.split("-");
                            return n[0] = e.reduce(n[0].split("."), function(t, e) {
                                return t + e
                            }, ""), n[1] = e.reduce(n[1].split("."), function(t, e) {
                                return t + e
                            }, ""), n[0] < n[1]
                        }
                        return /((^|\.)((25[0-5])|(2[0-4]\d)|(1\d\d)|([1-9]?\d))){4}(\/(?:\d|[12]\d|3[01]))?$/.test(i) || /((^|\.)((25[0-5])|(2[0-4]\d)|(1\d\d)|([1-9]?\d))){4}(((,|\.)((25[0-5])|(2[0-4]\d)|(1\d\d)|([1-9]?\d))){4})*$/.test(i)
                    }, i.next(".v-msg").text("IP格式错误")
                }
            }
        }
        function h() {
            return {
                require: "ngModel",
                link: function(t, e, i, n) {
                    n.$validators.urlWithWildcard = function(t, e) {
                        if (/[-a-zA-Z0-9@:%_\+.~#?&\/\/=\*]{2,256}\.[a-z\*]{2,4}\b(\/[-a-zA-Z0-9@:%_\+.~#?&\/\/=\*]*)?/.test(e) && !/(^\-|\-\-|\.\-|\-\.|\*\*|\-$)/.test(e)) {
                            var i = e.split("/")[0];
                            return /^(([a-zA-Z]{1})|([a-zA-Z]{1}[a-zA-Z]{1})|([a-zA-Z]{1}[0-9]{1})|([0-9]{1}[a-zA-Z]{1})|([a-zA-Z0-9][a-zA-Z0-9-_]{1,61}[a-zA-Z0-9]))\.([a-zA-Z]{2,6}|[a-zA-Z0-9-]{2,30}\.[a-zA-Z]{2,3})$/.test(i)
                        }
                        return !1
                    }, e.next(".v-msg").text("URL格式错误")
                }
            }
        }
        function d() {
            return {
                require: "ngModel",
                link: function(t, e, i, n) {
                    n.$validators.urlWithWildcard = function(t, e) {
                        return /^[-a-zA-Z0-9@:%._\+~#=]{2,256}\.[a-z]{2,6}\b([-a-zA-Z0-9@:%_\+.~#?&\/\/=]*)$/.test(e) && !/(^\-|\-\-|\.\-|\-\.|\*\*|\-$)/.test(e)
                    }, e.next(".v-msg").text("URL格式错误")
                }
            }
        }
        function p() {
            return {
                require: "ngModel",
                link: function(t, e, i, n) {
                    n.$validators.ip = function(t, e) {
                        return /((^|\.)((25[0-5])|(2[0-4]\d)|(1\d\d)|([1-9]?\d))){4}$/.test(e)
                    }, e.next(".v-msg").text("IP格式错误")
                }
            }
        }
        function f() {
            return {
                require: "ngModel",
                link: function(t, e, i, n) {
                    n.$validators.emptyConnDefense = function(t, e) {
                        return /^([1-9]+\d*)$|^0$/.test(e)
                    }, e.next(".v-msg").text("空链接超时格式错误")
                }
            }
        }
        function g() {
            return {
                require: "ngModel",
                link: function(t, e, i, r) {
                    r.$validators.dateTime = function(t, e) {
                        return n(e, "YYYYMMDDHHmm").isValid()
                    }, e.next(".v-msg").text("时间格式错误")
                }
            }
        }
        function m() {
            return {
                require: "ngModel",
                scope: {
                    vMax: "@"
                },
                link: function(t, e, i, n) {
                    n.$validators.max = function(e, i) {
                        return !t.vMax || parseInt(e) <= parseInt(t.vMax)
                    }, e.next(".v-msg").text("必须小于等于" + t.vMax)
                }
            }
        }
        function v() {
            return {
                require: "ngModel",
                scope: {
                    vMin: "@"
                },
                link: function(t, e, i, n) {
                    n.$validators.min = function(e, i) {
                        return !t.vMin || parseInt(e) >= parseInt(t.vMin)
                    }, e.next(".v-msg").text("必须大于等于" + t.vMin)
                }
            }
        }
        function y() {
            return {
                require: "ngModel",
                scope: {
                    vExcept: "@"
                },
                link: function(t, i, n, r) {
                    var a = (t.vExcept || "").split(" ");
                    r.$validators.except = function(n, r) {
                        var o = !e.find(a, function(t) {
                            return t == r
                        });
                        return o || i.next(".v-msg").text('不能输入"' + t.vExcept + '"'), o
                    }
                }
            }
        }
        function x() {
            return {
                require: "ngModel",
                link: function(t, e, i, n) {
                    n.$validators.domainOrIp = function(t, e) {
                        return /^([a-zA-Z0-9\-]+\.)+[a-zA-Z]{2,}$/.test(e) && !/--/.test(e) && !/\.\-|\-\./.test(e) || /^((^|\.)((25[0-5])|(2[0-4]\d)|(1\d\d)|([1-9]?\d))){4}$/.test(e)
                    }, e.next(".v-msg").text("域名或IP格式错误")
                }
            }
        }
        r.$inject = ["$rootScope", "$scope", "$stateParams", "$state", "$uibModal", "$_yaq", "$q", "$adsData", "meal", "service"];
        var _ = i(405);
        t.exports = _.module("ads.mealservice", []).filter("adsBoolToZH", a).directive("vPort", o).directive("vPortForHttp", s).directive("vPortForTcp", l).directive("vDomain", c).directive("vIpRange", u).directive("vUrlWithWildcard", h).directive("vUrl", d).directive("vIp", p).directive("vEmptyConnDefense", f).directive("vDateTime", g).directive("vMax", m).directive("vMin", v).directive("vExcept", y).directive("vDomainOrIp", x).controller("adsServiceCtrl", r)
    }).call(e, i(482), i(484))
}, function(t, e) {
    t.exports = '<div class=ads-scope> <div class=modal-header> <button type=button class=close ng-click=$dismiss()> <span aria-hidden=true>&times;</span> </button> <h3 class=modal-title ng-if=!vm.isEdit>添加域名</h3> <h3 class=modal-title ng-if=vm.isEdit>编辑域名</h3> </div> <div class=modal-body> <div ng-form=Form class=form-horizontal> <div class=form-group ng-class="{\'has-error\': (Form.$submitted||Form.domain.$dirty)&&Form.domain.$invalid}"> <label class="col-xs-3 control-label">域名</label> <div class=col-xs-9> <input class=form-control name=domain v-domain ng-model=vm.domain.domain> <p class="help-block v-msg" ng-show=(Form.$submitted||Form.domain.$dirty)&&Form.domain.$invalid></p> </div> </div> <fieldset ng-if=!vm.isHttp> <div class=form-group> <div class="col-xs-9 col-xs-offset-3"> <div class=checkbox> <label> <input type=checkbox ng-model=vm.isHttpEnabled> 同时启用HTTP </label> </div> </div> </div> <fieldset ng-disabled=!vm.isHttpEnabled ng-show=vm.isHttpEnabled> <div class=form-group ng-class="{\'has-error\': vm.isHttpEnabled&&(Form.$submitted||Form.http.$dirty)&&Form.http.$invalid}"> <label class="col-xs-3 control-label">ADS-HTTP端口</label> <div class=col-xs-9> <input name=http v-port class=form-control ng-model=vm.domain.http placeholder=仅可输入数字，范围是1到65535> <p class="help-block v-msg" ng-show=vm.isHttpEnabled&&(Form.$submitted||Form.http.$dirty)&&Form.http.$invalid></p> </div> </div> <div class=form-group ng-class="{\'has-error\': vm.isHttpEnabled&&(Form.$submitted||Form.upstream_http.$dirty)&&Form.upstream_http.$invalid}"> <label class="col-xs-3 control-label">ADS-源站端口</label> <div class=col-xs-9> <input name=upstream_http v-port class=form-control ng-model=vm.domain.upstream_http placeholder=仅可输入数字，范围是1到65535> <p class="help-block v-msg" ng-show=vm.isHttpEnabled&&(Form.$submitted||Form.upstream_http.$dirty)&&Form.upstream_http.$invalid></p> </div> </div> </fieldset> <div class=form-group> <label class="col-xs-3 control-label">证书类型</label> <div class=col-xs-9> <label class=radio-inline> <input type=radio ng-model=vm.domain.keyless ng-value=false> SSL </label> </div> </div> <div class=form-group ng-if=!vm.domain.keyless> <div class="col-xs-9 col-xs-offset-3"> <label class="btn btn-primary btn-file"> <input type=file class=form-control file-model=vm.cert style=display:none> 选择公钥 </label> <span>（非源站证书需要上传公钥）</span> <p class=help-block>{{!vm.cert&&vm.domain.cert?\'已选择\':vm.cert.name}}</p> </div> </div> <div class=form-group ng-if=!vm.domain.keyless> <div class="col-xs-9 col-xs-offset-3"> <label class="btn btn-primary btn-file" ng-class="{\'btn-danger\':Form.$submitted&&!vm.private_key}"> <input type=file class=form-control file-model=vm.private_key style=display:none> 选择私钥 </label> <p class=help-block>{{!vm.private_key&&vm.domain.private_key?\'已选择\':vm.private_key.name}}</p> </div> </div> <div class=form-group> <div class="col-xs-9 col-xs-offset-3"> <label class=radio-inline> <input type=radio ng-model=vm.domain.keyless ng-value=true> KeyLess（需部署KeyLess服务器） </label> </div> </div> </fieldset> </div> </div> <div class=modal-footer> <button class="btn btn-default" ng-click=$dismiss()>取消</button> <button ng-if=vm.isHttp class="btn btn-primary" ng-click=Form.$setSubmitted();!Form.$error.domain&&vm.close()>确认</button> <button ng-if=!vm.isHttp class="btn btn-primary" ng-click=Form.$setSubmitted();!Form.$error.domain&&!(vm.isHttpEnabled&&Form.$error.port)&&(vm.domain.keyless||vm.domain.private_key||!!vm.private_key)&&vm.close()>确认</button> </div> </div> '
}, function(t, e) {
    t.exports = '<div class=ads-scope> <div class=modal-header> <button type=button class=close ng-click=$dismiss()> <span aria-hidden=true>&times;</span> </button> <h3 class=modal-title ng-if=!vm.isEdit>添加源站</h3> <h3 class=modal-title ng-if=vm.isEdit>编辑源站</h3> </div> <div class=modal-body> <div ng-form=Form class=form-horizontal> <div class=form-group ng-class="{\'has-error\': (Form.$submitted||Form.ip.$dirty)&&Form.ip.$invalid}"> <label class="col-xs-3 control-label">源站</label> <div class=col-xs-9> <input class=form-control name=ip v-domain-or-ip ng-model=vm.upstream_ip.ip placeholder=可输入域名或IP> <p class="help-block v-msg" ng-show=(Form.$submitted||Form.ip.$dirty)&&Form.ip.$invalid></p> </div> </div> <div class=form-group ng-class="{\'has-error\': (Form.$submitted||Form.port.$dirty)&&Form.port.$invalid}"> <label class="col-xs-3 control-label">源站端口</label> <div class=col-xs-9> <input ng-if="$stateParams.type!==\'tcp\'" class=form-control name=port v-port ng-model=vm.upstream_ip.port placeholder=仅可输入数字，范围是1到65535> <input ng-if="$stateParams.type===\'tcp\'" class=form-control name=port v-port-for-tcp ng-model=vm.portRange placeholder=仅可输入数字，范围是1到65535，支持端口范围输入> <p class="help-block v-msg" ng-show=(Form.$submitted||Form.port.$dirty)&&Form.port.$invalid></p> </div> </div> <div class=form-group> <label class="col-xs-3 control-label">回源策略</label> <div class=col-xs-9> <div class=checkbox> <label> <input type=checkbox ng-true-value=false ng-false-value=true ng-model=vm.upstream_ip.lock> 自动回源（负载均衡） </label> </div> </div> </div> <fieldset ng-disabled=!vm.upstream_ip.lock ng-class="{\'text-muted\':!vm.upstream_ip.lock}"> <div class=form-group> <div class="col-xs-offset-3 col-xs-9"> <label class=radio-inline> <input type=radio ng-model=vm.upstream_ip.isp value=mobile> 移动回源 </label> <label class=radio-inline> <input type=radio ng-model=vm.upstream_ip.isp value=unicom> 联通回源 </label> <label class=radio-inline> <input type=radio ng-model=vm.upstream_ip.isp value=telecom> 电信回源 </label> </div> </div> </fieldset> <div class=form-group> <label class="col-xs-3 control-label">其他</label> <div class=col-xs-9> <div class=checkbox> <label> <input type=checkbox ng-model=vm.upstream_ip.backup> 作为备用回源 </label> </div> </div> </div> </div> </div> <div class=modal-footer> <button class="btn btn-default" ng-click=$dismiss()>取消</button> <button class="btn btn-primary" ng-click=Form.$setSubmitted();Form.$valid&&$close(vm)>确认</button> </div> </div> '
}, function(t, e, i) {
    "use strict";
    function n(t, e, i, n, r, a, o, s, l) {
        "ngInject";
        function c(t) {
            r.open({
                templateUrl: "modalAdd.html",
                size: "md",
                animation: !1,
                backdrop: "static"
            }).result.then(function(e) {
                var r = {
                    meal_id: i.meal_id
                };
                return r[t] = [{
                    ip: e.ip,
                    url: e.url,
                    action: "add"
                }], s.setMeal(r).then(function() {
                    return n.reload()
                }).catch(function(t) {
                    o.broadMsgFn({
                        msg: t.description
                    })
                })
            }).catch(function() {})
        }
        function u(t, e) {
            r.open({
                templateUrl: "modalDelete.html",
                size: "sm",
                animation: !1,
                backdrop: "static"
            }).result.then(function() {
                var r = {
                    meal_id: i.meal_id
                };
                return r[t] = [{
                    ip: e,
                    url: e,
                    action: "delete"
                }], s.setMeal(r).then(function() {
                    return n.reload()
                }).catch(function(t) {
                    o.broadMsgFn({
                        msg: t.description
                    })
                })
            }).catch(function() {})
        }
        var h = this;
        h.meal = l, h.openModalAddFn = c, h.openModalDeleteFn = u
    }
    n.$inject = ["$rootScope", "$scope", "$stateParams", "$state", "$uibModal", "$_http", "$_yaq", "$adsData", "meal"];
    var r = i(405);
    t.exports = r.module("ads.bwlist", []).controller("adsBwlistCtrl", n)
}, function(t, e, i) {
    (function(e) {
        "use strict";
        function n(t, i, n, r, a, o, s, l, c) {
            "ngInject";
            var u = this;
            u.meal = c, u.isLiveDdosBytes = !1, u.isLiveCcRequest = !1, u.isLiveCcUpRequest = !1, u.isLiveCcUpBytes = !1, u.isLiveCcBytes = !1, u.isLiveTcpRequest = !1, u.isLiveTcpUpRequest = !1, u.dateRangePicker = {
                range: {
                    startDate: e().startOf("day"),
                    endDate: e().endOf("day")
                },
                options: {
                    showCustomRangeLabel: !0,
                    timePicker: !0,
                    timePicker24Hour: !0,
                    ranges: {
                        "最近一天": [e().startOf("day"), e().endOf("day")],
                        "最近一周": [e().startOf("day").subtract(6, "days"), e().endOf("day")],
                        "实时": [e(), e()]
                    }
                }
            }, u.ddosBytesOption = {
                legend: {
                    data: ["攻击流量"]
                },
                xAxis: {
                    type: "time"
                },
                yAxis: {
                    name: "bps",
                    type: "value",
                    axisLabel: {
                        formatter: function(t) {
                            var e = s(t);
                            return "" + Math.round(10 * e.value) / 10 + e.unit
                        }
                    }
                },
                tooltip: {
                    formatter: function(t) {
                        var i = t[0],
                            n = e(i.value[0]).format("YYYY-MM-DD HH:mm:ss"),
                            r = s(i.value[1]);
                        return r = Math.round(100 * r.value) / 100 + " " + r.unit + "bps", n += '<br/><span style="color:' + i.color + '">●</span> ' + i.seriesName + " : " + r
                    }
                },
                series: [{
                    name: "攻击流量",
                    type: "line",
                    data: [],
                    itemStyle: {
                        normal: {
                            color: "#3ebe5e"
                        }
                    }
                }]
            }, u.ccRequestOption = {
                legend: {
                    data: ["请求数", "响应数", "拦截数"]
                },
                xAxis: {
                    type: "time"
                },
                yAxis: {
                    name: "qps",
                    type: "value",
                    axisLabel: {
                        formatter: function(t) {
                            var e = l(t);
                            return "" + Math.round(10 * e.value) / 10 + e.unit
                        }
                    }
                },
                tooltip: {
                    formatter: function(t) {
                        var i = t[0],
                            n = e(i.value[0]).format("YYYY-MM-DD HH:mm:ss");
                        return t.forEach(function(t) {
                            var e = l(t.value[1]);
                            e = "" + Math.round(100 * e.value) / 100 + e.unit + " qps", n += '<br/><span style="color:' + t.color + '">●</span> ' + t.seriesName + " : " + e
                        }), n
                    }
                },
                series: [{
                    name: "请求数",
                    type: "line",
                    data: [],
                    itemStyle: {
                        normal: {
                            color: "#22e0e0"
                        }
                    }
                }, {
                    name: "响应数",
                    type: "line",
                    data: [],
                    itemStyle: {
                        normal: {
                            color: "#5460fe"
                        }
                    }
                }, {
                    name: "拦截数",
                    type: "line",
                    data: [],
                    itemStyle: {
                        normal: {
                            color: "#ff4052"
                        }
                    }
                }]
            }, u.ccUpRequestOption = {
                legend: {
                    data: ["请求数", "响应数"]
                },
                xAxis: {
                    type: "time"
                },
                yAxis: {
                    name: "qps",
                    type: "value",
                    axisLabel: {
                        formatter: function(t) {
                            var e = l(t);
                            return "" + Math.round(10 * e.value) / 10 + e.unit
                        }
                    }
                },
                tooltip: {
                    formatter: function(t) {
                        var i = t[0],
                            n = e(i.value[0]).format("YYYY-MM-DD HH:mm:ss");
                        return t.forEach(function(t) {
                            var e = l(t.value[1]);
                            e = "" + Math.round(100 * e.value) / 100 + e.unit + " qps", n += '<br/><span style="color:' + t.color + '">●</span> ' + t.seriesName + " : " + e
                        }), n
                    }
                },
                series: [{
                    name: "请求数",
                    type: "line",
                    data: [],
                    itemStyle: {
                        normal: {
                            color: "#22e0e0"
                        }
                    }
                }, {
                    name: "响应数",
                    type: "line",
                    data: [],
                    itemStyle: {
                        normal: {
                            color: "#5460fe"
                        }
                    }
                }]
            }, u.ccBytesOption = {
                legend: {
                    data: ["流量"]
                },
                xAxis: {
                    type: "time"
                },
                yAxis: {
                    name: "bps",
                    type: "value",
                    axisLabel: {
                        formatter: function(t) {
                            var e = s(t);
                            return "" + Math.round(10 * e.value) / 10 + e.unit
                        }
                    }
                },
                tooltip: {
                    formatter: function(t) {
                        var i = t[0],
                            n = e(i.value[0]).format("YYYY-MM-DD HH:mm:ss");
                        return t.forEach(function(t) {
                            var e = s(t.value[1]);
                            e = Math.round(100 * e.value) / 100 + " " + e.unit + "bps", n += '<br/><span style="color:' + t.color + '">●</span> ' + t.seriesName + " : " + e
                        }), n
                    }
                },
                series: [{
                    name: "流量",
                    type: "line",
                    data: [],
                    itemStyle: {
                        normal: {
                            color: "#3ebe5e"
                        }
                    }
                }]
            }, u.ccUpBytesOption = {
                legend: {
                    data: ["流量"]
                },
                xAxis: {
                    type: "time"
                },
                yAxis: {
                    name: "bps",
                    type: "value",
                    axisLabel: {
                        formatter: function(t) {
                            var e = s(t);
                            return "" + Math.round(10 * e.value) / 10 + e.unit
                        }
                    }
                },
                tooltip: {
                    formatter: function(t) {
                        var i = t[0],
                            n = e(i.value[0]).format("YYYY-MM-DD HH:mm:ss");
                        return t.forEach(function(t) {
                            var e = s(t.value[1]);
                            e = Math.round(100 * e.value) / 100 + " " + e.unit + "bps", n += '<br/><span style="color:' + t.color + '">●</span> ' + t.seriesName + " : " + e
                        }), n
                    }
                },
                series: [{
                    name: "流量",
                    type: "line",
                    data: [],
                    itemStyle: {
                        normal: {
                            color: "#a042fb"
                        }
                    }
                }]
            }, u.tcpRequestOption = {
                legend: {
                    data: ["并发连接数", "拦截数"]
                },
                xAxis: {
                    type: "time"
                },
                yAxis: {
                    name: "qps",
                    type: "value",
                    axisLabel: {
                        formatter: function(t) {
                            var e = s(t);
                            return "" + Math.round(10 * e.value) / 10 + e.unit
                        }
                    }
                },
                tooltip: {
                    formatter: function(t) {
                        var i = t[0],
                            n = e(i.value[0]).format("YYYY-MM-DD HH:mm:ss");
                        return t.forEach(function(t) {
                            var e = s(t.value[1]);
                            e = Math.round(100 * e.value) / 100 + " " + e.unit + "qps", n += '<br/><span style="color:' + t.color + '">●</span> ' + t.seriesName + " : " + e
                        }), n
                    }
                },
                series: [{
                    name: "并发连接数",
                    type: "line",
                    data: [],
                    itemStyle: {
                        normal: {
                            color: "#4290fb"
                        }
                    }
                }, {
                    name: "拦截数",
                    type: "line",
                    data: [],
                    itemStyle: {
                        normal: {
                            color: "#ff4052"
                        }
                    }
                }]
            }, u.tcpUpRequestOption = {
                legend: {
                    data: ["请求流量", "响应流量"]
                },
                xAxis: {
                    type: "time"
                },
                yAxis: {
                    name: "bps",
                    type: "value",
                    axisLabel: {
                        formatter: function(t) {
                            var e = s(t);
                            return "" + Math.round(10 * e.value) / 10 + e.unit
                        }
                    }
                },
                tooltip: {
                    formatter: function(t) {
                        var i = t[0],
                            n = e(i.value[0]).format("YYYY-MM-DD HH:mm:ss");
                        return t.forEach(function(t) {
                            var e = s(t.value[1]);
                            e = Math.round(100 * e.value) / 100 + " " + e.unit + "bps", n += '<br/><span style="color:' + t.color + '">●</span> ' + t.seriesName + " : " + e
                        }), n
                    }
                },
                series: [{
                    name: "请求流量",
                    type: "line",
                    data: [],
                    itemStyle: {
                        normal: {
                            color: "#22e0e0"
                        }
                    }
                }, {
                    name: "响应流量",
                    type: "line",
                    data: [],
                    itemStyle: {
                        normal: {
                            color: "#5460fe"
                        }
                    }
                }]
            }, u.fetchDdosBytes = function(t, e, n, s, l) {
                r.is("ads.meal.report") && Promise.resolve().then(function() {
                    return "live" !== s ? (u.isLiveDdosBytes = !1, a.getHistoryDdos({
                        ip: t,
                        start_time: e,
                        end_time: n,
                        time_scale: s
                    })) : (l || (u.isLiveDdosBytes = !0), o(function() {
                        u.isLiveDdosBytes && u.fetchDdosBytes(t, e, n, s, !0)
                    }, 1), a.getLiveDdos({
                        ip: t
                    }))
                }).then(function(t) {
                    l && !u.isLiveDdosBytes || (u.ddosBytesOption = {
                        series: [{
                            data: t.map(function(t) {
                                return [1e3 * t.start_time, t.data.bytes]
                            }),
                            showSymbol: t.length < 30
                        }]
                    })
                }).catch(function(t) {
                    i.broadMsgFn({
                        msg: t.description
                    })
                })
            }, u.fetchCcRequest = function(t, e, n, s, l) {
                r.is("ads.meal.report") && Promise.resolve().then(function() {
                    return "live" !== s ? (u.isLiveCcRequest = !1, a.getHistoryCc({
                        ip: t,
                        start_time: e,
                        end_time: n,
                        time_scale: s
                    })) : (l || (u.isLiveCcRequest = !0), o(function() {
                        u.isLiveCcRequest && u.fetchCcRequest(t, e, n, s, !0)
                    }, 1), a.getLiveCc({
                        ip: t
                    }))
                }).then(function(t) {
                    l && !u.isLiveCcRequest || (u.ccRequestOption = {
                        series: [{
                            data: t.map(function(t) {
                                return [1e3 * t.start_time, t.data.request]
                            }),
                            showSymbol: t.length < 30
                        }, {
                            data: t.map(function(t) {
                                return [1e3 * t.start_time, t.data.reply]
                            }),
                            showSymbol: t.length < 30
                        }, {
                            data: t.map(function(t) {
                                return [1e3 * t.start_time, t.data.defense]
                            }),
                            showSymbol: t.length < 30
                        }]
                    })
                }).catch(function(t) {
                    i.broadMsgFn({
                        msg: t.description
                    })
                })
            }, u.fetchCcUpRequest = function(t, e, n, s, l) {
                r.is("ads.meal.report") && Promise.resolve().then(function() {
                    return "live" !== s ? (u.isLiveCcUpRequest = !1, a.getHistoryCc({
                        ip: t,
                        start_time: e,
                        end_time: n,
                        time_scale: s
                    })) : (l || (u.isLiveCcUpRequest = !0), o(function() {
                        u.isLiveCcUpRequest && u.fetchCcUpRequest(t, e, n, s, !0)
                    }, 1), a.getLiveCc({
                        ip: t
                    }))
                }).then(function(t) {
                    l && !u.isLiveCcUpRequest || (u.ccUpRequestOption = {
                        series: [{
                            data: t.map(function(t) {
                                return [1e3 * t.start_time, t.data.up_request]
                            }),
                            showSymbol: t.length < 30
                        }, {
                            data: t.map(function(t) {
                                return [1e3 * t.start_time, t.data.up_reply]
                            }),
                            showSymbol: t.length < 30
                        }]
                    })
                }).catch(function(t) {
                    i.broadMsgFn({
                        msg: t.description
                    })
                })
            }, u.fetchCcUpBytes = function(t, e, n, s, l) {
                r.is("ads.meal.report") && Promise.resolve().then(function() {
                    return "live" !== s ? (u.isLiveCcUpBytes = !1, a.getHistoryCc({
                        ip: t,
                        start_time: e,
                        end_time: n,
                        time_scale: s
                    })) : (l || (u.isLiveCcUpBytes = !0), o(function() {
                        u.isLiveCcUpBytes && u.fetchCcUpBytes(t, e, n, s, !0)
                    }, 1), a.getLiveCc({
                        ip: t
                    }))
                }).then(function(t) {
                    l && !u.isLiveCcUpBytes || (u.ccUpBytesOption = {
                        series: [{
                            data: t.map(function(t) {
                                return [1e3 * t.start_time, t.data.up_bytes]
                            }),
                            showSymbol: t.length < 30
                        }]
                    })
                }).catch(function(t) {
                    i.broadMsgFn({
                        msg: t.description
                    })
                })
            }, u.fetchCcBytes = function(t, e, n, s, l) {
                r.is("ads.meal.report") && Promise.resolve().then(function() {
                    return "live" !== s ? (u.isLiveCcBytes = !1, a.getHistoryCc({
                        ip: t,
                        start_time: e,
                        end_time: n,
                        time_scale: s
                    })) : (l || (u.isLiveCcBytes = !0), o(function() {
                        u.isLiveCcBytes && u.fetchCcBytes(t, e, n, s, !0)
                    }, 1), a.getLiveCc({
                        ip: t
                    }))
                }).then(function(t) {
                    l && !u.isLiveCcBytes || (u.ccBytesOption = {
                        series: [{
                            data: t.map(function(t) {
                                return [1e3 * t.start_time, t.data.bytes]
                            }),
                            showSymbol: t.length < 30
                        }]
                    })
                }).catch(function(t) {
                    i.broadMsgFn({
                        msg: t.description
                    })
                })
            }, u.fetchTcpRequest = function(t, e, n, s, l) {
                r.is("ads.meal.report") && Promise.resolve().then(function() {
                    return "live" !== s ? (u.isLiveTcpRequest = !1, a.getHistoryTcp({
                        ip: t,
                        start_time: e,
                        end_time: n,
                        time_scale: s
                    })) : (l || (u.isLiveTcpRequest = !0), o(function() {
                        u.isLiveTcpRequest && u.fetchTcpRequest(t, e, n, s, !0)
                    }, 1), a.getLiveTcp({
                        ip: t
                    }))
                }).then(function(t) {
                    l && !u.isLiveTcpRequest || (u.tcpRequestOption = {
                        series: [{
                            data: t.map(function(t) {
                                return [1e3 * t.start_time, t.data.connections]
                            }),
                            showSymbol: t.length < 30
                        }, {
                            data: t.map(function(t) {
                                return [1e3 * t.start_time, t.data.defense]
                            }),
                            showSymbol: t.length < 30
                        }]
                    })
                }).catch(function(t) {
                    i.broadMsgFn({
                        msg: t.description
                    })
                })
            }, u.fetchTcpUpRequest = function(t, e, n, s, l) {
                r.is("ads.meal.report") && Promise.resolve().then(function() {
                    return "live" !== s ? (u.isLiveTcpUpRequest = !1, a.getHistoryTcp({
                        ip: t,
                        start_time: e,
                        end_time: n,
                        time_scale: s
                    })) : (l || (u.isLiveTcpUpRequest = !0), o(function() {
                        u.isLiveTcpUpRequest && u.fetchTcpUpRequest(t, e, n, s, !0)
                    }, 1), a.getLiveTcp({
                        ip: t
                    }))
                }).then(function(t) {
                    l && !u.isLiveTcpUpRequest || (u.tcpUpRequestOption = {
                        series: [{
                            data: t.map(function(t) {
                                return [1e3 * t.start_time, t.data.recv]
                            }),
                            showSymbol: t.length < 30
                        }, {
                            data: t.map(function(t) {
                                return [1e3 * t.start_time, t.data.send]
                            }),
                            showSymbol: t.length < 30
                        }]
                    })
                }).catch(function(t) {
                    i.broadMsgFn({
                        msg: t.description
                    })
                })
            }
        }
        n.$inject = ["$scope", "$_yaq", "$stateParams", "$state", "$adsReportData", "$timeout", "$btyeFormatter", "$wFormatter", "meal"];
        var r = (i(1025), i(405));
        t.exports = r.module("ads.report", [i(1071).name, i(1072).name, i(504).name, i(498).name]).controller("adsReportCtrl", n)
    }).call(e, i(484))
}, function(t, e, i) {
    (function(e) {
        "use strict";
        function n(t, i, n, a) {
            "ngInject";
            var o = this;
            this.liveData, this.liveDataFilter, this.liveDataTimestamp, this.liveDataPromise;
            var s = function() {
                    if ((!o.liveDataTimestamp || e().valueOf() - o.liveDataTimestamp > 1e4) && (o.liveData = {
                        ddos: [],
                        cc: [],
                        tcp: []
                    }, o.liveDataFilter = {
                        ddos: [],
                        cc: [],
                        tcp: []
                    }), o.liveDataPromise)
                        return o.liveDataPromise;
                    var s = function() {
                        var r = 1e3 - e().millisecond();
                        return {
                            v: o.liveDataPromise = new Promise(function(s, l) {
                                a(function() {
                                    n.reqPostFn("addos/ads_all", {
                                        instance_id: t.base.ID,
                                        meal_id: i.meal_id
                                    }, {
                                        ignoreLoadingBar: !0
                                    }).then(function(t) {
                                        o.liveDataFilter.ddos.push(t.data.ddos), o.liveDataFilter.cc.push(t.data.cc), o.liveDataFilter.tcp.push(t.data.tcp), o.liveDataFilter.ddos.length > 10 && (o.liveDataFilter.ddos.shift(), o.liveDataFilter.cc.shift(), o.liveDataFilter.tcp.shift());
                                        var i = e().unix();
                                        o.liveData.ddos.push({
                                            start_time: i,
                                            end_time: i,
                                            ads_ip: o.liveDataFilter.ddos.reduce(function(t, e) {
                                                return t.concat(e)
                                            }, [])
                                        }), o.liveData.cc.push({
                                            start_time: i,
                                            end_time: i,
                                            ads_ip: o.liveDataFilter.cc.reduce(function(t, e) {
                                                return t.concat(e)
                                            }, [])
                                        }), o.liveData.tcp.push({
                                            start_time: i,
                                            end_time: i,
                                            ads_ip: o.liveDataFilter.tcp.reduce(function(t, e) {
                                                return t.concat(e)
                                            }, [])
                                        }), o.liveData.ddos.length > 60 && (o.liveData.ddos.shift(), o.liveData.cc.shift(), o.liveData.tcp.shift()), o.liveDataTimestamp = e().valueOf(), s(o.liveData)
                                    }).catch(function(t) {
                                        console.error(t), s(o.liveData)
                                    }).then(function() {
                                        return o.liveDataPromise = void 0
                                    })
                                }, r)
                            })
                        }
                    }();
                    return "object" === ("undefined" == typeof s ? "undefined" : r(s)) ? s.v : void 0
                },
                l = function() {
                    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
                        e = t.ip;
                    return s().then(function(t) {
                        return t.ddos.map(function(t) {
                            return t.data = t.ads_ip.reduce(function(t, i) {
                                return e && i.ip != e || Object.keys(t).forEach(function(e) {
                                    t[e] += i[e]
                                }), t
                            }, {
                                bytes: 0,
                                pkts: 0
                            }), t.data.bytes *= 8, Object.keys(t.data).forEach(function(e) {
                                t.data[e] = Math.ceil(t.data[e] / 10)
                            }), t
                        })
                    })
                },
                c = function() {
                    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
                        e = t.ip;
                    return s().then(function(t) {
                        return t.cc.map(function(t) {
                            return t.data = t.ads_ip.reduce(function(t, i) {
                                return e && i.ip != e || Object.keys(t).forEach(function(e) {
                                    t[e] += i[e]
                                }), t
                            }, {
                                request: 0,
                                reply: 0,
                                defense: 0,
                                up_request: 0,
                                up_reply: 0,
                                bytes: 0,
                                up_bytes: 0
                            }), t.data.bytes *= 8, t.data.up_bytes *= 8, Object.keys(t.data).forEach(function(e) {
                                t.data[e] = Math.ceil(t.data[e] / 10)
                            }), t
                        })
                    })
                },
                u = function() {
                    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
                        e = t.ip;
                    return s().then(function(t) {
                        return t.tcp.map(function(t) {
                            return t.data = t.ads_ip.reduce(function(t, i) {
                                return e && i.ip != e || Object.keys(t).forEach(function(e) {
                                    t[e] += i[e]
                                }), t
                            }, {
                                connections: 0,
                                defense: 0,
                                recv: 0,
                                send: 0
                            }), t.data.recv *= 8, t.data.send *= 8, Object.keys(t.data).forEach(function(e) {
                                t.data[e] = Math.ceil(t.data[e] / 10)
                            }), t
                        })
                    })
                },
                h = function() {
                    var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                    return e.instance_id = t.base.ID, e.meal_id = i.meal_id, n.reqPostFn("addos/ads_history_ddos", e).then(function(t) {
                        return t.data.ddos.forEach(function(t) {
                            t.data = t.ads_ip.reduce(function(t, e) {
                                return Object.keys(t).forEach(function(i) {
                                    t[i] += e[i]
                                }), t
                            }, {
                                bytes: 0,
                                pkts: 0
                            }), t.data.bytes *= 8, Object.keys(t.data).forEach(function(e) {
                                t.data[e] = Math.ceil(t.data[e] / 60)
                            })
                        }), t.data.ddos
                    })
                },
                d = function() {
                    var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                    return e.instance_id = t.base.ID, e.meal_id = i.meal_id, n.reqPostFn("addos/ads_history_cc", e).then(function(t) {
                        return t.data.cc.forEach(function(t) {
                            t.data = t.ads_ip.reduce(function(t, e) {
                                return Object.keys(t).forEach(function(i) {
                                    t[i] += e[i]
                                }), t
                            }, {
                                request: 0,
                                reply: 0,
                                defense: 0,
                                up_request: 0,
                                up_reply: 0,
                                bytes: 0,
                                up_bytes: 0
                            }), t.data.bytes *= 8, t.data.up_bytes *= 8, Object.keys(t.data).forEach(function(e) {
                                t.data[e] = Math.ceil(t.data[e] / 60)
                            })
                        }), t.data.cc
                    })
                },
                p = function() {
                    var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                    return e.instance_id = t.base.ID, e.meal_id = i.meal_id, n.reqPostFn("addos/ads_history_tcp", e).then(function(t) {
                        return t.data.tcp.forEach(function(t) {
                            t.data = t.ads_ip.reduce(function(t, e) {
                                return Object.keys(t).forEach(function(i) {
                                    t[i] += e[i]
                                }), t
                            }, {
                                connections: 0,
                                defense: 0,
                                recv: 0,
                                send: 0
                            }), t.data.connections *= 60, t.data.recv *= 8, t.data.send *= 8, Object.keys(t.data).forEach(function(e) {
                                t.data[e] = Math.ceil(t.data[e] / 60)
                            })
                        }), t.data.tcp
                    })
                };
            return {
                getHistoryDdos: h,
                getHistoryCc: d,
                getHistoryTcp: p,
                getLiveDdos: l,
                getLiveCc: c,
                getLiveTcp: u
            }
        }
        n.$inject = ["$rootScope", "$stateParams", "$_http", "$timeout"];
        var r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                return typeof t
            } : function(t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
            },
            a = i(405);
        t.exports = a.module("ads.report.service", []).factory("$adsReportData", n)
    }).call(e, i(484))
}, function(t, e, i) {
    (function(e) {
        "use strict";
        var n = i(405);
        t.exports = n.module("ads.report.titleAndSelector", [i(498).name]).component("titleAndSelector", {
            template: '\n      <div class="block-title">\n        <h2 uib-dropdown>\n          <strong uib-dropdown-toggle><ng-transclude></ng-transclude><span class="caret"></span></strong>\n          <ul uib-dropdown-menu>\n            <li ng-class="{active:!$ctrl.ip}">\n              <a ng-click="$ctrl.ipApply()">套餐总览</a>\n            </li>\n            <li ng-repeat="ip in $ctrl.ips track by $index" ng-class="{active:$ctrl.ip===ip.ip}">\n              <a ng-click="$ctrl.ipApply(ip.ip)">{{ip.ip}}</a>\n            </li>\n          </ul>\n        </h2>\n        <div class="block-options pull-right">\n          <date-pick-button options="$ctrl.dateRangePicker.options" range="$ctrl.dateRangePicker.range" on-apply="$ctrl.dateApply(startDate, endDate, label, opts)"></date-pick-button>\n        </div>\n      </div>\n    ',
            transclude: !0,
            bindings: {
                ips: "<",
                onApply: "&"
            },
            controller: function() {
                "ngInject";
                var t = this;
                this.$onInit = function() {
                    t.ip = void 0, t.dateRange = {}, t.dateRangePicker = {
                        range: {
                            startDate: e().startOf("day"),
                            endDate: e().endOf("day")
                        },
                        options: {
                            showCustomRangeLabel: !0,
                            timePicker: !0,
                            timePicker24Hour: !0,
                            ranges: {
                                "最近一天": [e().startOf("day"), e().endOf("day")],
                                "最近一周": [e().startOf("day").subtract(6, "days"), e().endOf("day")],
                                "实时": [e(), e()]
                            }
                        }
                    }, t.ipApply = function(e) {
                        t.ip = e, t.onApply({
                            ip: t.ip,
                            start_time: t.dateRange.startDate,
                            end_time: t.dateRange.endDate,
                            time_scale: t.dateRange.time_scale
                        })
                    }, t.dateApply = function(e, i, n, r) {
                        var a = "d";
                        if ("最近一天" == n)
                            a = "h";
                        else if ("最近一周" == n)
                            a = "d";
                        else {
                            var o = i.unix() - e.unix();
                            a = 0 == o ? "live" : o < 21600 ? "m" : o < 604800 ? "h" : "d"
                        }
                        t.dateRange = {
                            startDate: e.unix(),
                            endDate: i.unix(),
                            time_scale: a
                        }, t.onApply({
                            ip: t.ip,
                            start_time: t.dateRange.startDate,
                            end_time: t.dateRange.endDate,
                            time_scale: t.dateRange.time_scale
                        })
                    }
                }
            }
        })
    }).call(e, i(484))
}, function(t, e) {
    t.exports = '<div class="block full"> <div class=block-title> <h2><strong>套餐状态</strong></h2> </div> <div> <div ng-if="vm.mealList.length == 0" style=height:100px;display:flex;align-items:center;justify-content:center> <h2 ng-if=!vm.isFetching>尚未购买套餐</h2> <h2 ng-if=vm.isFetching>加载中...</h2> </div> <div ng-if="vm.mealList.length !== 0"> <table class="table table-vcenter table-striped"> <thead> <tr> <th>套餐</th> <th>高防组</th> <th>高防IP</th> <th>高防线路</th> <th>操作</th> </tr> <tr style=border:0> <td colspan=5 style=padding:5px></td> </tr> </thead> <tbody> <tr ng-if="vm.mealList.length === 0"> <td colspan=5>没有数据</td> </tr> <tr ng-repeat-start="item in vm.mealList track by $index"> <td colspan=5 style=text-align:left> <span style=margin-right:20px>购买日期：{{item.start_time}}</span> <span>到期日期：{{item.end_time}}</span> </td> </tr> <tr ng-repeat-end> <td>{{item.meal_info}}</td> <td>{{item.meal_id}}</td> <td> <div ng-repeat="val in item.ads_ip"> {{val.ip}} </div> </td> <td> <div ng-repeat="val in item.ads_ip"> {{val.isp | adsIspToZH}} </div> </td> <td> <div> <a ui-sref="ads.meal.default({meal_id: item.meal_id})">管理配置</a> <span class=text-muted style=margin:10px>│</span> <a ui-sref="ads.meal.report({meal_id: item.meal_id})">查看报表</a> </div> </td> </tr> </tbody> </table> <div ng-if="vm.total != vm.mealList.length"> <button class="btn btn-default btn-block" ng-click=vm.fetchDataFn()>加载更多 ..</button> </div> </div> </div> </div> '
}, function(t, e) {
    t.exports = '<div class="block full"> <div class=block-title> <div class="block-options pull-right"> <div class="btn-group btn-group-sm" uib-dropdown> <button type=button class="btn btn-sm btn-primary dropdown-toggle" uib-dropdown-toggle ng-disabled="vm.meal.order_status!=1||!base.authority"> 添加配置 <span class=caret></span> </button> <ul class=dropdown-menu uib-dropdown-menu role=menu> <li><a ui-sref="ads.meal.service({type:\'http\'})">HTTP</a></li> <li><a ui-sref="ads.meal.service({type:\'https\'})">HTTPS</a></li> <li><a ui-sref="ads.meal.service({type:\'tcp\'})">TCP</a></li> </ul> </div> <button class="btn btn-sm btn-default" ui-sref="ads.meal.list({tab:\'black_ip\'})">黑白名单（CC防护）</button> <button class="btn btn-sm btn-default" ui-sref=ads.meal.report>查看报表</button> </div> <h2><strong>套餐状态-管理配置</strong></h2><a ui-sref=ads.default> &laquo; 返回 </a> </div> <div> <div class="panel panel-default"> <div class=panel-body> <div class=row> <div class=col-xs-8> <label>CC防护设置</label> <div>开启CC防护将启动CC防护引擎阻断攻击IP，对套餐内所有记录生效</div> </div> <div class=col-xs-4> <select class="form-control pull-right" ng-model=vm.cc_sensitivity ng-change=vm.onCcChange(vm.cc_sensitivity) style=max-width:228px ng-disabled="vm.meal.order_status!=1||!base.authority"> <option ng-value=100>强力</option> <option ng-value=1>高</option> <option ng-value=2>中</option> <option ng-value=3>低</option> <option ng-value=0>关闭</option> </select> </div> </div> </div> </div> <table class="table table-vcenter table-striped table-bordered"> <thead> <tr> <th>防御端口</th> <th>域名</th> <th>CNAME</th> <th>源站</th> <th>协议类型</th> <th>操作</th> </tr> </thead> <tbody> <tr></tr> <tr ng-if="!vm.meal.services||vm.meal.services.length===0"> <td colspan=6>没有数据</td> </tr> <tr ng-repeat="service in vm.meal.services track by $index"> <td>{{service.port}}{{service.port_end&&service.port!=service.port_end?\'-\'+service.port_end:\'\'}}</td> <td> <div ng-if="service.type==\'http\'" ng-repeat="domain in service.domains track by $index">{{domain}}</div> <div ng-if="service.type==\'https\'" ng-repeat="domain in service.domains track by $index">{{domain.domain}}</div> <div ng-if="service.type==\'tcp\'">-</div> </td> <td> <div ng-if="service.type==\'http\'" ng-repeat="domain in service.domains track by $index"> <span ng-repeat="group in service.cname[domain]">{{group.cname}}</span> </div> <div ng-if="service.type==\'https\'" ng-repeat="domain in service.domains track by $index"> <span ng-repeat="group in service.cname[domain.domain]">{{group.cname}}</span> </div> <div ng-if="service.type==\'tcp\'">-</div> </td> <td> <div ng-repeat="upstream_ip in service.upstream_ips track by $index">{{upstream_ip.ip}}</div> </td> <td>{{service.type.toLocaleUpperCase()}}</td> <td> <div> <button class="btn btn-link" ui-sref=ads.meal.service({service_id:service.service_id,type:service.type})>查看并编辑</button> <span class=text-muted style=margin:10px>│</span> <button class="btn btn-link" ng-click=vm.openModalDeleteConfigFn(service.service_id) ng-disabled="vm.meal.order_status!=1||!base.authority">删除</button> </div> </td> </tr> </tbody> </table> </div> </div> <script type=text/ng-template id=addos/meal/modalDeleteConfig.html> <div class="modal-header">\n    <button type="button" class="close" ng-click="$dismiss()"><span aria-hidden="true">&times;</span></button>\n    <h3 class="modal-title">删除配置</h3>\n  </div>\n  <div class="modal-body">\n    <div style="display:flex;align-items:center">\n      <div style="margin:0px 20px">\n        <i class="fa fa-question-circle fa-5x text-primary"></i>\n      </div>\n      <div>\n        <div>删除后不可恢复</div>\n        <div>请确认是否删除</div>\n      </div>\n    </div>\n  </div>\n  <div class="modal-footer">\n    <button class="btn btn-default" ng-click="$dismiss()">取消</button>\n    <button class="btn btn-primary" ng-click="$close()">确认删除</button>\n  </div> </script> ';
}, function(t, e) {
    t.exports = '<div class="block full"> <div class=block-title> <h2> <strong>套餐状态-管理配置-{{$stateParams.type.toUpperCase()}}配置</strong> </h2> <a href="" ng-click=vm.openModalAlertFn()> &laquo; 返回 </a> </div> <div> <div class=form-horizontal ng-form=Form> <fieldset ng-if="$stateParams.type===\'http\'"> <div class=form-group ng-class="{\'has-error\': (Form.$submitted||Form.port.$dirty)&&Form.port.$invalid}"> <label class="col-xs-2 col-lg-1 control-label">防御端口</label> <div class=col-xs-5> <input class=form-control name=port v-port-for-http placeholder=仅可输入1-65535之间的数字，不能输入81-87,62222 ng-model=vm.service.port> <p class="help-block v-msg" ng-show=(Form.$submitted||Form.port.$dirty)&&Form.port.$invalid></p> </div> </div> <div class=form-group> <label class="col-xs-2 col-lg-1 control-label">域名</label> <div class=col-xs-5> <button class="btn btn-primary" ng-click=vm.openModalAddDomainFn()>添加</button> </div> </div> <div class=form-group ng-if="vm.service.domains&&vm.service.domains.length!==0"> <div class="col-xs-10 col-xs-offset-2 col-lg-11 col-lg-offset-1"> <table class="table table-vcenter table-striped table-bordered"> <thead> <tr> <th>域名</th> <th>操作</th> </tr> </thead> <tbody> <tr></tr> <tr ng-repeat="(index, domain) in vm.service.domains track by $index"> <td>{{domain}}</td> <td> <div> <button class="btn btn-link" ng-click=vm.openModalAddDomainFn(index)>编辑</button> <span class=text-muted style=margin:10px>│</span> <button class="btn btn-link" ng-click=vm.service.domains.splice(index,1)>删除</button> </div> </td> </tr> </tbody> </table> </div> </div> <div class=form-group> <label class="col-xs-2 col-lg-1 control-label">源站</label> <div class=col-xs-5> <button class="btn btn-primary" ng-click=vm.openModalAddUpstreamFn()>添加</button> </div> </div> <div class=form-group ng-if="vm.service.upstream_ips&&vm.service.upstream_ips&&vm.service.upstream_ips.length!==0"> <div class="col-xs-10 col-xs-offset-2 col-lg-11 col-lg-offset-1"> <table class="table table-vcenter table-striped table-bordered"> <thead> <tr> <th>源站</th> <th>源站端口</th> <th>回源策略</th> <th>备用</th> <th>操作</th> </tr> </thead> <tbody> <tr></tr> <tr ng-repeat="(index, ip) in vm.service.upstream_ips track by $index"> <td>{{ip.ip}}</td> <td>{{ip.port}}</td> <td>{{ip.lock?(ip.isp | adsIspToZH):\'自动\'}}回源</td> <td>{{ip.backup | adsBoolToZH}}</td> <td> <div> <button class="btn btn-link" ng-click=vm.openModalAddUpstreamFn(index)>编辑</button> <span class=text-muted style=margin:10px>│</span> <button class="btn btn-link" ng-click=vm.service.upstream_ips.splice(index,1)>删除</button> </div> </td> </tr> </tbody> </table> </div> </div> </fieldset> <fieldset ng-if="$stateParams.type===\'https\'"> <div class=form-group ng-class="{\'has-error\': (Form.$submitted||Form.port.$dirty)&&Form.port.$invalid}"> <label class="col-xs-2 col-lg-1 control-label">防御端口</label> <div class=col-xs-5> <input class=form-control name=port v-port-for-http placeholder=仅可输入1-65535之间的数字，不能输入81-87,62222 ng-model=vm.service.port> <p class="help-block v-msg" ng-show=(Form.$submitted||Form.port.$dirty)&&Form.port.$invalid></p> </div> </div> <div class=form-group> <label class="col-xs-2 col-lg-1 control-label">域名</label> <div class=col-xs-5> <button class="btn btn-primary" ng-click=vm.openModalAddDomainFn()>添加</button> </div> </div> <div class=form-group ng-if="vm.service.domains&&vm.service.domains.length!==0"> <div class="col-xs-10 col-xs-offset-2 col-lg-11 col-lg-offset-1"> <table class="table table-vcenter table-striped table-bordered"> <thead> <tr> <th>域名</th> <th>是否启用HTTP</th> <th>证书类型</th> <th>操作</th> </tr> </thead> <tbody> <tr></tr> <tr ng-repeat="(index, domain) in vm.service.domains track by $index"> <td>{{domain.domain}}</td> <td>{{domain.http | adsBoolToZH}}</td> <td>{{domain.keyless?\'KeyLess\':\'私钥\'}}</td> <td> <div> <button class="btn btn-link" ng-click=vm.openModalAddDomainFn(index)>编辑</button> <span class=text-muted style=margin:10px>│</span> <button class="btn btn-link" ng-click=vm.service.domains.splice(index,1)>删除</button> </div> </td> </tr> </tbody> </table> </div> </div> <div class=form-group> <label class="col-xs-2 col-lg-1 control-label">源站</label> <div class=col-xs-5> <button class="btn btn-primary" ng-click=vm.openModalAddUpstreamFn()>添加</button> </div> </div> <div class=form-group ng-if="vm.service.upstream_ips&&vm.service.upstream_ips.length!==0"> <div class="col-xs-10 col-xs-offset-2 col-lg-11 col-lg-offset-1"> <table class="table table-vcenter table-striped table-bordered"> <thead> <tr> <th>源站</th> <th>源站端口</th> <th>回源策略</th> <th>备用</th> <th>操作</th> </tr> </thead> <tbody> <tr></tr> <tr ng-repeat="(index, ip) in vm.service.upstream_ips track by $index"> <td>{{ip.ip}}</td> <td>{{ip.port}}</td> <td>{{ip.lock?(ip.isp | adsIspToZH):\'自动\'}}回源</td> <td>{{ip.backup | adsBoolToZH}}</td> <td> <div> <button class="btn btn-link" ng-click=vm.openModalAddUpstreamFn(index)>编辑</button> <span class=text-muted style=margin:10px>│</span> <button class="btn btn-link" ng-click=vm.service.upstream_ips.splice(index,1)>删除</button> </div> </td> </tr> </tbody> </table> </div> </div> <fieldset ng-if=vm.keyless> <div class=form-group> <label class="col-xs-2 col-lg-1 control-label">KeyLess</label> <div class=col-xs-5> <button class="btn btn-primary" ng-click=vm.openModalAddKeyLessFn()>添加</button> </div> </div> <div class=form-group ng-if="vm.service.keyserver&&vm.service.keyserver.length!==0"> <div class="col-xs-10 col-xs-offset-2 col-lg-11 col-lg-offset-1"> <table class="table table-vcenter table-striped table-bordered"> <thead> <tr> <th>IP</th> <th>端口</th> <th>线路</th> <th>操作</th> </tr> </thead> <tbody> <tr></tr> <tr ng-repeat="(index, keyserver) in vm.service.keyserver track by $index"> <td>{{keyserver.ip}}</td> <td>{{keyserver.port}}</td> <td>{{keyserver.isp | adsIspToZH}}</td> <td> <div> <button class="btn btn-link" ng-click=vm.openModalAddKeyLessFn(index)>编辑</button> <span class=text-muted style=margin:10px>│</span> <button class="btn btn-link" ng-click=vm.service.keyserver.splice(index,1)>删除</button> </div> </td> </tr> </tbody> </table> </div> </div> </fieldset> </fieldset> <fieldset ng-if="$stateParams.type===\'tcp\'"> <div class=form-group ng-class="{\'has-error\': (Form.$submitted||Form.port.$dirty)&&Form.port.$invalid}"> <label class="col-xs-2 col-lg-1 control-label">防御端口</label> <div class=col-xs-5> <input class=form-control name=port v-port-for-tcp placeholder=仅可输入1-65535之间的数字，不能输入80-87,62222。支持端口范围输入，格式为：100-108 ng-model=vm.portRange> <p class="help-block v-msg" ng-show=(Form.$submitted||Form.port.$dirty)&&Form.port.$invalid></p> </div> </div> <div class=form-group ng-class="{\'has-error\': (Form.$submitted||Form.empty_conn_defense.$dirty)&&Form.empty_conn_defense.$invalid}"> <label class="col-xs-2 col-lg-1 control-label">空链接超时</label> <div class=col-xs-5> <input class=form-control name=empty_conn_defense v-empty-conn-defense ng-model=vm.service.empty_conn_defense placeholder=单位为秒，0表示关闭检测> <p class="help-block v-msg" ng-show=(Form.$submitted||Form.empty_conn_defense.$dirty)&&Form.empty_conn_defense.$invalid></p> </div> </div> <div class=form-group> <label class="col-xs-2 col-lg-1 control-label">HAProxy协议支持</label> <div class=col-xs-5> <label class=radio-inline> <input type=radio ng-model=vm.service.haproxy ng-value=true> 开 </label> <label class=radio-inline> <input type=radio ng-model=vm.service.haproxy ng-value=false> 关 </label> <p class=help-block>注：需服务端支持 HAProxy 协议</p> </div> </div> <div ng-if="base.NAME.indexOf(\'联众\')!=-1" class=form-group> <label class="col-xs-2 col-lg-1 control-label">启用match</label> <div class=col-xs-5 ng-init="vm.service.match_rule=0"> <label class=radio-inline> <input type=radio ng-model=vm.service.match_rule ng-value=1> 开 </label> <label class=radio-inline> <input type=radio ng-model=vm.service.match_rule ng-value=0> 关 </label> </div> </div> <div class=form-group> <label class="col-xs-2 col-lg-1 control-label">源站</label> <div class=col-xs-5> <button class="btn btn-primary" ng-click=vm.openModalAddUpstreamFn()>添加</button> </div> </div> <div class=form-group ng-if="vm.service.upstream_ips&&vm.service.upstream_ips.length!==0"> <div class="col-xs-10 col-xs-offset-2 col-lg-11 col-lg-offset-1"> <table class="table table-vcenter table-striped table-bordered"> <thead> <tr> <th>源站</th> <th>源站端口</th> <th>回源策略</th> <th>备用</th> <th>操作</th> </tr> </thead> <tbody> <tr></tr> <tr ng-repeat="(index, ip) in vm.service.upstream_ips track by $index"> <td>{{ip.ip}}</td> <td>{{ip.port}}{{ip.port_end&&ip.port!=ip.port_end?\'-\'+ip.port_end:\'\'}}</td> <td>{{ip.lock?(ip.isp | adsIspToZH):\'自动\'}}回源</td> <td>{{ip.backup | adsBoolToZH}}</td> <td> <div> <button class="btn btn-link" ng-click=vm.openModalAddUpstreamFn(index)>编辑</button> <span class=text-muted style=margin:10px>│</span> <button class="btn btn-link" ng-click=vm.service.upstream_ips.splice(index,1)>删除</button> </div> </td> </tr> </tbody> </table> </div> </div> </fieldset> <div class=form-group> <div class="col-xs-5 col-xs-offset-2 col-lg-offset-1"> <button class="btn btn-primary" ng-click=Form.$setSubmitted();Form.$valid&&vm.saveServiceFn() ng-disabled="vm.meal.order_status!=1||!base.authority">保存配置</button> </div> </div> </div> </div> </div> <script type=text/ng-template id=addos/service/modalAlert.html> <div class="ads-scope">\n    <div class="modal-header">\n      <button type="button" class="close" ng-click="$dismiss()">\n        <span aria-hidden="true">&times;</span>\n      </button>\n      <h3 class="modal-title">不保存配置并返回</h3>\n    </div>\n    <div class="modal-body">\n      <div style="display:flex;align-items:center">\n        <div style="margin:0px 20px">\n          <i class="fa fa-question-circle fa-5x text-primary"></i>\n        </div>\n        <div>\n          <div>确认不保存配置吗？</div>\n          <div>返回后已填写的数据将失效</div>\n        </div>\n      </div>\n    </div>\n    <div class="modal-footer">\n      <button class="btn btn-default" ng-click="$dismiss()">取消</button>\n      <button class="btn btn-primary" ng-click="$close()">确认返回</button>\n    </div>\n  </div> </script> <script type=text/ng-template id=addos/service/modalAddKeyLess.html> <div class="ads-scope">\n    <div class="modal-header">\n      <button type="button" class="close" ng-click="$dismiss()">\n        <span aria-hidden="true">&times;</span>\n      </button>\n      <h3 class="modal-title">添加KeyLess</h3>\n    </div>\n    <div class="modal-body">\n      <div class="form-horizontal" ng-form="Form">\n        <div class="form-group" ng-class="{\'has-error\': (Form.$submitted||Form.ip.$dirty)&&Form.ip.$invalid}">\n          <label class="col-xs-3 control-label">Server IP</label>\n          <div class="col-xs-9">\n            <input class="form-control" name="ip" v-ip ng-model="vm.keyserver.ip"></input>\n            <p class="help-block v-msg" ng-show="(Form.$submitted||Form.ip.$dirty)&&Form.ip.$invalid"></p>\n          </div>\n        </div>\n        <div class="form-group" ng-class="{\'has-error\': (Form.$submitted||Form.port.$dirty)&&Form.port.$invalid}">\n          <label class="col-xs-3 control-label">端口</label>\n          <div class="col-xs-9">\n            <input class="form-control" name="port" v-port ng-model="vm.keyserver.port" placeholder="仅可输入数字，范围是1到65535"></input>\n            <p class="help-block v-msg" ng-show="(Form.$submitted||Form.port.$dirty)&&Form.port.$invalid"></p>\n          </div>\n        </div>\n        <div class="form-group">\n          <label class="col-xs-3 control-label">IP线路</label>\n          <div class="col-xs-9">\n            <label class="radio-inline">\n              <input type="radio" ng-model="vm.keyserver.isp" value="mobile">\n              移动\n            </label>\n            <label class="radio-inline">\n              <input type="radio" ng-model="vm.keyserver.isp" value="unicom">\n              联通\n            </label>\n            <label class="radio-inline">\n              <input type="radio" ng-model="vm.keyserver.isp" value="telecom">\n              电信\n            </label>\n          </div>\n        </div>\n      </div>\n    </div>\n    <div class="modal-footer">\n      <button class="btn btn-default" ng-click="$dismiss()">取消</button>\n      <button class="btn btn-primary" ng-click="Form.$setSubmitted();Form.$valid&&$close(vm.keyserver)">确认</button>\n    </div>\n  </div> </script> '
}, function(t, e) {
    t.exports = '<div class="block full"> <div class=block-title> <h2><strong>套餐状态-黑白名单</strong></h2><a ui-sref=ads.meal.default> &laquo; 返回 </a> </div> <div> <uib-tabset active=$stateParams.tab> <uib-tab index="\'black_ip\'" heading=IP黑名单 select="$state.go(\'.\',{tab:\'black_ip\'},{notify: false})"> <div class=text-right style="margin:10px auto"> <button class="btn btn-primary" ng-click="vm.openModalAddFn(\'black_ip\')" ng-disabled="vm.meal.order_status!=1||!base.authority">添加</button> </div> <table class="table table-vcenter table-striped table-bordered"> <thead> <tr> <th>序号</th> <th>IP或IP段</th> <th>操作</th> </tr> </thead> <tbody> <tr></tr> <tr ng-if="!vm.meal.black_ip.list||vm.meal.black_ip.list.length===0"> <td colspan=3>没有数据</td> </tr> <tr ng-repeat="(key, ip) in vm.meal.black_ip.list track by $index"> <td> {{key + 1}} </td> <td> {{ip}} </td> <td> <button class="btn btn-link" ng-click="vm.openModalDeleteFn(\'black_ip\', ip)" ng-disabled="vm.meal.order_status!=1||!base.authority">删除</button> </td> </tr> </tbody> </table> </uib-tab> <uib-tab index="\'white_ip\'" heading=IP白名单 select="$state.go(\'.\',{tab:\'white_ip\'},{notify: false})"> <div class=text-right style="margin:10px auto"> <button class="btn btn-primary" ng-click="vm.openModalAddFn(\'white_ip\')" ng-disabled="vm.meal.order_status!=1||!base.authority">添加</button> </div> <table class="table table-vcenter table-striped table-bordered"> <thead> <tr> <th>序号</th> <th>IP或IP段</th> <th>操作</th> </tr> </thead> <tbody> <tr></tr> <tr ng-if="!vm.meal.white_ip.list||vm.meal.white_ip.list.length===0"> <td colspan=3>没有数据</td> </tr> <tr ng-repeat="(key, ip) in vm.meal.white_ip.list track by $index"> <td> {{key + 1}} </td> <td> {{ip}} </td> <td> <button class="btn btn-link" ng-click="vm.openModalDeleteFn(\'white_ip\', ip)" ng-disabled="vm.meal.order_status!=1||!base.authority">删除</button> </td> </tr> </tbody> </table> </uib-tab> <uib-tab index="\'black_url\'" heading=URL黑名单 select="$state.go(\'.\',{tab:\'black_url\'},{notify: false})"> <div class=text-right style="margin:10px auto"> <button class="btn btn-primary" ng-click="vm.openModalAddFn(\'black_url\')" ng-disabled="vm.meal.order_status!=1||!base.authority">添加</button> </div> <table class="table table-vcenter table-striped table-bordered"> <thead> <tr> <th>序号</th> <th>URL</th> <th>操作</th> </tr> </thead> <tbody> <tr></tr> <tr ng-if="!vm.meal.black_url.list||vm.meal.black_url.list.length===0"> <td colspan=3>没有数据</td> </tr> <tr ng-repeat="(key, url) in vm.meal.black_url.list track by $index"> <td> {{key + 1}} </td> <td> {{url}} </td> <td> <button class="btn btn-link" ng-click="vm.openModalDeleteFn(\'black_url\', url)" ng-disabled="vm.meal.order_status!=1||!base.authority">删除</button> </td> </tr> </tbody> </table> </uib-tab> <uib-tab index="\'white_url\'" heading=URL白名单 select="$state.go(\'.\',{tab:\'white_url\'},{notify: false})"> <div class=text-right style="margin:10px auto"> <button class="btn btn-primary" ng-click="vm.openModalAddFn(\'white_url\')" ng-disabled="vm.meal.order_status!=1||!base.authority">添加</button> </div> <table class="table table-vcenter table-striped table-bordered"> <thead> <tr> <th>序号</th> <th>URL</th> <th>操作</th> </tr> </thead> <tbody> <tr></tr> <tr ng-if="!vm.meal.white_url.list||vm.meal.white_url.list.length===0"> <td colspan=3>没有数据</td> </tr> <tr ng-repeat="(key, url) in vm.meal.white_url.list track by $index"> <td> {{key + 1}} </td> <td> {{url}} </td> <td> <button class="btn btn-link" ng-click="vm.openModalDeleteFn(\'white_url\', url)" ng-disabled="vm.meal.order_status!=1||!base.authority">删除</button> </td> </tr> </tbody> </table> </uib-tab> </uib-tabset> </div> </div> <script type=text/ng-template id=modalAdd.html> <div class="ads-scope">\n    <div class="modal-header">\n      <button type="button" class="close" ng-click="$dismiss()"><span aria-hidden="true">&times;</span></button>\n      <h3 class="modal-title" ng-if="$stateParams.tab.indexOf(\'black\')>-1">添加黑名单</h3>\n      <h3 class="modal-title" ng-if="$stateParams.tab.indexOf(\'white\')>-1">添加白名单</h3>\n    </div>\n    <div class="modal-body">\n      <div class="form-horizontal" ng-form="Form">\n        <div class="form-group" ng-show="$stateParams.tab.indexOf(\'ip\')>-1" ng-class="{\'has-error\': (Form.$submitted||Form.ip.$dirty)&&Form.ip.$invalid}">\n          <label class="col-xs-2 control-label">IP或IP段</label>\n          <div class="col-xs-10">\n            <textarea name="ip" v-ip-range class="form-control" rows="4" ng-model="vm.ip" placeholder="填写多个IP时，以英文逗号分隔，IP段可采用掩码形式如192.168.0.1/24；也可以以指定IP起始和终止的形式进行填写，如192.168.1.1-192.168.1.255" style="resize: none;"></textarea>\n            <p class="help-block v-msg" ng-show="(Form.$submitted||Form.ip.$dirty)&&Form.ip.$invalid"></p>\n          </div>\n        </div>\n        <div class="form-group" ng-show="$stateParams.tab.indexOf(\'url\')>-1" ng-class="{\'has-error\': (Form.$submitted||Form.url.$dirty)&&Form.url.$invalid}">\n          <label class="col-xs-2 control-label">URL</label>\n          <div class="col-xs-10">\n            <input name="url" v-url class="form-control" ng-model="vm.url" placeholder="url地址填写示例：www.xxx.com/url/content-111.html" style="resize: none;"></input>\n            <p class="help-block v-msg" ng-show="(Form.$submitted||Form.url.$dirty)&&Form.url.$invalid"></p>\n          </div>\n        </div>\n      </div>\n    </div>\n    <div class="modal-footer">\n      <button class="btn btn-default" ng-click="$dismiss()">取消</button>\n      <button class="btn btn-primary" ng-click="Form.$setSubmitted();(Form.ip.$valid||Form.url.$valid)&&$close(vm)">确认添加</button>\n    </div>\n  </div> </script> <script type=text/ng-template id=modalDelete.html> <div class="ads-scope">\n    <div class="modal-header">\n      <button type="button" class="close" ng-click="$dismiss()"><span aria-hidden="true">&times;</span></button>\n      <h3 class="modal-title" ng-if="$stateParams.tab.indexOf(\'black\')>-1">删除黑名单</h3>\n      <h3 class="modal-title" ng-if="$stateParams.tab.indexOf(\'white\')>-1">删除白名单</h3>\n    </div>\n    <div class="modal-body">\n      <div style="display:flex;align-items:center">\n        <div style="margin:0px 20px">\n          <i class="fa fa-question-circle fa-5x text-primary"></i>\n        </div>\n        <div>\n          <div>确认删除？</div>\n          <div>删除后，将不可恢复！</div>\n        </div>\n      </div>\n    </div>\n    <div class="modal-footer">\n      <button class="btn btn-default" ng-click="$dismiss()">取消</button>\n      <button class="btn btn-primary" ng-click="$close()">确认删除</button>\n    </div>\n  </div> </script> '
}, function(t, e) {
    t.exports = '<div class=report> <h4><strong>DDoS攻击流量数据</strong></h4> <div class=row> <div class=col-sm-12> <div class="block full"> <title-and-selector ips=vm.meal.ads_ip on-apply="vm.fetchDdosBytes(ip, start_time, end_time, time_scale)">攻击流量</title-and-selector> <echarts option=vm.ddosBytesOption></echarts> </div> </div> </div> <h4><strong>HTTP/HTTPS(CC防御)</strong></h4> <div class=row> <div class=col-sm-6> <div class="block full"> <title-and-selector ips=vm.meal.ads_ip on-apply="vm.fetchCcRequest(ip, start_time, end_time, time_scale)">访问数据</title-and-selector> <echarts option=vm.ccRequestOption></echarts> </div> </div> <div class=col-sm-6> <div class="block full"> <title-and-selector ips=vm.meal.ads_ip on-apply="vm.fetchCcUpRequest(ip, start_time, end_time, time_scale)">回源数据</title-and-selector> <echarts option=vm.ccUpRequestOption></echarts> </div> </div> </div> <div class=row> <div class=col-sm-6> <div class="block full"> <title-and-selector ips=vm.meal.ads_ip on-apply="vm.fetchCcBytes(ip, start_time, end_time, time_scale)">访问流量</title-and-selector> <echarts option=vm.ccBytesOption></echarts> </div> </div> <div class=col-sm-6> <div class="block full"> <title-and-selector ips=vm.meal.ads_ip on-apply="vm.fetchCcUpBytes(ip, start_time, end_time, time_scale)">回源流量</title-and-selector> <echarts option=vm.ccUpBytesOption></echarts> </div> </div> </div> <h4><strong>TCP空连接防御</strong></h4> <div class=row> <div class=col-sm-6> <div class="block full"> <title-and-selector ips=vm.meal.ads_ip on-apply="vm.fetchTcpRequest(ip, start_time, end_time, time_scale)">防御数据</title-and-selector> <echarts option=vm.tcpRequestOption></echarts> </div> </div> <div class=col-sm-6> <div class="block full"> <title-and-selector ips=vm.meal.ads_ip on-apply="vm.fetchTcpUpRequest(ip, start_time, end_time, time_scale)">回源数据</title-and-selector> <echarts option=vm.tcpUpRequestOption></echarts> </div> </div> </div> </div> '
}]));

